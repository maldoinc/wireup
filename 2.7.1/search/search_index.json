{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Overview","text":"<p>Performant, concise and type-safe Dependency Injection for Python.</p> <p> </p> <p>Automate dependency management using Python's type system. Build complex applications with native support for async and generators, plus integrations for popular frameworks out of the box. Wireup is thread-safe for concurrent dependency resolution and ready for no-GIL Python (PEP 703).</p> <p>Zero Runtime Overhead</p> <p>New: Inject Dependencies in FastAPI with zero runtime overhead using Class-Based Handlers.</p>"},{"location":"#clean-type-safe-di","title":"\u26a1 Clean &amp; Type-Safe DI","text":"<p>Use decorators and annotations for concise, co-located definitions, or factories to keep your domain model pure and decoupled.</p> 1. Basic Usage2. Inject Configuration3. Clean Architecture <p>Start simple. Register classes directly using decorators and let the container resolve dependencies automatically.</p> <pre><code>@injectable\nclass Database:\n    def __init__(self) -&gt; None:\n        self.engine = sqlalchemy.create_engine(\"sqlite://\")\n\n\n@injectable\nclass UserService:\n    def __init__(self, db: Database) -&gt; None:\n        self.db = db\n\n\n# Now that the dependencies are defined, register them with the container.\n# You can pass a list of classes, functions, or even modules to be scanned.\ncontainer = wireup.create_sync_container(injectables=[Database, UserService])\nuser_service = container.get(UserService)  # \u2705 Dependencies resolved.\n</code></pre> <p>Wireup containers can store and inject configuration. This enables self-contained definitions without having to create factories for every injectable.</p> <pre><code>@injectable\nclass Database:\n    # Inject \"db_url\" from the container configuration.\n    def __init__(self, url: Annotated[str, Inject(config=\"db_url\")]) -&gt; None:\n        self.engine = sqlalchemy.create_engine(url)\n\n\n@injectable\nclass UserService:\n    def __init__(self, db: Database) -&gt; None:\n        self.db = db\n\n\ncontainer = wireup.create_sync_container(\n    injectables=[Database, UserService], config={\"db_url\": os.environ[\"DB_URL\"]}\n)\nuser_service = container.get(UserService)  # \u2705 Dependencies resolved.\n</code></pre> <p>Need strict boundaries? Use factories to wire pure domain objects and integrate external libraries like Pydantic.</p> Domain Layer<pre><code># 1. No Wireup imports\nclass Database:\n    def __init__(self, url: str) -&gt; None:\n        self.engine = create_engine(url)\n\n\n# 2. Configuration (Pydantic)\nclass Settings(BaseModel):\n    db_url: str = \"sqlite://\"\n</code></pre> Wiring<pre><code># 3. Wireup factories\n@injectable\ndef make_settings() -&gt; Settings:\n    return Settings()\n\n\n@injectable\ndef make_database(settings: Settings) -&gt; Database:\n    return Database(url=settings.db_url)\n\n\ncontainer = wireup.create_sync_container(\n    injectables=[make_settings, make_database]\n)\ndatabase = container.get(Database)  # \u2705 Dependencies resolved.\n</code></pre>"},{"location":"#function-injection","title":"\ud83c\udfaf Function Injection","text":"<p>Inject dependencies directly into any function. This is useful for CLI commands, background tasks, event handlers, or any standalone function that needs access to the container.</p> <pre><code>@inject_from_container(container)\ndef migrate_database(db: Injected[Database], settings: Injected[Settings]):\n    # \u2705 Database and Settings injected.\n    pass\n</code></pre>"},{"location":"#interfaces-abstractions","title":"\ud83d\udcdd Interfaces &amp; Abstractions","text":"<p>Define abstract types and have the container automatically inject the implementation.</p> <pre><code>class Notifier(Protocol):\n    def notify(self) -&gt; None: ...\n\n\n@injectable(as_type=Notifier)\nclass SlackNotifier:\n    def notify(self) -&gt; None: ...\n\n\ncontainer = create_sync_container(injectables=[SlackNotifier])\nnotifier = container.get(Notifier)  # \u2705 SlackNotifier instance.\n</code></pre>"},{"location":"#managed-lifetimes","title":"\ud83d\udd04 Managed Lifetimes","text":"<p>Declare dependencies as singletons, scoped, or transient to control whether to inject a fresh copy or reuse existing instances.</p> SingletonScopedTransient <p>One instance per application. <code>@injectable(lifetime=\"singleton\")</code> is the default.</p> <pre><code>@injectable\nclass Database:\n    pass\n</code></pre> <p>One instance per scope/request, shared within that scope/request.</p> <pre><code>@injectable(lifetime=\"scoped\")\nclass RequestContext:\n    def __init__(self) -&gt; None:\n        self.request_id = uuid4()\n</code></pre> <p>When full isolation and clean state is required. Every request to create transient dependencies results in a new instance.</p> <pre><code>@injectable(lifetime=\"transient\")\nclass OrderProcessor:\n    pass\n</code></pre>"},{"location":"#flexible-creation-patterns","title":"\ud83c\udfed Flexible Creation Patterns","text":"<p>Defer instantiation to specialized factories when complex initialization or cleanup is required. Full support for async and generators. Wireup handles cleanup at the correct time depending on the injectable lifetime.</p> SynchronousAsync <pre><code>class WeatherClient:\n    def __init__(self, client: requests.Session) -&gt; None:\n        self.client = client\n\n\n@injectable\ndef weather_client_factory() -&gt; Iterator[WeatherClient]:\n    with requests.Session() as session:\n        yield WeatherClient(client=session)\n</code></pre> <pre><code>class WeatherClient:\n    def __init__(self, client: aiohttp.ClientSession) -&gt; None:\n        self.client = client\n\n\n@injectable\nasync def weather_client_factory() -&gt; AsyncIterator[WeatherClient]:\n    async with aiohttp.ClientSession() as session:\n        yield WeatherClient(client=session)\n</code></pre> <p>Need reusable provider-style wiring with different runtime settings? See Reusable Factory Bundles.</p>"},{"location":"#optional-dependencies","title":"\u2753 Optional Dependencies","text":"<p>Wireup has first-class support for <code>Optional[T]</code> and <code>T | None</code>. Expose optional dependencies and let Wireup handle the rest.</p> <pre><code>@injectable\ndef make_cache(settings: Settings) -&gt; RedisCache | None:\n    return RedisCache(settings.redis_url) if settings.cache_enabled else None\n\n\n@injectable\nclass UserService:\n    def __init__(self, cache: RedisCache | None):\n        self.cache = cache\n\n\n# You can also retrieve optional dependencies directly\ncache = container.get(RedisCache | None)\n</code></pre>"},{"location":"#static-analysis","title":"\ud83d\udee1\ufe0f Static Analysis","text":"<p>Wireup validates your entire dependency graph at container creation. If the container starts, you can be confident there won't be runtime surprises from missing dependencies or misconfigurations.</p> <p>Checks performed at startup:</p> <ul> <li>Missing dependencies and unknown types</li> <li>Circular dependencies</li> <li>Lifetime mismatches (e.g., singletons depending on scoped/transient)</li> <li>Missing or invalid configuration keys</li> <li>Duplicate registrations</li> </ul> Container CreationFunction InjectionConfiguration <p>The container validates everything when created.</p> <pre><code>@injectable\nclass Foo:\n    def __init__(self, unknown: NotManagedByWireup) -&gt; None: ...\n\n\ncontainer = wireup.create_sync_container(injectables=[Foo])\n# \u274c Parameter 'unknown' of 'Foo' depends on an unknown injectable 'NotManagedByWireup'.\n</code></pre> <p>Decorated functions are validated at import time, not when called.</p> <pre><code>@inject_from_container(container)\ndef my_function(oops: Injected[NotManagedByWireup]): ...\n\n\n# \u274c Parameter 'oops' of 'my_function' depends on an unknown injectable 'NotManagedByWireup'.\n</code></pre> <p>Configuration injection is also validated at startup.</p> <pre><code>@injectable\nclass Database:\n    def __init__(self, url: Annotated[str, Inject(config=\"db_url\")]) -&gt; None:\n        self.url = url\n\n\n# \u274c Parameter 'url' of Type 'Database' depends on an unknown Wireup config key 'db_url'.\n</code></pre>"},{"location":"#framework-independent","title":"\ud83d\udccd Framework Independent","text":"<p>With Wireup, business logic is decoupled from your runtime. Define injectables once and reuse them across Web Applications, CLI Tools, and Task Queues without duplication or refactoring.</p> <pre><code># 1. Define your Service Layer once (e.g. in my_app.services)\n# injectables = [UserService, Database, ...]\n\n\n# 2. Run in FastAPI\n@app.get(\"/\")\n@inject_from_container(container)\nasync def view(service: Injected[UserService]): ...\n\n\n# 3. Run in CLI\n@click.command()\n@inject_from_container(container)\ndef command(service: Injected[UserService]): ...\n\n\n# 4. Run in Workers (Celery)\n@app.task\n@inject_from_container(container)\ndef task(service: Injected[UserService]): ...\n</code></pre>"},{"location":"#native-integration-with-popular-frameworks","title":"\ud83d\udd0c Native Integration with popular frameworks","text":"<p>Integrate with popular frameworks for a smoother developer experience. Integrations manage request scopes, injection in endpoints, and dependency lifetimes.</p> Full FastAPI example<pre><code>app = FastAPI()\ncontainer = create_async_container(injectables=[UserService, Database])\n\n\n@app.get(\"/\")\ndef users_list(user_service: Injected[UserService]):\n    pass\n\n\nwireup.integration.fastapi.setup(container, app)\n</code></pre> <p>View all integrations \u2192</p>"},{"location":"#simplified-testing","title":"\ud83e\uddea Simplified Testing","text":"<p>Wireup decorators only collect metadata. Injectables remain plain classes or functions with no added magic to them. Test them directly with mocks or fakes, no special setup required.</p> <p>You can also use <code>container.override</code> to swap dependencies during tests:</p> <pre><code>with container.override.injectable(target=Database, new=in_memory_database):\n    # The /users endpoint depends on Database.\n    # During the lifetime of this context manager, requests to inject `Database`\n    # will result in `in_memory_database` being injected instead.\n    response = client.get(\"/users\")\n</code></pre>"},{"location":"#installation","title":"\ud83d\udce6 Installation","text":"<pre><code>pip install wireup\n</code></pre>"},{"location":"#next-steps","title":"Next Steps","text":"<ul> <li>Getting Started - Follow the Getting Started guide for a more in-depth tutorial.</li> <li>Injectables</li> <li>Configuration</li> <li>Factories - Includes advanced patterns like Reusable Factory Bundles.</li> </ul>"},{"location":"configuration/","title":"Configuration","text":"<p>Wireup containers can store and inject configuration. This enables self-contained definitions without having to create factories for every injectable.</p>"},{"location":"configuration/#loading-configuration","title":"Loading Configuration","text":"<p>Configuration is passed to the container during creation as a dictionary.</p> <pre><code>import wireup\nimport os\n\ncontainer = wireup.create_sync_container(\n    config={\n        \"database_url\": os.environ[\"DB_CONNECTION_STRING\"],\n        \"env\": os.environ.get(\"APP_ENV\", \"production\"),\n        \"max_connections\": 100,\n    }\n)\n</code></pre>"},{"location":"configuration/#injecting-configuration","title":"Injecting Configuration","text":""},{"location":"configuration/#primitives-key-value","title":"Primitives (Key-Value)","text":"<p>Inject specific values by key using <code>Inject(config=\"key\")</code>.</p> <pre><code>from typing import Annotated\nfrom wireup import injectable, Inject\n\n\n@injectable\nclass DatabaseService:\n    def __init__(\n        self,\n        # Injects the value of \"database_url\" from the config dict\n        url: Annotated[str, Inject(config=\"database_url\")],\n    ) -&gt; None:\n        self.url = url\n</code></pre>"},{"location":"configuration/#dot-notation-nested-configuration","title":"Dot Notation (Nested Configuration)","text":"<p>Access nested configuration values using dot notation. Wireup allows you to inject configuration from any point in the tree, not just leaf values.</p> <pre><code>import wireup\nfrom typing import Annotated, Any\nfrom wireup import injectable, Inject\n\ncontainer = wireup.create_sync_container(\n    config={\n        \"db\": {\n            \"host\": \"localhost\",\n            \"port\": 5432,\n            \"options\": {\"timeout\": 30},\n        },\n    }\n)\n\n\n@injectable\nclass DatabaseService:\n    def __init__(\n        self,\n        # Injects \"localhost\"\n        host: Annotated[str, Inject(config=\"db.host\")],\n        # Injects 5432\n        port: Annotated[int, Inject(config=\"db.port\")],\n        # Injects the entire dictionary: {\"timeout\": 30}\n        # You can inject any value from the config, not just primitives.\n        options: Annotated[dict[str, Any], Inject(config=\"db.options\")],\n        # Injects the whole 'db' config: {\"host\": \"...\", \"port\": ..., \"options\": ...}\n        db_config: Annotated[dict[str, Any], Inject(config=\"db\")],\n    ) -&gt; None:\n        self.host = host\n</code></pre>"},{"location":"configuration/#structured-objects","title":"Structured Objects","text":"<p>You are not limited to primitives. You can inject entire configuration objects, such as Dataclasses or Pydantic models. This allows you to group related settings and inject only what a service needs.</p> DataclassPydantic <pre><code>from dataclasses import dataclass\n\n\n@dataclass\nclass DatabaseConfig:\n    url: str\n    max_connections: int\n\n\ncontainer = wireup.create_sync_container(\n    config={\"db_config\": DatabaseConfig(url=\"...\", max_connections=10)},\n    injectables=[...],\n)\n</code></pre> <pre><code>from pydantic_settings import BaseSettings\n\n\nclass DatabaseSettings(BaseSettings):\n    url: str\n    max_connections: int = 10\n\n\ncontainer = wireup.create_sync_container(\n    config={\"db\": DatabaseSettings()},  # Loads from env automatically\n    injectables=[...],\n)\n</code></pre> <p>Then inject the configuration object:</p> <pre><code>import sqlite3\n\n\n@injectable\nclass DatabaseService:\n    def __init__(\n        self, config: Annotated[DatabaseConfig, Inject(config=\"db_config\")]\n    ) -&gt; None:\n        self.connection = sqlite3.connect(config.url)\n</code></pre>"},{"location":"configuration/#interpolation","title":"Interpolation","text":"<p>You can create dynamic configuration values by interpolating other configuration keys using the <code>${key}</code> syntax.</p> <pre><code># config = {\"env\": \"prod\", \"host\": \"localhost\", \"port\": 5432}\n\n\n@injectable\nclass FileStorageService:\n    def __init__(\n        self,\n        # Becomes \"/tmp/uploads/prod\"\n        upload_path: Annotated[str, Inject(expr=\"/tmp/uploads/${env}\")],\n        # Becomes \"postgresql://localhost:5432/mydb\"\n        db_url: Annotated[\n            str, Inject(expr=\"postgresql://${host}:${port}/mydb\")\n        ],\n    ) -&gt; None:\n        self.upload_path = upload_path\n</code></pre> <p>Expression results are strings</p> <p>Configuration expressions always return strings. Non-string configuration values are converted using <code>str()</code> before interpolation.</p>"},{"location":"configuration/#aliasing-configuration-keys","title":"Aliasing Configuration Keys","text":"<p>Avoid repeating string keys across your codebase by creating type aliases. This also makes refactoring easier if configuration keys change.</p> <pre><code># Create an alias for the configuration injection\nEnvConfig = Annotated[str, Inject(config=\"env\")]\n\n\n# Use the alias instead of repeating Inject(config=\"env\")\ndef list_users(env: EnvConfig) -&gt; None: ...\ndef get_users(env: EnvConfig) -&gt; None: ...\n</code></pre>"},{"location":"configuration/#next-steps","title":"Next Steps","text":"<ul> <li>Lifetimes &amp; Scopes - Control how long objects live.</li> <li>Factories - Create complex dependencies and third-party objects.</li> <li>Testing - Override configuration values for testing.</li> </ul>"},{"location":"container/","title":"Container","text":"<p>The container is the object responsible for creating and managing your application's dependencies. When you request a dependency, whether via type hints, <code>container.get()</code>, or a framework integration, the container builds it and any dependencies it requires.</p> <p>In practice, you mainly interact with the container directly during setup. Once configured, dependencies flow automatically through type hints and decorators.</p>"},{"location":"container/#creation","title":"Creation","text":"<p>Wireup provides two ways to create containers, depending on whether your application is synchronous or asynchronous.</p>"},{"location":"container/#create_sync_container","title":"<code>create_sync_container</code>","text":"<p>Use this for traditional, blocking Python applications (e.g., Flask, Django, scripts).</p> <pre><code>container = wireup.create_sync_container(injectables=[...], config={...})\n</code></pre>"},{"location":"container/#create_async_container","title":"<code>create_async_container</code>","text":"<p>Use this for <code>async/await</code> based applications (e.g., FastAPI, Starlette). It supports <code>async</code> factories and has <code>async</code> methods for retrieval and cleanup.</p> <pre><code>container = wireup.create_async_container(injectables=[...], config={...})\n</code></pre>"},{"location":"container/#arguments","title":"Arguments","text":"<p>Both creation functions accept the following arguments:</p> Argument Type Description <code>injectables</code> <code>list[Union[type, Callable, ModuleType]]</code> Classes, functions decorated with <code>@injectable</code>, or modules to scan. Modules are scanned recursively, collecting only items decorated with <code>@injectable</code>. For reusable provider-style wiring (same graph, different runtime settings), see Factories: Reusable Factory Bundles. <code>config</code> <code>dict[str, Any]</code> Configuration dictionary. Values from this dictionary can be injected using <code>Inject(config=\"key\")</code>. <code>concurrent_scoped_access</code> <code>bool</code> Set to <code>True</code> if you share scopes across multiple threads/tasks. Defaults to <code>False</code>. See Lifetimes &amp; Scopes: Concurrent Access for details. <p>Multiple Containers</p> <p>The <code>@injectable</code> decorator only stores metadata, it doesn't register anything globally. Each container you create is fully independent with its own state.</p>"},{"location":"container/#core-api","title":"Core API","text":""},{"location":"container/#get","title":"<code>get</code>","text":"<p>Retrieve an instance of a registered injectable.</p> SynchronousAsync <pre><code>db = container.get(Database)\nreadonly_db = container.get(Database, qualifier=\"readonly\")\n</code></pre> <pre><code>db = await container.get(Database)\nreadonly_db = await container.get(Database, qualifier=\"readonly\")\n</code></pre> <p>Qualifiers: Use the <code>qualifier</code> argument to retrieve specific implementations when multiple are registered. See Interfaces for more details.</p> <p>Important</p> <p>Prefer constructor-based dependency injection over calling <code>get</code> directly. Use <code>get</code> as an escape hatch for advanced scenarios like dynamic service lookup or when working with framework integration code.</p>"},{"location":"container/#close","title":"<code>close</code>","text":"<p>Clean up the container and release resources. This triggers the cleanup phase of any generator-based factories.</p> SynchronousAsync <pre><code>container.close()\n</code></pre> <pre><code>await container.close()\n</code></pre>"},{"location":"container/#enter_scope","title":"<code>enter_scope</code>","text":"<p>Create a scoped container. Scoped containers manage their own scoped and transient dependencies while sharing singletons with the root container. See Lifetimes &amp; Scopes for details on how scopes work.</p> SynchronousAsync <pre><code>with container.enter_scope() as scoped:\n    db_session = scoped.get(DbSession)  # Fresh instance per scope\n</code></pre> <pre><code>async with container.enter_scope() as scoped:\n    db_session = await scoped.get(DbSession)  # Fresh instance per scope\n</code></pre> <p>See Lifetimes &amp; Scopes for details.</p>"},{"location":"container/#config","title":"<code>config</code>","text":"<p>Access configuration values directly from the container. This provides programmatic access to the configuration dictionary passed during container creation.</p> <pre><code>env = container.config.get(\"app_env\")\ndb_url = container.config.get(\"database_url\")\n</code></pre> <p>Important</p> <p>Prefer <code>Inject(config=\"key\")</code> in dependency constructors over accessing <code>container.config</code> directly.</p>"},{"location":"container/#override","title":"<code>override</code>","text":"<p>Substitute dependencies for testing. Access via <code>container.override</code>.</p> <pre><code>with container.override.injectable(target=Database, new=mock_db):\n    ...  # All injections of Database use mock_db\n</code></pre> <p>See Testing for details.</p>"},{"location":"container/#eager-initialization","title":"Eager Initialization","text":"<p>By default, objects are created lazily when first requested. To avoid latency on first request for expensive services, initialize them at startup:</p> <pre><code>for dependency in [HeavyComputeService, MLModelService, Database]:\n    container.get(dependency)  # or `await container.get(dependency)` for async\n</code></pre>"},{"location":"container/#next-steps","title":"Next Steps","text":"<ul> <li>Lifetimes &amp; Scopes - Control how long objects live.</li> <li>Factories - Create complex dependencies and third-party objects.</li> <li>Testing - Override dependencies and test with the container.</li> </ul>"},{"location":"factories/","title":"Factories","text":"<p>Use factories to handle complex creation logic, instantiate third-party classes, or manage resources that can't be handled by simple class constructors.</p>"},{"location":"factories/#third-party-classes","title":"Third-party Classes","text":"<p>You can't add <code>@injectable</code> to code you don't own. Factories solve this by wrapping third-party classes in a function you control. The factory creates and configures the object, and Wireup registers it by the return type.</p> <p>Example: Redis Client</p> <pre><code>from typing import Annotated\n\nimport redis\nfrom wireup import Inject, injectable\n\n\n@injectable\ndef redis_factory(\n    url: Annotated[str, Inject(config=\"redis_url\")],\n) -&gt; redis.Redis:\n    return redis.from_url(url)\n\n\n# Usage:\n@injectable\nclass AuthService:\n    def __init__(self, cache: redis.Redis):\n        self.cache = cache\n</code></pre>"},{"location":"factories/#pure-domain-objects","title":"Pure Domain Objects","text":"<p>If you prefer to keep your domain layer free of Wireup imports, don't use <code>@injectable</code> on those classes. Instead, create factory functions in a separate wiring module that construct and return them.</p> domain/services.py<pre><code># No Wireup imports here\nclass UserService:\n    def __init__(self, repository: UserRepository) -&gt; None:\n        self.repository = repository\n</code></pre> wiring/factories.py<pre><code>from wireup import injectable\nfrom domain.services import UserService\n\n\n@injectable\ndef user_service_factory(repository: UserRepository) -&gt; UserService:\n    return UserService(repository)\n</code></pre>"},{"location":"factories/#complex-initialization","title":"Complex Initialization","text":"<p>Some objects need conditional logic, multi-step setup, or configuration that depends on the environment. Factories let you encapsulate this logic in one place rather than scattering it across your codebase.</p> <pre><code>from wireup import injectable\n\n\n@injectable\ndef db_connection_factory(config: AppConfig) -&gt; DatabaseConnection:\n    timeout = config.timeout if config.is_production else 30\n\n    conn = DatabaseConnection(dsn=config.dsn, timeout=timeout)\n    conn.set_encoding(\"utf-8\")\n\n    return conn\n</code></pre>"},{"location":"factories/#injecting-primitives","title":"Injecting Primitives","text":"<p>If you register two factories that both return <code>str</code>, Wireup can't tell them apart. Use <code>typing.NewType</code> to create distinct types so each primitive can be requested independently.</p> factories.py<pre><code>from typing import NewType\nfrom wireup import injectable\n\nAuthenticatedUsername = NewType(\"AuthenticatedUsername\", str)\n\n\n@injectable(lifetime=\"scoped\")\ndef authenticated_username_factory(auth: AuthService) -&gt; AuthenticatedUsername:\n    user = auth.get_current_user()\n    return AuthenticatedUsername(user.username)\n</code></pre> <p>Usage:</p> <pre><code>from wireup import injectable\n\n\n@injectable(lifetime=\"scoped\")\nclass UserProfileService:\n    def __init__(self, username: AuthenticatedUsername):\n        self.username = username\n</code></pre>"},{"location":"factories/#strategy-pattern","title":"Strategy Pattern","text":"<p>When the correct implementation depends on runtime state (user preferences, feature flags, environment), a factory can inspect other dependencies and return the appropriate one.</p> <pre><code>from typing import Protocol\nfrom wireup import injectable\n\n\nclass Notifier(Protocol):\n    def notify(self, message: str): ...\n\n\n@injectable(lifetime=\"scoped\")\ndef get_user_notifier(\n    user: AuthenticatedUser,\n    slack: SlackNotifier,\n    email: EmailNotifier,\n) -&gt; Notifier:\n    if user.prefers_slack:\n        return slack\n\n    return email\n</code></pre>"},{"location":"factories/#models-and-dtos","title":"Models and DTOs","text":"<p>Sometimes you want to inject data that comes from another service, like the currently authenticated user. A factory can call that service and return the result, making it available as a dependency.</p> <pre><code>from wireup import injectable\n\n\n@injectable(lifetime=\"scoped\")\ndef get_current_user(auth_service: AuthService) -&gt; AuthenticatedUser:\n    return auth_service.get_current_user()\n</code></pre>"},{"location":"factories/#optional-dependencies","title":"Optional Dependencies","text":"<p>Some dependencies are only available under certain conditions, like a cache that's disabled in development. Factories can return <code>None</code> to signal the dependency isn't available, and consumers can handle this gracefully.</p> <p>Registration Required</p> <p>The factory must still be registered even if it returns <code>None</code>. Wireup needs to know how to resolve the specific type, even if the result is nothing.</p> <pre><code>from wireup import injectable\n\n\n@injectable\ndef cache_factory(settings: Settings) -&gt; Redis | None:\n    if not settings.use_cache:\n        return None\n\n    return Redis.from_url(settings.redis_url)\n</code></pre> <p>Requesting Optional Dependencies</p> <pre><code>from wireup import injectable\n\n\n@injectable\nclass UserService:\n    # Use T | None (Python 3.10+) or Optional[T]\n    def __init__(self, cache: Redis | None) -&gt; None:\n        self.cache = cache\n\n    def get(self, user_id: str):\n        if self.cache:\n            return self.cache.get(user_id)\n        # ...\n</code></pre> Null Object Pattern for Optional Dependencies <p>Instead of adding conditional checks throughout your code, use the pattern to handle optional dependencies cleanly. It involves creating a noop implementation that can be used when the real implementation is not available.</p> services/cache.py<pre><code>from typing import Annotated, Any, Protocol\nfrom wireup import Inject, injectable\n\n\nclass Cache(Protocol):\n    def get(self, key: str) -&gt; Any | None: ...\n    def set(self, key: str, value: str) -&gt; None: ...\n\n\nclass RedisCache: ...  # Real Redis implementation\n\n\nclass NullCache:\n    def get(self, key: str) -&gt; Any | None:\n        return None  # Always cache miss\n\n    def set(self, key: str, value: str) -&gt; None:\n        return None  # Do nothing\n\n\n@injectable\ndef cache_factory(\n    redis_url: Annotated[str | None, Inject(config=\"redis_url\")],\n) -&gt; Cache:\n    return RedisCache(redis_url) if redis_url else NullCache()\n</code></pre> <p>Usage</p> Before: Optional DependenciesAfter: Null Pattern <pre><code>@injectable\nclass UserService:\n    def __init__(self, cache: Cache | None):\n        self.cache = cache\n\n    def get_user(self, user_id: str) -&gt; User:\n        # Guard required\n        if self.cache and (cached := self.cache.get(f\"user:{user_id}\")):\n            return User.from_json(cached)\n\n        user = self.db.get_user(user_id)\n\n        # Guard required\n        if self.cache:\n            self.cache.set(f\"user:{user_id}\", user.to_json())\n\n        return user\n</code></pre> <pre><code>@injectable\nclass UserService:\n    def __init__(self, cache: Cache):\n        self.cache = cache  # Always a Cache instance\n\n    def get_user(self, user_id: str) -&gt; User:\n        if cached := self.cache.get(f\"user:{user_id}\"):\n            return User.from_json(cached)\n\n        user = self.db.get_user(user_id)\n        self.cache.set(f\"user:{user_id}\", user.to_json())\n        return user\n</code></pre>"},{"location":"factories/#reusable-factory-bundles","title":"Reusable Factory Bundles","text":"<p>When you need to register the same dependency graph multiple times with different runtime settings, use a parameterized function that returns injectable factories.</p> <p>This is useful for cases like:</p> <ul> <li>Multiple database clients with different connection settings.</li> <li>Tenant-specific integrations.</li> <li>Reusing the same wiring pattern across environments.</li> </ul> <pre><code>from typing import Annotated\nimport wireup\nfrom wireup import Inject, injectable\n\n\nclass DbClient: ...\n\n\nclass DbRepository: ...\n\n\ndef make_db_bundle(*, dsn: str, qualifier: str | None = None) -&gt; list[object]:\n    @injectable(qualifier=qualifier)\n    def db_client_factory() -&gt; DbClient:\n        return DbClient(dsn=dsn)\n\n    @injectable(qualifier=qualifier)\n    def db_repo_factory(\n        client: Annotated[DbClient, Inject(qualifier=qualifier)],\n    ) -&gt; DbRepository:\n        return DbRepository(client=client)\n\n    return [db_client_factory, db_repo_factory]\n\n\nprimary = make_db_bundle(dsn=\"postgresql://primary-db\")\nanalytics = make_db_bundle(\n    dsn=\"postgresql://analytics-db\", qualifier=\"analytics\"\n)\n\ncontainer = wireup.create_sync_container(\n    injectables=[*primary, *analytics, app.services],\n)\n</code></pre> <p>Use an unqualified default (<code>None</code>) for your primary bundle, then add qualifiers only where needed:</p> <pre><code>from typing import Annotated\nfrom wireup import Inject, Injected, injectable\n\n\n@injectable\nclass ReportService:\n    def __init__(\n        self,\n        primary_repo: Injected[DbRepository],\n        analytics_repo: Annotated[DbRepository, Inject(qualifier=\"analytics\")],\n    ) -&gt; None:\n        self.primary_repo = primary_repo\n        self.analytics_repo = analytics_repo\n</code></pre>"},{"location":"function_injection/","title":"Function Injection","text":"<p>The <code>@inject_from_container</code> decorator injects dependencies directly into function parameters. Use this when building your own integration or using Wireup in a framework without built-in support.</p>"},{"location":"function_injection/#basic-usage","title":"Basic Usage","text":"<p>Decorate any function and annotate the parameters you want injected:</p> <pre><code>from typing import Annotated\nfrom wireup import Inject, Injected, inject_from_container\n\n\n@inject_from_container(container)\ndef process_order(\n    order_service: Injected[OrderService],\n    db_url: Annotated[str, Inject(config=\"database_url\")],\n) -&gt; None:\n    order_service.process()\n</code></pre> <p>The decorator:</p> <ol> <li>Creates a new scope before the function runs</li> <li>Injects all annotated parameters from that scope</li> <li>Closes the scope when the function returns (triggering cleanup)</li> </ol>"},{"location":"function_injection/#async-functions","title":"Async Functions","text":"<p>The decorator works with <code>async</code> functions. The container must be created using <code>wireup.create_async_container</code>.</p> <pre><code>@inject_from_container(container)\nasync def process_data(service: Injected[DataService]):\n    await service.process()\n</code></pre> <p>Annotations Required</p> <p>Only parameters annotated with <code>Injected[T]</code> or <code>Annotated[T, Inject(...)]</code> are injected. Unannotated parameters are left alone for the caller to provide.</p>"},{"location":"function_injection/#advanced-usage","title":"Advanced Usage","text":""},{"location":"function_injection/#using-an-existing-scope","title":"Using an Existing Scope","text":"<p>If a scope already exists (e.g., created by middleware), pass a callable that returns it as the second argument. The decorator will use that scope instead of creating a new one.</p> <pre><code>from contextvars import ContextVar\nfrom wireup import ScopedSyncContainer, inject_from_container\n\nscoped_container: ContextVar[ScopedSyncContainer] = ContextVar(\n    \"scoped_container\"\n)\n\n\n@inject_from_container(container, scoped_container.get)\ndef handle_request(service: Injected[RequestService]) -&gt; None: ...\n</code></pre>"},{"location":"function_injection/#creating-a-decorator-alias","title":"Creating a Decorator Alias","text":"<p>For cleaner code, create an alias:</p> <pre><code>inject = inject_from_container(container, scoped_container.get)\n\n\n@inject\ndef handle_request(service: Injected[RequestService]) -&gt; None: ...\n</code></pre> <p>Framework Integrations</p> <p>If you're using FastAPI, Flask, Django, or another supported framework, the integration handles this for you. See Integrations.</p>"},{"location":"function_injection/#api-reference","title":"API Reference","text":""},{"location":"function_injection/#wireupinject_from_container","title":"<code>wireup.inject_from_container</code>","text":"<p>Inject dependencies into the decorated function based on annotations. Wireup containers will attempt to provide only parameters annotated with <code>Inject</code>.</p> <p>See the documentation for more details: https://maldoinc.github.io/wireup/latest/function_injection/</p> <p>Parameters:</p> Name Type Description Default <code>container</code> <code>SyncContainer | AsyncContainer</code> <p>The root container created via <code>wireup.create_sync_container</code> or <code>wireup.create_async_container</code>.</p> required <code>scoped_container_supplier</code> <code>Callable[[], ScopedSyncContainer | ScopedAsyncContainer] | None</code> <p>An optional callable that returns the current scoped container instance. If provided, it will be used to create scoped dependencies. If not provided, the container will automatically enter a scope. Provide a scoped_container_supplier if you need to manage the container's scope manually.</p> <code>None</code> <code>hide_annotated_names</code> <code>bool</code> <p>If True, the parameters annotated with Wireup annotations will be removed from the signature of the decorated function.</p> <code>False</code>"},{"location":"getting_started/","title":"Getting Started","text":"<p>To showcase the basics of Wireup, we will create a container able to inject the following:</p> <ul> <li>A <code>WeatherService</code> that queries a fictional weather api. It needs an api key, a <code>KeyValueStore</code> to cache data and an     async http client to make requests.</li> <li><code>KeyValueStore</code> itself needs a <code>redis_url</code> denoting the server it will connect to to query/store data.</li> </ul> <p>These will then be retrieved in a <code>/weather/forecast</code> endpoint that requires <code>WeatherService</code> to provide weather information.</p> <pre><code>graph LR\n    redis_url[\u2699\ufe0f redis_url] --&gt; KeyValueStore[\ud83d\udc0d KeyValueStore]\n    weather_api_key[\u2699\ufe0f weather_api_key] --&gt; WeatherService\n    KeyValueStore --&gt; WeatherService[\ud83d\udc0d WeatherService]\n    WeatherService --&gt; Route[\ud83c\udf0e /weather/forecast]\n    F[\ud83c\udfed HttpClient] --&gt; WeatherService</code></pre> <p>Tip</p> <p>There will be little <code>+</code> icons in code fragments. You can click on those for more detailed information as to what is happening in that particular line.</p>"},{"location":"getting_started/#1-define-dependencies","title":"1. Define Dependencies","text":"<p>The container uses types and annotations to define dependencies and discover relationships between them. This results in self-contained definitions without having to create factories for every dependency.</p>"},{"location":"getting_started/#keyvaluestore","title":"\ud83d\udc0d <code>KeyValueStore</code>","text":"<p>To create the <code>KeyValueStore</code>, we need a value for <code>redis_url</code>. The <code>@injectable</code> decorator registers the class, and the type hint tells the container to inject the value of the <code>redis_url</code> key into the <code>dsn</code> parameter.</p> services/key_value_store.py<pre><code>from wireup import injectable, Inject\nfrom typing import Annotated\nimport redis\n\n\n@injectable  # (1)!\nclass KeyValueStore:\n    def __init__(\n        self, dsn: Annotated[str, Inject(config=\"redis_url\")]\n    ) -&gt; None:  # (2)!\n        self.client = redis.from_url(dsn)\n</code></pre> <ol> <li>Decorators are only used to collection metadata. This makes testing simpler, as you can still instantiate this like a     regular class in your tests.</li> <li>Since type-based injection is not possible here (there can be many string/int configs after all), config injection     must be annotated with the <code>Inject(config=key)</code> syntax. This tells the container which config key to inject.</li> </ol>"},{"location":"getting_started/#aiohttpclientsession","title":"\ud83c\udfed <code>aiohttp.ClientSession</code>","text":"<p>The http client making requests cannot be instantiated directly as we need to enter an async context manager. To accommodate such cases, Wireup allows you to use functions to create dependencies. These can be sync/async as well as regular or generator functions if cleanup needs to take place.</p> <p>Factories can define their dependencies in the function's signature.</p> <p>When using generator factories make sure to call <code>container.close</code> when the application is terminating for the necessary cleanup to take place.</p> services/factories.py<pre><code>from wireup import injectable\nfrom typing import AsyncIterator\nimport aiohttp\n\n\n@injectable\nasync def http_client_factory() -&gt; AsyncIterator[aiohttp.ClientSession]:\n    async with aiohttp.ClientSession() as client:\n        yield client\n</code></pre>"},{"location":"getting_started/#weatherservice","title":"\ud83d\udc0d <code>WeatherService</code>","text":"<p>Creating <code>WeatherService</code> is also straightforward. The <code>@injectable</code> decorator creates a unique registration for the class. Class dependencies do not need additional annotations, even though the http client is created via an async generator. This is transparently handled by the container.</p> services/weather_service.py<pre><code>from wireup import injectable, Inject\nfrom typing import Annotated\nimport aiohttp\n\n\n@injectable\nclass WeatherService:\n    def __init__(\n        self,\n        api_key: Annotated[str, Inject(config=\"weather_api_key\")],  # (1)!\n        kv_store: KeyValueStore,  # (2)!\n        client: aiohttp.ClientSession,  # (3)!\n    ) -&gt; None: ...\n</code></pre> <ol> <li>Same as above, weather api key needs the config key for the container to inject it.</li> <li><code>KeyValueStore</code> can be injected only by type and does not require annotations.</li> <li><code>aiohttp.ClientSession</code> can be injected only by type and requires no additional configuration.</li> </ol>"},{"location":"getting_started/#2-create-the-container","title":"2. Create the container","text":"<p>The next step is to create a container and register the dependencies we just defined.</p> container.py<pre><code>import wireup\nfrom my_app import services\nimport os\n\ncontainer = wireup.create_async_container(\n    # `config` is an optional key-value configuration store.\n    # You can inject configuration as necessary by referencing config keys.\n    # This allows you to create self-contained service definitions\n    # without additional setup code.\n    config={  # (1)!\n        \"redis_url\": os.environ[\"APP_REDIS_URL\"],\n        \"weather_api_key\": os.environ[\"APP_WEATHER_API_KEY\"],\n    },\n    # Let the container know where registrations are located.\n    # This is a list of modules containing injectable definitions,\n    # or functions/classes decorated with `@injectable`.\n    injectables=[services],\n)\n</code></pre> <ol> <li> <p><code>config</code> is configuration your application needs. Such as an api key, database url, or other settings.</p> <p>You can inject them as necessary by their name (dict key) where required. Wireup won't pull things from the environment or other places for you. You need to expose to it the different settings you'll need.</p> <p>You don't have to use this if you prefer using things like pydantic-settings, but it will enable you to have self-contained service definitions without writing additional set-up code to create these objects.</p> <p>Note that the values can be literally anything you need to inject and not just int/strings or other scalars. You can put dataclasses for example in the config to inject structured configuration.</p> </li> </ol> <p>Container variants: Sync and Async</p> <p>Wireup includes two types of containers: async and sync. The difference is that the async one exposes <code>async def</code> methods for the common operations and is capable of creating resources from <code>async def</code> factories.</p> <p>The async container can create both regular and resources from async factories.</p> <p>If you don't use async in your code you should create a container via <code>wireup.create_sync_container</code>. Some integrations that Wireup provides also require you to create containers of a given type. E.g: FastAPI integration only supports async containers.</p>"},{"location":"getting_started/#3-use","title":"3. Use","text":"<p>All that's left now is to retrieve dependencies from the container.</p> Direct RetrievalInjection via decoratorFastAPIFlaskDjango <p>To fetch dependencies from the container, call <code>.get</code> on the container instance with the type you want to retrieve.</p> views/posts.py<pre><code>@app.get(\"/weather/forecast\")\nasync def get_forecast():\n    weather_service = await container.get(WeatherService)\n    return await weather_service.get_forecast(...)\n</code></pre> <p>You can also apply Wireup containers as decorators. See Apply the container as a decorator docs for more info, but the end result is that you can decorate any function and specify dependencies to inject in it's signature.</p> views/posts.py<pre><code>from wireup import Injected, inject_from_container\n\n\n@app.get(\"/weather/forecast\")\n@inject_from_container(container)\nasync def get_forecast(weather_service: Injected[WeatherService]):\n    return await weather_service.get_forecast(...)\n</code></pre> <p>With the FastAPI integration you can declare dependencies in http or websocket routes.</p> views/posts.py<pre><code>from wireup import Injected\n\n\n@app.get(\"/weather/forecast\")\nasync def get_forecast(weather_service: Injected[WeatherService]):\n    return await weather_service.get_forecast(...)\n</code></pre> <p>Learn More: FastAPI Integration.</p> <p>With the Flask integration you can declare dependencies in views.</p> views/posts.py<pre><code>from wireup import Injected\n\n\n@app.get(\"/weather/forecast\")\ndef get_forecast(weather_service: Injected[WeatherService]):\n    return weather_service.get_forecast(...)\n</code></pre> <p>Learn More: Flask Integration.</p> <p>With the Django integration you can declare dependencies in views. The integration provides support for async views, regular views as well as class-based views.</p> views/posts.py<pre><code>from wireup import Injected\n\n\nasync def get_forecast(weather_service: Injected[WeatherService]):\n    return await weather_service.get_forecast(...)\n</code></pre> <p>Learn More: Django Integration.</p>"},{"location":"getting_started/#integrations","title":"Integrations","text":"<p>While Wireup is framework-agnostic, usage can be simplified when using it alongside one of the integrations. Key benefits of the integrations are:</p> <ul> <li>Automatic injection in routes without having to do <code>container.get</code> or use decorators.</li> <li>Lifecycle management and access to request-scoped dependencies.</li> <li>Eliminates the need for a global container variable as containers are bound to the application instance.</li> </ul> <p>Check out the Integrations page.</p>"},{"location":"getting_started/#4-test","title":"4. Test","text":"<p>Wireup does not patch your classes, which means they can be instantiated and tested independently of the container.</p> <p>To substitute dependencies on targets such as views in a web application you can override dependencies with new ones on the fly.</p> <pre><code>with container.override.injectable(WeatherService, new=test_weather_service):\n    response = client.get(\"/weather/forecast\")\n</code></pre> <p>Requests to inject <code>WeatherService</code> during the lifetime of the context manager will result in <code>test_weather_service</code> being injected instead.</p>"},{"location":"getting_started/#conclusion","title":"Conclusion","text":"<p>This concludes the \"Getting Started\" walkthrough, covering the most common dependency injection use cases.</p> <p>Info</p> <ul> <li>Wireup can perform injection on both sync and async targets.</li> <li>If you need to create multiple containers, every container you create is separate from the rest and has its own state.</li> </ul>"},{"location":"getting_started/#next-steps","title":"Next Steps","text":"<ul> <li>Injectables</li> <li>Configuration</li> <li>Factories</li> </ul>"},{"location":"injectables/","title":"Injectables","text":"<p>An injectable is any class or function that you register with the container, making it available to be requested as a dependency. Once registered, Wireup can instantiate it, resolve its own dependencies, and inject it wherever needed.</p>"},{"location":"injectables/#the-injectable-decorator","title":"The <code>@injectable</code> Decorator","text":"<p>The <code>@injectable</code> decorator marks a class or function for registration with the container.</p> ClassesFunctions <pre><code>from wireup import injectable\n\n\n@injectable\nclass UserRepository: ...\n</code></pre> <pre><code>from wireup import injectable\n\n\n@injectable\ndef db_connection() -&gt; DatabaseConnection: ...\n</code></pre>"},{"location":"injectables/#arguments","title":"Arguments","text":"<p>You can customize how an injectable is registered by passing arguments to the decorator:</p> Argument Description Default <code>lifetime</code> Controls how long the object lives (e.g., <code>\"singleton\"</code>, <code>\"scoped\"</code>). See Lifetimes. <code>\"singleton\"</code> <code>qualifier</code> A unique identifier, useful when you have multiple implementations of the same type. See Interfaces. <code>None</code> <code>as_type</code> Register the object as a different type (like a Protocol or Base Class). See Interfaces. <code>None</code> <pre><code>from wireup import injectable\n\n\n@injectable(lifetime=\"scoped\", qualifier=\"readonly\")\nclass DbSession: ...\n</code></pre>"},{"location":"injectables/#defining-dependencies","title":"Defining Dependencies","text":"<p>Wireup resolves dependencies using Type Hints. It inspects the types you declare and automatically finds the matching injectable.</p>"},{"location":"injectables/#classes","title":"Classes","text":"<p>Standard Python classes with type-hinted <code>__init__</code> methods are automatically wired. No extra configuration is needed.</p> <pre><code>from wireup import injectable\n\n\n@injectable\nclass UserService:\n    # UserRepository will be injected automatically\n    def __init__(self, repo: UserRepository) -&gt; None:\n        self.repo = repo\n</code></pre>"},{"location":"injectables/#factories","title":"Factories","text":"<p>Functions can be registered as factories. This is standard for creating 3rd-party objects, when complex setup is required or for enforcing clean architecture.</p> <p>See Factories and Resource Management.</p> <pre><code>import boto3\nfrom wireup import injectable, Inject\nfrom typing import Annotated\n\n\n@injectable\ndef create_s3_client(\n    region: Annotated[str, Inject(config=\"aws_region\")],\n) -&gt; boto3.client:\n    return boto3.client(\"s3\", region_name=region)\n</code></pre>"},{"location":"injectables/#dataclasses","title":"Dataclasses","text":"<p>You can combine <code>@injectable</code> with <code>@dataclass</code> to eliminate <code>__init__</code> boilerplate.</p> Standard ClassDataclass <pre><code>@injectable\nclass OrderProcessor:\n    def __init__(\n        self,\n        payment_gateway: PaymentGateway,\n        inventory_service: InventoryService,\n    ):\n        self.payment_gateway = payment_gateway\n        self.inventory_service = inventory_service\n</code></pre> <pre><code>from dataclasses import dataclass\n\n\n@injectable\n@dataclass\nclass OrderProcessor:\n    payment_gateway: PaymentGateway\n    inventory_service: InventoryService\n</code></pre> Counter-example <p>Mix with caution if your class has many non-dependency fields.</p> <pre><code>@injectable\n@dataclass\nclass Foo:\n    FOO_CONST = 1  # Not added to __init__ by @dataclass.\n    logger = logging.getLogger(__name__)  # Not added to __init__ by @dataclass.\n\n    # These will be added to __init__ by @dataclass\n    # and marked as dependencies by Wireup.\n    payment_gateway: PaymentGateway\n    inventory_service: InventoryService\n    order_repository: OrderRepository\n</code></pre> <p>In this example, due to how the <code>@dataclass</code> decorator works, combining the two leads to code that's more difficult to read, since it's not immediately obvious what are dependencies and what are class fields.</p>"},{"location":"injectables/#dependencies-with-default-values","title":"Dependencies with Default Values","text":"<p>When Wireup encounters a dependency it doesn't recognize, it normally raises an error. However, if that parameter has a default value, Wireup will skip it and let Python use the default instead.</p> <p>This is useful when integrating with libraries that add their own <code>__init__</code> parameters, such as Pydantic Settings:</p> <pre><code>from pydantic_settings import BaseSettings\nfrom wireup import injectable\n\n\n@injectable\nclass Settings(BaseSettings):\n    app_name: str = \"myapp\"\n    debug: bool = False\n</code></pre> <p>In this example, Pydantic's <code>BaseSettings</code> adds parameters that Wireup doesn't manage. Since they have defaults, Wireup allows the class to be registered without errors.</p> <p>Note</p> <p>This only applies to parameters with explicit default values. Parameters without defaults that reference unknown types will still raise an error to catch configuration mistakes early.</p>"},{"location":"injectables/#next-steps","title":"Next Steps","text":"<ul> <li>Configuration - Inject configuration values.</li> <li>Lifetimes &amp; Scopes - Control how long objects live.</li> <li>Factories - Advanced creation logic.</li> </ul>"},{"location":"interfaces/","title":"Interfaces","text":"<p>Use protocols or abstract base classes (ABCs) to define the behavior your application needs, separately from how it is implemented. This allows you to easily switch between different implementations, for example using an in-memory repository during testing instead of a real database.</p>"},{"location":"interfaces/#basic-usage","title":"Basic Usage","text":"<p>You can use the <code>as_type</code> parameter in <code>@injectable</code> to register an injectable as any other type. This is commonly used to bind a concrete class to a Protocol or an Abstract Base Class.</p> ProtocolAbstract Base Class <pre><code>from typing import Protocol\nfrom wireup import injectable\n\n\nclass Cache(Protocol):\n    def get(self, key: str) -&gt; str | None: ...\n    def set(self, key: str, value: str): ...\n\n\n@injectable(as_type=Cache)\nclass InMemoryCache: ...\n</code></pre> <pre><code>from abc import ABC, abstractmethod\nfrom wireup import injectable\n\n\nclass Cache(ABC):\n    @abstractmethod\n    def get(self, key: str) -&gt; str | None: ...\n\n    @abstractmethod\n    def set(self, key: str, value: str): ...\n\n\n@injectable(as_type=Cache)\nclass InMemoryCache(Cache):\n    def get(self, key: str) -&gt; str | None: ...\n    def set(self, key: str, value: str): ...\n</code></pre> <p>Type Checking Limitation</p> <p>Type checkers cannot verify that the decorated class implements the protocol or ABC specified in <code>as_type</code>. This is a Python type system limitation.</p> <p>Factories Control Registration Type</p> <p>With factories, you control the type the dependency is registered as by specifying the return type annotation. This makes <code>as_type</code> largely unnecessary for factories and allows type checkers to verify the return type.</p> <pre><code>from wireup import injectable\n\n\n@injectable\ndef make_cache() -&gt; Cache:\n    return InMemoryCache()\n</code></pre> <p>This is equivalent to:</p> <pre><code>@injectable(as_type=Cache)\nclass InMemoryCache: ...\n</code></pre> <p>The <code>as_type</code> parameter is still useful when you want the function to retain its original type for other purposes (e.g., testing, direct usage) while registering it under a different type in the container.</p>"},{"location":"interfaces/#multiple-implementations","title":"Multiple Implementations","text":"<p>When you have multiple implementations of the same type, use qualifiers to distinguish between them. This is useful for environment-specific behavior (e.g., in-memory cache in development, Redis in production) or feature flags.</p> <pre><code>from typing import Annotated\nfrom wireup import Inject, injectable, inject_from_container\n\n\n@injectable(as_type=Cache, qualifier=\"memory\")\nclass InMemoryCache: ...\n\n\n@injectable(as_type=Cache, qualifier=\"redis\")\nclass RedisCache: ...\n\n\n@inject_from_container(container)\ndef main(\n    memory_cache: Annotated[Cache, Inject(qualifier=\"memory\")],\n    redis_cache: Annotated[Cache, Inject(qualifier=\"redis\")],\n): ...\n</code></pre> <p>Qualifiers don't have to be strings</p> <p>You can avoid magic strings by using Enums or hashable types for qualifiers. This prevents typos and makes refactoring easier.</p> <pre><code>from enum import StrEnum\n\n\nclass CacheType(StrEnum):\n    MEMORY = \"memory\"\n    REDIS = \"redis\"\n\n\n@injectable(as_type=Cache, qualifier=CacheType.REDIS)\nclass RedisCache: ...\n</code></pre>"},{"location":"interfaces/#default-implementation","title":"Default Implementation","text":"<p>You can register a default implementation by omitting the qualifier on one of the implementations. When <code>Cache</code> is requested without a qualifier, the default will be injected.</p> <pre><code>from typing import Annotated\nfrom wireup import Inject, injectable, Injected, inject_from_container\n\n\n@injectable(as_type=Cache)\nclass InMemoryCache: ...\n\n\n@injectable(as_type=Cache, qualifier=\"redis\")\nclass RedisCache: ...\n\n\n@inject_from_container(container)\ndef main(\n    # Default implementation: InMemoryCache\n    memory_cache: Injected[Cache],\n    # RedisCache: Qualified via qualifier=\"redis\".\n    redis_cache: Annotated[Cache, Inject(qualifier=\"redis\")],\n): ...\n</code></pre>"},{"location":"interfaces/#optional-binding","title":"Optional Binding","text":"<p>When registering factory functions that return optional types (e.g. <code>Cache | None</code>), the binding is automatically registered as optional.</p> <pre><code>@injectable(as_type=Cache)\ndef make_cache() -&gt; RedisCache | None: ...\n</code></pre> <p>This acts as if the factory was registered with <code>as_type=Cache | None</code>, allowing you to inject <code>Cache | None</code> or <code>Optional[Cache]</code>.</p>"},{"location":"lifetimes_and_scopes/","title":"Lifetimes & Scopes","text":"<p>Wireup controls how long instances live and when they're shared through lifetimes and scopes.</p>"},{"location":"lifetimes_and_scopes/#why-scopes","title":"Why Scopes?","text":"<p>Some resources need isolation. For example:</p> <ul> <li>Database transactions should be independent per request</li> <li>User context should not leak between requests</li> <li>Temporary objects should be created fresh each time</li> </ul> <p>Scopes solve this by providing isolated contexts with automatic cleanup. When a scope ends, Wireup automatically releases resources created within that scope.</p>"},{"location":"lifetimes_and_scopes/#lifetimes","title":"Lifetimes","text":"<p>Wireup provides three lifetime options that control instance creation and sharing. Configure the lifetime using the <code>@injectable</code> decorator.</p>"},{"location":"lifetimes_and_scopes/#quick-reference","title":"Quick Reference","text":"Lifetime Instance Creation Shared Within Retrieved From Best For Singleton Once per container Entire application Root or scoped Configuration, database connections, caching Scoped Once per scope Current scope only Scoped only Request state, transactions, user sessions Transient Every resolution Never shared Scoped only Stateless objects, temporary objects <p>Container Access Rules</p> <p>The root container is the one you create during setup via <code>wireup.create_sync_container</code> or <code>wireup.create_async_container</code>. A scoped container is created from it using <code>container.enter_scope()</code>.</p> <ul> <li>Root container (<code>container.get()</code>) can only retrieve singletons</li> <li>Scoped container (<code>scope.get()</code>) can retrieve singletons, scoped, and transient dependencies</li> <li>Scoped containers automatically look up singletons from the root container</li> </ul>"},{"location":"lifetimes_and_scopes/#singleton-default","title":"Singleton (Default)","text":"<p>One instance is created and shared across the entire application:</p> <pre><code>@injectable  # lifetime=\"singleton\" is the default\nclass Database:\n    def __init__(self): ...\n\n\n# Same instance everywhere\ndb1 = container.get(Database)  # Instance created\ndb2 = container.get(Database)  # Reuses instance\nassert db1 is db2  # True\n</code></pre> <p>Tip</p> <p>Singletons are lazy by default. See Eager Initialization to initialize them at startup.</p>"},{"location":"lifetimes_and_scopes/#scoped","title":"Scoped","text":"<p>One instance per scope, shared within that scope:</p> <pre><code>@injectable(lifetime=\"scoped\")\nclass RequestContext:\n    def __init__(self):\n        self.request_id = uuid.uuid4()\n\n\nwith container.enter_scope() as scope1:\n    ctx1 = scope1.get(RequestContext)\n    ctx2 = scope1.get(RequestContext)\n    assert ctx1 is ctx2  # Same instance within scope\n\nwith container.enter_scope() as scope2:\n    ctx3 = scope2.get(RequestContext)\n    assert ctx1 is not ctx3  # Different instance in different scope\n</code></pre>"},{"location":"lifetimes_and_scopes/#transient","title":"Transient","text":"<p>Creates a new instance on every resolution:</p> <pre><code>@injectable(lifetime=\"transient\")\nclass MessageBuilder:\n    def __init__(self):\n        self.timestamp = time.time()\n\n\nwith container.enter_scope() as scope:\n    builder1 = scope.get(MessageBuilder)\n    builder2 = scope.get(MessageBuilder)\n    assert builder1 is not builder2  # Always different instances\n</code></pre>"},{"location":"lifetimes_and_scopes/#cleanup-timing","title":"Cleanup Timing","text":"<ul> <li>Singleton cleanup happens when <code>container.close()</code> is called (application shutdown)</li> <li>Scoped cleanup happens when the scope exits (end of request/context)</li> <li>Transient cleanup happens when the scope that created them exits</li> </ul>"},{"location":"lifetimes_and_scopes/#working-with-scopes","title":"Working with Scopes","text":"<p>Scopes provide isolated contexts. This is useful for things like database sessions or user context that should only exist for a short duration (like a single HTTP request).</p> <pre><code>graph TD\n    Root[\"Root Container&lt;br/&gt;(Singletons)\"]\n\n    Root --&gt;|enter_scope| Scope1\n    Root --&gt;|enter_scope| Scope2\n    Root --&gt;|enter_scope| Scope3\n\n    subgraph Scope1[\"Request 1\"]\n        S1_scoped[\"Scoped deps\"]\n        S1_transient[\"Transient deps\"]\n    end\n\n    subgraph Scope2[\"Request 2\"]\n        S2_scoped[\"Scoped deps\"]\n        S2_transient[\"Transient deps\"]\n    end\n\n\n    subgraph Scope3[\"Request 3\"]\n        S3_scoped[\"Scoped deps\"]\n        S3_transient[\"Transient deps\"]\n    end</code></pre> <p>Each call to <code>enter_scope()</code> creates an isolated scoped container with its own scoped and transient dependencies.</p> Web FrameworksFunction DecoratorManual Context <p>When using Integrations (like FastAPI, Flask, Django), scopes are handled automatically. A new scope is created for every incoming request and closed when the request finishes.</p> <pre><code>@app.get(\"/users/me\")\ndef get_current_user(auth_service: Injected[AuthService]):\n    return auth_service.get_current_user()\n</code></pre> <p>The <code>@wireup.inject_from_container</code> automatically enters a new scope before the function runs and closes it afterwards, ensuring cleanup is performed.</p> <pre><code>@wireup.inject_from_container(container)\ndef process_order(order_service: Injected[OrderService]):\n    return order_service.process()\n</code></pre> <p>For granular control, you can manage scopes manually using <code>container.enter_scope()</code>.</p> <p>Synchronous</p> <pre><code>container = wireup.create_sync_container(injectables=[RequestService])\n\nwith container.enter_scope() as scope:\n    # Resolve dependencies from this specific scope\n    service = scope.get(RequestService)\n    service.process()\n\n# When the block exits, the scope is closed and cleanup runs.\n</code></pre> <p>Asynchronous</p> <pre><code>container = wireup.create_async_container(injectables=[RequestService])\n\nasync with container.enter_scope() as scope:\n    service = await scope.get(RequestService)\n    service.process()\n</code></pre>"},{"location":"lifetimes_and_scopes/#resource-cleanup","title":"Resource Cleanup","text":"<p>Scoped containers ensure that resources are released when the scope exits. This simplifies resource management for things like database transactions or file handles.</p> <p>See Resources &amp; Cleanup for details on creating cleanable resources using generator factories.</p>"},{"location":"lifetimes_and_scopes/#lifetime-dependency-rules","title":"Lifetime Dependency Rules","text":"<p>Dependencies have restrictions on what they can depend on to prevent Scope Leakage:</p> <ul> <li>Singletons can only depend on other singletons and config.</li> <li>Scoped can depend on singletons, scoped, and config.</li> <li>Transient can depend on any lifetime and config.</li> </ul>"},{"location":"lifetimes_and_scopes/#concurrent-access","title":"Concurrent Access","text":"<p>Scopes are typically accessed by a single thread or asyncio task (e.g., one web request). By default, Wireup does not use locks for scoped dependencies, optimizing for this common pattern.</p>"},{"location":"lifetimes_and_scopes/#when-to-enable-locking","title":"When to Enable Locking","text":"<p>If you need to share a scope across multiple concurrent tasks, such as, parallelizing work within a request while sharing a common context, enable <code>concurrent_scoped_access</code> when creating the container:</p> <pre><code>container = wireup.create_async_container(\n    injectables=[...],\n    concurrent_scoped_access=True,  # Safe for shared scopes\n)\n</code></pre> <p>Note</p> <p>This is an advanced use case. Most applications don't need this.</p>"},{"location":"lifetimes_and_scopes/#next-steps","title":"Next Steps","text":"<ul> <li>Factories - Create complex dependencies with setup and teardown logic.</li> <li>Interfaces - Register multiple implementations of the same type.</li> <li>Testing - Override dependencies for testing.</li> </ul>"},{"location":"resources/","title":"Resource Management","text":"<p>A resource is any dependency that requires cleanup, such as database connections, file handles, or network clients. Use generator factories to manage their lifecycle.</p>"},{"location":"resources/#generator-factories","title":"Generator Factories","text":"<p>Generator factories use Python's <code>yield</code> statement to manage resource lifecycle:</p> <ol> <li>Setup: Code before <code>yield</code> runs when the dependency is created.</li> <li>Use: The yielded value is injected into consumers.</li> <li>Teardown: Code after <code>yield</code> runs when the scope closes.</li> </ol> GeneratorsContext ManagerAsync Context Manager <pre><code>from typing import Iterator\nfrom wireup import injectable\n\n\n@injectable\ndef db_session_factory() -&gt; Iterator[Session]:\n    db = Session()\n    try:\n        yield db\n    finally:\n        db.close()\n</code></pre> <pre><code>import contextlib\nfrom typing import Iterator\nfrom wireup import injectable\n\n\n@injectable\ndef db_session_factory() -&gt; Iterator[Session]:\n    with contextlib.closing(Session()) as db:\n        yield db\n</code></pre> <pre><code>from typing import AsyncIterator\nfrom aiohttp import ClientSession\nfrom wireup import injectable\n\n\n@injectable\nasync def client_session_factory() -&gt; AsyncIterator[ClientSession]:\n    async with ClientSession() as sess:\n        yield sess\n</code></pre> <p>Generator Factories</p> <p>Generator factories must yield exactly once. Yielding multiple times will result in cleanup not being performed.</p> <p>When cleanup runs depends on the lifetime. See Cleanup Timing for details.</p>"},{"location":"resources/#error-handling","title":"Error Handling","text":"<p>When using generator factories with scoped or transient lifetimes, unhandled errors that occur within the scope are automatically propagated to the factories. This enables conditional cleanup, such as rolling back uncommitted database changes when operations fail.</p> <pre><code>from typing import Iterator\nfrom sqlalchemy import Engine\nfrom sqlalchemy.orm import Session\nfrom wireup import injectable\n\n\n@injectable(lifetime=\"scoped\")\ndef db_session_factory(engine: Engine) -&gt; Iterator[Session]:\n    session = Session(engine)\n    try:\n        yield session\n    except Exception:\n        # Error occurred - rollback any uncommitted changes\n        session.rollback()\n        raise\n    finally:\n        # Always close the session\n        session.close()\n</code></pre> <p>Suppressing Errors</p> <p>Factories cannot suppress exceptions, they can perform cleanup, but the original error will always propagate. This ensures cleanup code doesn't accidentally change your program's control flow.</p>"},{"location":"testing/","title":"Testing","text":"<p>The <code>@injectable</code> decorator doesn't modify your classes, so they can be instantiated and tested like any regular Python class. Pass dependencies manually in your tests.</p> <pre><code>from unittest.mock import MagicMock\n\n\ndef test_user_service_logic():\n    # Arrange: Create dependencies manually (mocks or real)\n    repo_mock = MagicMock()\n    repo_mock.get.return_value = User(id=1, name=\"Test User\")\n\n    # Act: Instantiate the service with the mock\n    service = UserService(repository=repo_mock)\n    result = service.get_user_name(1)\n\n    # Assert: Verify behavior\n    assert result == \"Test User\"\n    repo_mock.get.assert_called_once_with(1)\n</code></pre> <p>To specify custom behavior for tests, provide a custom implementation or a subclass that returns test data.</p>"},{"location":"testing/#overriding","title":"Overriding","text":"<p>Sometimes you need to be able to swap a dependency on the fly for a different one such as a mock.</p> <p>The <code>container.override</code> property provides access to a number of useful methods and context managers which help with overriding dependencies (See override manager).</p> <p>Good to know</p> <ul> <li>Overriding only applies to future injections.</li> <li>Once a singleton has been instantiated, it is not possible to directly replace any of its direct or transitive     dependencies via overriding as the object is already in memory.</li> <li>When injecting interfaces and/or qualifiers, override the interface and/or qualifier rather than the implementation     that will be injected.</li> </ul> <p>Tip</p> <p>If you're using an integration to get the container instance you can use the <code>wireup.integration.xxx.get_app_container</code> method. This returns the container associated with your application.</p>"},{"location":"testing/#context-manager","title":"Context Manager","text":"<pre><code>from unittest.mock import MagicMock\n\nrandom_mock = MagicMock()\nrandom_mock.get_random.return_value = 4\n\nwith container.override.injectable(target=RandomService, new=random_mock):\n    # Requests to inject RandomService during the lifetime\n    # of this context manager will use random_mock instead.\n    response = client.get(\"/random\")\n</code></pre>"},{"location":"testing/#overriding-multiple-injectables","title":"Overriding Multiple Injectables","text":"<p>When you need to override several dependencies at once, use <code>container.override.injectables</code> with a list of <code>InjectableOverride</code> objects:</p> <pre><code>from unittest.mock import MagicMock\nfrom wireup import InjectableOverride\n\nuser_service_mock = MagicMock()\norder_service_mock = MagicMock()\n\noverrides = [\n    InjectableOverride(target=UserService, new=user_service_mock),\n    InjectableOverride(target=OrderService, new=order_service_mock),\n]\n\nwith container.override.injectables(overrides=overrides):\n    # Both UserService and OrderService are now mocked\n    response = client.get(\"/checkout\")\n</code></pre>"},{"location":"testing/#pytest","title":"Pytest","text":"app.py<pre><code>import wireup\n\n\ndef create_app():\n    app = ...\n\n    container = wireup.create_async_container(...)\n    # Example shows FastAPI but any integration works the same.\n    wireup.integration.fastapi.setup(container, app)\n\n    return app\n</code></pre> conftest.py<pre><code># This is a function scoped fixture which means\n# you'll get a fresh copy of the application and container every time.\n@pytest.fixture\ndef app():\n    return create_app()\n</code></pre> some_test_file.py<pre><code>from wireup.integration.fastapi import get_app_container\n\n\ndef test_something_with_mocked_db_service(client: TestClient, app):\n    with get_app_container(app).override.injectable(DBService, new=...):\n        response = client.get(\"/some/path\")\n\n    # Assert response and mock calls.\n</code></pre>"},{"location":"testing/#next-steps","title":"Next Steps","text":"<ul> <li>Container - Learn about the container API.</li> <li>Lifetimes &amp; Scopes - Understand how lifetimes affect testing.</li> </ul>"},{"location":"upgrading/","title":"Upgrading","text":""},{"location":"upgrading/#upgrading-2x-to-24","title":"Upgrading 2.x to 2.4","text":"<ul> <li>Parameters have been renamed to Configuration to better reflect their purpose.</li> <li>When providing configuration use <code>config=</code> instead of <code>parameters=</code> during contaner creation:     <code>wireup.create_{a}sync_container(..., config={...})</code>.</li> <li>Instead of <code>container.params</code>, use <code>container.config</code>.</li> <li>Instead of <code>Inject(param=\"name\")</code>, use <code>Inject(config=\"key\")</code>.</li> <li>Deprecated <code>@abstract</code>: The <code>@abstract</code> decorator is deprecated and will be removed in a future release. Use     protocols or abstract base classes with <code>@injectable(as_type=...)</code> instead.</li> </ul> <pre><code># Before\n@abstract\nclass MyInterface(abc.ABC): ...\n\n\n@injectable\nclass MyImplementation(MyInterface): ...\n\n\n# After\nclass MyInterface(Protocol): ...\n\n\n@injectable(as_type=MyInterface)\nclass MyImplementation: ...\n</code></pre>"},{"location":"upgrading/#upgrade-1x-to-200","title":"Upgrade 1.x to 2.0.0","text":"<ul> <li>Wireup container itself has no breaking changes. The major version bump is due to a breaking change in the FastAPI     integration.</li> <li>Added new <code>middleware_mode</code> parameter to the <code>wireup.integration.fastapi.setup</code> call. Default value is <code>False</code>, Wireup     1.x behavior is the equivalent of <code>middleware_mode=True</code>. See FastAPI integration docs for when to enable this     setting.</li> </ul>"},{"location":"upgrading/#upgrade-0160-to-10","title":"Upgrade 0.16.0 to 1.0","text":"<p>With the API now stable, deprecated features have been removed. Refer to the deprecation notices for upgrade guidance.</p>"},{"location":"upgrading/#removed-wireupdependencycontainer","title":"Removed <code>wireup.DependencyContainer</code>","text":"<p>The previous container was overly complex. It has been split into <code>wireup.SyncContainer</code> and <code>wireup.AsyncContainer</code>.</p> <p>Use <code>wireup.AsyncContainer</code> if you need to create async dependencies, as it supports both sync and async resources.</p> <p>Changes include:</p> <ul> <li>Removed <code>@container.register</code><ul> <li>Use <code>@service</code> on services or factories and specify the container during creation with     <code>wireup.create_sync_container</code> or <code>wireup.create_async_container</code>.</li> </ul> </li> <li>Removed <code>@container.abstract</code><ul> <li>Similar to above, use the <code>@abstract</code> decorator.</li> </ul> </li> <li>Removed <code>@container.autowire</code><ul> <li>This is removed. See the Apply the container as a decorator docs for details.</li> </ul> </li> <li>Removed <code>container.has_type</code>.</li> <li><code>wireup.create_container</code> is now <code>wireup.create_sync_container</code> and <code>wireup.create_async_container</code>.</li> </ul>"},{"location":"upgrading/#removed-get_all-put-methods-of-parameterbag","title":"Removed get_all, put methods of <code>ParameterBag</code>.","text":"<p><code>ParameterBag</code> does not support mutations. Pass all parameters when creating the container.</p>"},{"location":"upgrading/#removed-support-for-default-values","title":"Removed support for default values","text":"<p>Using <code>foo: str = Inject(...)</code> is no longer supported. Use annotated types instead: <code>foo: Annotated[str, Inject(...)]</code>.</p>"},{"location":"upgrading/#removed-parameterenum","title":"Removed ParameterEnum","text":"<p><code>ParameterEnum</code> is removed. Use type definitions for parameters: <code>AppNameParameter = Annotated[str, Inject(name=\"app_name\")]</code>.</p>"},{"location":"upgrading/#removed-wire-wire","title":"Removed <code>Wire</code>, <code>wire</code>","text":"<p>Replace <code>Wire</code> or <code>wire</code> with <code>Inject</code>.</p>"},{"location":"upgrading/#removed-wireupcontainer-global","title":"Removed <code>wireup.container</code> global","text":"<p>The global <code>wireup.container</code> is removed. Create a container instance with <code>wireup.create_sync_container</code> or <code>wireup.create_async_container</code>.</p>"},{"location":"upgrading/#removed-warmup_container","title":"Removed <code>warmup_container</code>","text":"<p>This utility function is removed. Create a container instance with <code>wireup.create_sync_container</code> or <code>wireup.create_async_container</code>.</p>"},{"location":"upgrading/#removed-old-integrations","title":"Removed old integrations","text":"<p><code>wireup.integrations.flask_integration</code> is replaced by <code>wireup.integrations.flask</code>. <code>wireup.integrations.fastapi_integration</code> is replaced by <code>wireup.integrations.fastapi</code>.</p>"},{"location":"upgrading/#removed-initialize_container","title":"Removed <code>initialize_container</code>","text":"<p>This utility function is removed. Create a container instance with <code>wireup.create_sync_container</code> or <code>wireup.create_async_container</code>.</p>"},{"location":"upgrading/#removed-register_all_in_module","title":"Removed <code>register_all_in_module</code>","text":"<p>This utility function is removed. Register services by passing <code>service_modules</code> to <code>wireup.create_*_container</code>.</p>"},{"location":"upgrading/#removed-load_module","title":"Removed <code>load_module</code>","text":"<p>No direct replacement. Create a container instance with <code>wireup.create_sync_container</code> or <code>wireup.create_async_container</code>.</p>"},{"location":"upgrading/#removed-factoryduplicateserviceregistrationerror","title":"Removed <code>FactoryDuplicateServiceRegistrationError</code>","text":"<p>Use <code>DuplicateServiceRegistrationError</code>.</p>"},{"location":"upgrading/#removed-servicelifetime-enum-in-favor-of-literals","title":"Removed <code>ServiceLifetime</code> enum in favor of literals","text":"<p>Replace <code>ServiceLifetime.SINGLETON</code> with <code>\"singleton\"</code> and <code>ServiceLifetime.TRANSIENT</code> with <code>\"transient\"</code>.</p>"},{"location":"upgrading/#django-integration","title":"Django Integration","text":"<p>The <code>perform_wramup</code> setting is removed.</p>"},{"location":"upgrading/#flask-integration","title":"Flask Integration","text":"<p>The <code>import_flask_config</code> setting is removed. Expose Flask config directly to <code>create_sync_container</code>. See Flask integration docs for details.</p>"},{"location":"upgrading/#fastapi-integration","title":"FastAPI Integration","text":"<p>The integration no longer automatically exposes <code>fastapi.Request</code> as a Wireup dependency. Pass <code>wireup.integration.fastapi</code> in your service modules when creating a container if needed.</p>"},{"location":"versioning/","title":"Versioning Policy","text":"<p>Wireup follows Semantic Versioning (SemVer) to provide clear expectations about version compatibility.</p>"},{"location":"versioning/#version-numbers","title":"Version Numbers","text":"<p>Each version number follows the format <code>MAJOR.MINOR.PATCH</code>:</p> <ul> <li>MAJOR: Increments for backward-incompatible changes</li> <li>MINOR: Increments for new features (backward-compatible)</li> <li>PATCH: Increments for bug fixes (backward-compatible)</li> </ul>"},{"location":"versioning/#pre-release-versions-0xx","title":"Pre-release Versions (0.x.x)","text":"<p>Versions starting with <code>0</code> (e.g., <code>0.1.0</code>) are considered pre-release. During this phase:</p> <ul> <li>The API is considered unstable</li> <li>Minor version updates may include breaking changes</li> <li>Use version constraint <code>0.x.*</code> to receive bug fixes while avoiding breaking changes</li> </ul>"},{"location":"versioning/#public-api-definition","title":"Public API Definition","text":"<p>The following components constitute Wireup's public API:</p> <ol> <li>All direct exports from the <code>wireup</code> package</li> <li>All public members and interfaces of the exported objects</li> </ol> <p>Changes to these components are subject to semantic versioning rules.</p>"},{"location":"class/aiohttp_integration/","title":"AIOHTTP","text":""},{"location":"class/aiohttp_integration/#wireup.integration.aiohttp-classes","title":"Classes","text":""},{"location":"class/aiohttp_integration/#wireup.integration.aiohttp-functions","title":"Functions","text":""},{"location":"class/aiohttp_integration/#wireup.integration.aiohttp.aiohttp_request_factory","title":"<code>aiohttp_request_factory()</code>","text":"<p>Provide the current aiohttp request as a dependency.</p> <p>Note that this requires the Wireup-aiohttp integration to be set up.</p>"},{"location":"class/aiohttp_integration/#wireup.integration.aiohttp.get_app_container","title":"<code>get_app_container(app)</code>","text":"<p>Return the container associated with the given AIOHTTP application.</p>"},{"location":"class/aiohttp_integration/#wireup.integration.aiohttp.get_request_container","title":"<code>get_request_container()</code>","text":"<p>When inside a request, returns the scoped container instance handling the current request.</p>"},{"location":"class/aiohttp_integration/#wireup.integration.aiohttp.setup","title":"<code>setup(container, app, handlers=None)</code>","text":"<p>Integrate Wireup with AIOHTTP.</p> <p>If you need access to <code>aiohttp.web.Request</code> in your injectables, add this module to the container's injectables.</p> <p>Parameters:</p> Name Type Description Default <code>container</code> <code>AsyncContainer</code> <p>A Wireup async container.</p> required <code>app</code> <code>Application</code> <p>An AIOHTTP server application.</p> required <code>handlers</code> <code>Optional[Iterable[Type[_WireupHandler]]]</code> <p>A list of Wireup class-based handlers. See: https://maldoinc.github.io/wireup/latest/integrations/aiohttp/class_based_handlers/</p> <code>None</code>"},{"location":"class/click_integration/","title":"Click","text":""},{"location":"class/click_integration/#wireupintegrationclick","title":"wireup.integration.click","text":""},{"location":"class/click_integration/#wireup.integration.click-classes","title":"Classes","text":""},{"location":"class/click_integration/#wireup.integration.click-functions","title":"Functions","text":""},{"location":"class/click_integration/#wireup.integration.click.get_app_container","title":"<code>get_app_container(app)</code>","text":"<p>Retrieve the Wireup container associated with a Click command group.</p>"},{"location":"class/click_integration/#wireup.integration.click.setup","title":"<code>setup(container, command)</code>","text":"<p>Integrate Wireup with Click by injecting dependencies into Click commands.</p> <p>:command: The Click command group to inject dependencies into</p>"},{"location":"class/config_store/","title":"ConfigStore","text":"<p>Config flat key-value store for use with a container.</p> <p>Allows storing and retrieving of config. Templated strings can be used to interpolate a string referencing other config keys.</p>"},{"location":"class/config_store/#wireup.ioc.configuration.ConfigStore-functions","title":"Functions","text":""},{"location":"class/config_store/#wireup.ioc.configuration.ConfigStore.get","title":"<code>get(value)</code>","text":"<p>Get the value of a configuration key or expression.</p>"},{"location":"class/django_integration/","title":"Django","text":""},{"location":"class/django_integration/#wireup.integration.django-classes","title":"Classes","text":""},{"location":"class/django_integration/#wireup.integration.django.WireupSettings","title":"<code>WireupSettings</code>  <code>dataclass</code>","text":"<p>Class containing Wireup settings specific to Django.</p>"},{"location":"class/django_integration/#wireup.integration.django.WireupSettings-attributes","title":"Attributes","text":""},{"location":"class/django_integration/#wireup.integration.django.WireupSettings.auto_inject_views","title":"<code>auto_inject_views = True</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Whether to automatically inject dependencies into Django views.</p> <p>When True (default), Wireup will automatically inject dependencies into all Django views. When False, you must use the @inject decorator explicitly on views that need injection.</p> <p>Set this to False if you want to use @inject explicitly across all views (useful when mixing core Django views with third-party views like Django REST framework).</p>"},{"location":"class/django_integration/#wireup.integration.django.WireupSettings.injectables","title":"<code>injectables = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>List of modules containing wireup injectable registrations.</p>"},{"location":"class/django_integration/#wireup.integration.django.WireupSettings.service_modules","title":"<code>service_modules = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>List of modules containing wireup injectable registrations.</p>"},{"location":"class/django_integration/#wireup.integration.django-functions","title":"Functions","text":""},{"location":"class/django_integration/#wireup.integration.django.get_app_container","title":"<code>get_app_container()</code>","text":"<p>Return the container instance associated with the current django application.</p>"},{"location":"class/django_integration/#wireup.integration.django.get_request_container","title":"<code>get_request_container()</code>","text":"<p>When inside a request, returns the scoped container instance handling the current request.</p>"},{"location":"class/fastapi_integration/","title":"FastAPI","text":""},{"location":"class/fastapi_integration/#wireupintegrationfastapi","title":"wireup.integration.fastapi","text":""},{"location":"class/fastapi_integration/#wireup.integration.fastapi-classes","title":"Classes","text":""},{"location":"class/fastapi_integration/#wireup.integration.fastapi-functions","title":"Functions","text":""},{"location":"class/fastapi_integration/#wireup.integration.fastapi.get_app_container","title":"<code>get_app_container(app)</code>","text":"<p>Return the container associated with the given application.</p> <p>This is the instance created via <code>wireup.create_async_container</code>. Use this when you need the container outside of the request context lifecycle.</p>"},{"location":"class/fastapi_integration/#wireup.integration.fastapi.get_request_container","title":"<code>get_request_container()</code>","text":"<p>When inside a request, returns the scoped container instance handling the current request.</p> <p>This is what you almost always want.It has all the information the app container has in addition to data specific to the current request.</p>"},{"location":"class/fastapi_integration/#wireup.integration.fastapi.request_factory","title":"<code>request_factory()</code>","text":"<p>Provide the current request as a dependency.</p>"},{"location":"class/fastapi_integration/#wireup.integration.fastapi.setup","title":"<code>setup(container, app, *, class_based_handlers=None, middleware_mode=False)</code>","text":"<p>Integrate Wireup with FastAPI.</p> <p>Setup performs the following: * Injects dependencies into HTTP and WebSocket routes. * Closes the Wireup container upon app shutdown using the lifespan context.</p> <p>Parameters:</p> Name Type Description Default <code>container</code> <code>AsyncContainer</code> <p>An async container created via <code>wireup.create_async_container</code>.</p> required <code>app</code> <code>FastAPI</code> <p>The FastAPI application to integrate with. All routes must have been added to the app before this call.</p> required <code>class_based_handlers</code> <code>Optional[Iterable[Type[_ClassBasedHandlersProtocol]]]</code> <p>A list of class-based handlers to register. These classes must have a <code>router</code> attribute of type <code>fastapi.APIRouter</code>. Warning: Do not include these with fastapi directly.</p> <code>None</code> <code>middleware_mode</code> <code>bool</code> <p>If True, the container is exposed in fastapi middleware. Note, for this to work correctly, there should be no more middleware added after the call to this function.  For more details, visit: https://maldoinc.github.io/wireup/latest/integrations/fastapi/</p> <code>False</code>"},{"location":"class/fastapi_integration/#wireup.integration.fastapi.websocket_factory","title":"<code>websocket_factory()</code>","text":"<p>Provide the current WebSocket as a dependency.</p>"},{"location":"class/flask_integration/","title":"Flask","text":""},{"location":"class/flask_integration/#wireupintegrationflask","title":"wireup.integration.flask","text":""},{"location":"class/flask_integration/#wireup.integration.flask-classes","title":"Classes","text":""},{"location":"class/flask_integration/#wireup.integration.flask-functions","title":"Functions","text":""},{"location":"class/flask_integration/#wireup.integration.flask.get_app_container","title":"<code>get_app_container(app)</code>","text":"<p>Return the container associated with the given application.</p>"},{"location":"class/flask_integration/#wireup.integration.flask.get_request_container","title":"<code>get_request_container()</code>","text":"<p>Return the container handling the current request.</p>"},{"location":"class/flask_integration/#wireup.integration.flask.setup","title":"<code>setup(container, app)</code>","text":"<p>Integrate Wireup with Flask.</p> <p>Setup performs the following: * Injects dependencies into Flask views. * Creates a new container scope for each request, with a scoped lifetime matching the request duration.</p>"},{"location":"class/override_manager/","title":"OverrideManager","text":"<p>Enables overriding of injectables registered with the container.</p>"},{"location":"class/override_manager/#wireup.ioc.override_manager.OverrideManager-functions","title":"Functions","text":""},{"location":"class/override_manager/#wireup.ioc.override_manager.OverrideManager.clear","title":"<code>clear()</code>","text":"<p>Clear active injectable overrides.</p>"},{"location":"class/override_manager/#wireup.ioc.override_manager.OverrideManager.delete","title":"<code>delete(target, qualifier=None)</code>","text":"<p>Clear active override for the <code>target</code> injectable.</p>"},{"location":"class/override_manager/#wireup.ioc.override_manager.OverrideManager.injectable","title":"<code>injectable(target, new, qualifier=None)</code>","text":"<p>Override the <code>target</code> injectable with <code>new</code> for the duration of the context manager.</p> <p>Future requests to inject <code>target</code> will result in <code>new</code> being injected.</p> <p>Parameters:</p> Name Type Description Default <code>target</code> <code>type</code> <p>The target injectable to override.</p> required <code>qualifier</code> <code>Qualifier | None</code> <p>The qualifier of the injectable to override. Set this if injectable is registered with the qualifier parameter set to a value.</p> <code>None</code> <code>new</code> <code>Any</code> <p>The new object to be injected instead of <code>target</code>.</p> required"},{"location":"class/override_manager/#wireup.ioc.override_manager.OverrideManager.injectables","title":"<code>injectables(overrides)</code>","text":"<p>Override a number of injectables with new for the duration of the context manager.</p>"},{"location":"class/override_manager/#wireup.ioc.override_manager.OverrideManager.service","title":"<code>service(target, new, qualifier=None)</code>","text":"<p>Override the <code>target</code> injectable with <code>new</code> for the duration of the context manager.</p> <p>Future requests to inject <code>target</code> will result in <code>new</code> being injected.</p> <p>Parameters:</p> Name Type Description Default <code>target</code> <code>type</code> <p>The target injectable to override.</p> required <code>qualifier</code> <code>Qualifier | None</code> <p>The qualifier of the injectable to override. Set this if injectable is registered with the qualifier parameter set to a value.</p> <code>None</code> <code>new</code> <code>Any</code> <p>The new object to be injected instead of <code>target</code>.</p> required"},{"location":"class/override_manager/#wireup.ioc.override_manager.OverrideManager.services","title":"<code>services(overrides)</code>","text":"<p>Override a number of injectables with new for the duration of the context manager.</p>"},{"location":"class/override_manager/#wireup.ioc.override_manager.OverrideManager.set","title":"<code>set(target, new, qualifier=None)</code>","text":"<p>Override the <code>target</code> injectable with <code>new</code>.</p> <p>Future requests to inject <code>target</code> will result in <code>new</code> being injected.</p> <p>Parameters:</p> Name Type Description Default <code>target</code> <code>type</code> <p>The target injectable to override.</p> required <code>qualifier</code> <code>Qualifier | None</code> <p>The qualifier of the injectable to override. Set this if injectable is registered with the qualifier parameter set to a value.</p> <code>None</code> <code>new</code> <code>Any</code> <p>The new object to be injected instead of <code>target</code>.</p> required"},{"location":"class/starlette_integration/","title":"Starlette","text":""},{"location":"class/starlette_integration/#wireupintegrationflask","title":"wireup.integration.flask","text":""},{"location":"class/starlette_integration/#wireup.integration.starlette-attributes","title":"Attributes","text":""},{"location":"class/starlette_integration/#wireup.integration.starlette.inject","title":"<code>inject = inject_from_container_unchecked(get_request_container, hide_annotated_names=True)</code>  <code>module-attribute</code>","text":"<p>Inject dependencies into Starlette endpoints. Decorate your endpoint functions with this to use Wireup's dependency injection and use <code>Injected[T]</code> or <code>Annotated[T, Inject()]</code> to specify dependencies.</p>"},{"location":"class/starlette_integration/#wireup.integration.starlette-classes","title":"Classes","text":""},{"location":"class/starlette_integration/#wireup.integration.starlette-functions","title":"Functions","text":""},{"location":"class/starlette_integration/#wireup.integration.starlette.get_app_container","title":"<code>get_app_container(app)</code>","text":"<p>Return the container associated with the given application.</p> <p>This is the instance created via <code>wireup.create_async_container</code>. Use this when you need the container outside of the request context lifecycle.</p>"},{"location":"class/starlette_integration/#wireup.integration.starlette.get_request_container","title":"<code>get_request_container()</code>","text":"<p>When inside a request, returns the scoped container instance handling the current request.</p> <p>This is what you almost always want.It has all the information the app container has in addition to data specific to the current request.</p>"},{"location":"class/starlette_integration/#wireup.integration.starlette.request_factory","title":"<code>request_factory()</code>","text":"<p>Provide the current request as a dependency.</p>"},{"location":"class/starlette_integration/#wireup.integration.starlette.setup","title":"<code>setup(container, app)</code>","text":"<p>Integrate Wireup with a Starlette application.</p> <p>This sets up the application to use Wireup's dependency injection system and closes the container on application shutdown. Note, for this to work correctly, there should be no more middleware added after the call to this function.</p>"},{"location":"class/starlette_integration/#wireup.integration.starlette.websocket_factory","title":"<code>websocket_factory()</code>","text":"<p>Provide the current WebSocket as a dependency.</p>"},{"location":"class/wireup/","title":"wireup","text":""},{"location":"class/wireup/#wireup","title":"<code>wireup</code>","text":""},{"location":"class/wireup/#wireup-attributes","title":"Attributes","text":""},{"location":"class/wireup/#wireup.Injected","title":"<code>Injected = Annotated[T, Inject()]</code>  <code>module-attribute</code>","text":"<p>Let the Wireup container know it must inject this parameter.</p> <p>Alias of <code>Annotated[T, Inject()]</code>.</p>"},{"location":"class/wireup/#wireup-classes","title":"Classes","text":""},{"location":"class/wireup/#wireup.AsyncContainer","title":"<code>AsyncContainer</code>","text":"<p>               Bases: <code>BareAsyncContainer</code></p>"},{"location":"class/wireup/#wireup.AsyncContainer-functions","title":"Functions","text":""},{"location":"class/wireup/#wireup.AsyncContainer.enter_scope","title":"<code>enter_scope()</code>","text":"<p>Enter a new scope.</p> <p>The returned scope context manager controls the lifetime of scoped dependencies. It must be used as an async context manager: <code>async with container.enter_scope() as scope:</code>.</p> <p>Scoped dependencies are created once per scope and shared within that scope. They are discarded when the context manager exits.</p> <p>See the documentation for more details: https://maldoinc.github.io/wireup/latest/lifetimes_and_scopes/#working-with-scopes</p>"},{"location":"class/wireup/#wireup.InjectableOverride","title":"<code>InjectableOverride</code>  <code>dataclass</code>","text":"<p>Data class to represent a injectable override.</p> <p>This is used to replace a dependency with a new value (mock/stub) during testing.</p> <p>Parameters:</p> Name Type Description Default <code>target</code> <code>type[Any]</code> <p>The type of the dependency to override.</p> required <code>new</code> <code>Any</code> <p>The new value to use.</p> required <code>qualifier</code> <code>Qualifier | None</code> <p>The qualifier of the dependency to override (if any).</p> <code>None</code>"},{"location":"class/wireup/#wireup.ServiceOverride","title":"<code>ServiceOverride</code>  <code>dataclass</code>","text":"<p>Data class to represent a injectable override.</p> <p>This is used to replace a dependency with a new value (mock/stub) during testing.</p> <p>Parameters:</p> Name Type Description Default <code>target</code> <code>type[Any]</code> <p>The type of the dependency to override.</p> required <code>new</code> <code>Any</code> <p>The new value to use.</p> required <code>qualifier</code> <code>Qualifier | None</code> <p>The qualifier of the dependency to override (if any).</p> <code>None</code>"},{"location":"class/wireup/#wireup.SyncContainer","title":"<code>SyncContainer</code>","text":"<p>               Bases: <code>BareSyncContainer</code></p>"},{"location":"class/wireup/#wireup.SyncContainer-functions","title":"Functions","text":""},{"location":"class/wireup/#wireup.SyncContainer.enter_scope","title":"<code>enter_scope()</code>","text":"<p>Enter a new scope.</p> <p>The returned scope context manager controls the lifetime of scoped dependencies. It must be used as a context manager: <code>with container.enter_scope() as scope:</code>.</p> <p>Scoped dependencies are created once per scope and shared within that scope. They are discarded when the context manager exits.</p> <p>See the documentation for more details: https://maldoinc.github.io/wireup/latest/lifetimes_and_scopes/#working-with-scopes</p>"},{"location":"class/wireup/#wireup-functions","title":"Functions","text":""},{"location":"class/wireup/#wireup.Inject","title":"<code>Inject(*, config=None, param=None, expr=None, qualifier=None)</code>","text":"<p>Let the Wireup container know how to inject this parameter.</p> <p>This function is used with <code>Annotated</code> to specify what should be injected. For example: <code>Annotated[str, Inject(config=\"env\")]</code>.</p> <p>If used without arguments, it tells the container to inject the dependency based on the type hint. This is equivalent to <code>Injected[T]</code>.</p> <p>See the documentation for more details: https://maldoinc.github.io/wireup/latest/annotations/</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>str | None</code> <p>The configuration key to inject.</p> <code>None</code> <code>param</code> <code>str | None</code> <p>Deprecated: Use <code>config</code> instead.</p> <code>None</code> <code>expr</code> <code>str | None</code> <p>A templated string to inject. Variables in the format <code>${variable}</code> will be replaced with the value of the configuration key <code>variable</code>.</p> <code>None</code> <code>qualifier</code> <code>Qualifier | None</code> <p>The qualifier to use when injecting a type that has multiple implementations.</p> <code>None</code>"},{"location":"class/wireup/#wireup.abstract","title":"<code>abstract(cls)</code>","text":"<p>Mark the decorated class as an abstract injectable.</p> <p>DEPRECATED: Use <code>@injectable(as_type=...)</code> instead.</p> <p>See the documentation for more details: https://maldoinc.github.io/wireup/latest/interfaces/</p>"},{"location":"class/wireup/#wireup.create_async_container","title":"<code>create_async_container(service_modules=None, services=None, parameters=None, *, config=None, injectables=None, concurrent_scoped_access=False)</code>","text":"<p>Create an asynchronous Wireup container.</p> <p>See the documentation for more details: https://maldoinc.github.io/wireup/latest/container/</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>dict[str, Any] | None</code> <p>Configuration to expose to the container. Injectables or factories can request config via the <code>Inject(config=\"name\")</code> annotation.</p> <code>None</code> <code>injectables</code> <code>list[Any] | None</code> <p>A list of classes or functions decorated with <code>@injectable</code> or <code>@abstract</code> or modules containing injectables to register with the container instance.</p> <code>None</code> <code>service_modules</code> <code>list[ModuleType] | None</code> <p>Deprecated: Use injectables instead.</p> <code>None</code> <code>services</code> <code>list[Any] | None</code> <p>Deprecated: Use injectables instead.</p> <code>None</code> <code>parameters</code> <code>dict[str, Any] | None</code> <p>Deprecated. Parameters was renamed to config, use that instead.</p> <code>None</code> <code>concurrent_scoped_access</code> <code>bool</code> <p>Indicates whether the scoped container will be accessed concurrently. If True, the container will use locking to ensure concurrency safety when resolving scoped dependencies. This is useful when multiple concurrent tasks need to share the same scope. If False (default), no locking is used for scoped dependencies, which improves performance but assumes the scope is accessed by a single thread or asyncio task (e.g. standard web request). See: https://maldoinc.github.io/wireup/latest/lifetimes_and_scopes/#concurrent-access</p> <code>False</code> <p>Raises:</p> Type Description <code>WireupError</code> <p>Raised if the dependencies cannot be fully resolved.</p>"},{"location":"class/wireup/#wireup.create_sync_container","title":"<code>create_sync_container(service_modules=None, services=None, parameters=None, *, config=None, injectables=None, concurrent_scoped_access=False)</code>","text":"<p>Create a synchronous Wireup container.</p> <p>See the documentation for more details: https://maldoinc.github.io/wireup/latest/container/</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>dict[str, Any] | None</code> <p>Configuration to expose to the container. Injectables or factories can request config via the <code>Inject(config=\"name\")</code> annotation.</p> <code>None</code> <code>injectables</code> <code>list[Any] | None</code> <p>A list of classes or functions decorated with <code>@injectable</code> or <code>@abstract</code> or modules containing injectables to register with the container instance.</p> <code>None</code> <code>service_modules</code> <code>list[ModuleType] | None</code> <p>Deprecated: Use injectables instead.</p> <code>None</code> <code>services</code> <code>list[Any] | None</code> <p>Deprecated: Use injectables instead.</p> <code>None</code> <code>parameters</code> <code>dict[str, Any] | None</code> <p>Deprecated. Parameters was renamed to config, use that instead.</p> <code>None</code> <code>concurrent_scoped_access</code> <code>bool</code> <p>Indicates whether the scoped container will be accessed concurrently. If True, the container will use locking to ensure concurrency safety when resolving scoped dependencies. This is useful when multiple concurrent tasks need to share the same scope. If False (default), no locking is used for scoped dependencies, which improves performance but assumes the scope is accessed by a single thread or asyncio task (e.g. standard web request). See: https://maldoinc.github.io/wireup/latest/lifetimes_and_scopes/#concurrent-access</p> <code>False</code> <p>Raises:</p> Type Description <code>WireupError</code> <p>Raised if the dependencies cannot be fully resolved.</p>"},{"location":"class/wireup/#wireup.inject_from_container","title":"<code>inject_from_container(container, scoped_container_supplier=None, _middleware=None, *, hide_annotated_names=False)</code>","text":"<p>Inject dependencies into the decorated function based on annotations. Wireup containers will attempt to provide only parameters annotated with <code>Inject</code>.</p> <p>See the documentation for more details: https://maldoinc.github.io/wireup/latest/function_injection/</p> <p>Parameters:</p> Name Type Description Default <code>container</code> <code>SyncContainer | AsyncContainer</code> <p>The root container created via <code>wireup.create_sync_container</code> or <code>wireup.create_async_container</code>.</p> required <code>scoped_container_supplier</code> <code>Callable[[], ScopedSyncContainer | ScopedAsyncContainer] | None</code> <p>An optional callable that returns the current scoped container instance. If provided, it will be used to create scoped dependencies. If not provided, the container will automatically enter a scope. Provide a scoped_container_supplier if you need to manage the container's scope manually.</p> <code>None</code> <code>hide_annotated_names</code> <code>bool</code> <p>If True, the parameters annotated with Wireup annotations will be removed from the signature of the decorated function.</p> <code>False</code>"},{"location":"class/wireup/#wireup.injectable","title":"<code>injectable(obj=None, *, qualifier=None, lifetime='singleton', as_type=None)</code>","text":"<pre><code>injectable(\n    obj: None = None,\n    *,\n    qualifier: Qualifier | None = None,\n    lifetime: InjectableLifetime = \"singleton\",\n    as_type: type[Any] | None = None\n) -&gt; Callable[[T], T]\n</code></pre><pre><code>injectable(\n    obj: T,\n    *,\n    qualifier: Qualifier | None = None,\n    lifetime: InjectableLifetime = \"singleton\",\n    as_type: type[Any] | None = None\n) -&gt; T\n</code></pre> <p>Mark the decorated class or function as a Wireup injectable.</p> <p>This decorator registers the class or function with the Wireup container. Dependencies will be automatically injected based on type hints.</p> <p>See the documentation for more details: https://maldoinc.github.io/wireup/latest/injectables/</p> <p>Parameters:</p> Name Type Description Default <code>qualifier</code> <code>Qualifier | None</code> <p>A unique identifier to distinguish between multiple implementations of the same type.</p> <code>None</code> <code>lifetime</code> <code>InjectableLifetime</code> <p>Controls the lifespan of the object (e.g. \"singleton\", \"scoped\", \"transient\"). Default is \"singleton\".</p> <code>'singleton'</code> <code>as_type</code> <code>type[Any] | None</code> <p>Register the injectable as a different type (e.g. a Protocol or ABC).</p> <code>None</code>"},{"location":"class/wireup/#wireup.service","title":"<code>service(obj=None, *, qualifier=None, lifetime='singleton')</code>","text":"<pre><code>service(\n    obj: None = None,\n    *,\n    qualifier: Qualifier | None = None,\n    lifetime: InjectableLifetime = \"singleton\"\n) -&gt; Callable[[T], T]\n</code></pre><pre><code>service(\n    obj: T,\n    *,\n    qualifier: Qualifier | None = None,\n    lifetime: InjectableLifetime = \"singleton\"\n) -&gt; T\n</code></pre> <p>Mark the decorated class or function as a Wireup service.</p> <p>DEPRECATED: Use @injectable instead.</p>"},{"location":"integrations/","title":"Integrations","text":"<p>Integrations handle the boilerplate of connecting Wireup to your framework: automatic scope management per request, injection in route handlers, and container lifecycle tied to the application.</p> <p>Wireup is framework-agnostic and can be used in any project, but it also provides integrations for the following frameworks:</p> <ul> <li> AIOHTTP</li> <li> Click</li> <li> Django</li> <li> FastAPI</li> <li> Flask</li> <li> Starlette</li> </ul>"},{"location":"integrations/aiohttp/","title":"AIOHTTP Integration","text":"<p>Dependency injection for AIOHTTP is available in the <code>wireup.integration.aiohttp</code> module.</p> <ul> <li> <p> Automatic Dependency Management</p> <p>Inject dependencies in routes and automatically manage container lifecycle.</p> </li> <li> <p> Request Objects</p> <p>Use request and websocket objects in Wireup dependencies.</p> </li> <li> <p> Zero Runtime Overhead</p> <p>Inject dependencies with zero runtime overhead in Class-Based Handlers.</p> <p> Learn more</p> </li> <li> <p> Shared business logic</p> <p>Wireup is framework-agnostic. Share the service layer between web applications and other interfaces, such as a CLI.</p> </li> </ul>"},{"location":"integrations/aiohttp/#initialize-the-integration","title":"Initialize the integration","text":"<p>First, create an async container.</p> <pre><code>container = wireup.create_async_container(\n    injectables=[services], config={\"db_dsn\": os.environ.get(\"APP_DB_DSN\")}\n)\n</code></pre> <p>Then initialize the integration:</p> <pre><code>wireup.integration.aiohttp.setup(container, app)\n</code></pre>"},{"location":"integrations/aiohttp/#inject-in-aiohttp-handlers","title":"Inject in AIOHTTP handlers","text":"<p>To inject dependencies, add the type to the handler's signature and annotate with <code>Injected[T]</code> or <code>Annotated[T, Inject(...)]</code>.</p> Function HandlersClass-Based Views Function Handler<pre><code>async def get_users(\n    request: web.Request,\n    user_repository: Injected[UserRepository],\n) -&gt; web.Response: ...\n</code></pre> <p>In Class-based views dependencies must be declared in the init method.</p> Class Based View<pre><code>class UsersView(web.View):\n    def __init__(\n        self,\n        request: web.Request,\n        user_repository: Injected[UserRepository],\n    ) -&gt; None:\n        super().__init__(request)\n        self.user_repository = user_repository\n\n    async def get(self) -&gt; web.Response: ...\n</code></pre>"},{"location":"integrations/aiohttp/#inject-aiohttp-request","title":"Inject AIOHTTP request","text":"<p>To be able to inject <code>web.Request</code>, include the <code>wireup.integration.aiohttp</code> module in the <code>injectables</code> parameter when creating the container.</p> <pre><code>container = wireup.create_async_container(\n    injectables=[services, wireup.integration.aiohttp],\n    config={\"db_dsn\": os.environ.get(\"APP_DB_DSN\")},\n)\n</code></pre>"},{"location":"integrations/aiohttp/#accessing-the-container","title":"Accessing the Container","text":"<p>If you need to access the Wireup container directly, use the following functions:</p> <pre><code>from wireup.integration.aiohttp import get_app_container, get_request_container\n\n# Get application-wide container.\napp_container: AsyncContainer = get_app_container(app)\n\n# Get request-scoped container.\n# This is what is currently injecting services on the active request.\nrequest_container: ScopedAsyncContainer = get_request_container()\n</code></pre>"},{"location":"integrations/aiohttp/#testing","title":"Testing","text":"<p>For general testing tips with Wireup refer to the test docs. With the AIOHTTP integration, you can override dependencies in the container as follows.</p> test_thing.py<pre><code>from wireup.integration.aiohttp import get_app_container\n\n\ndef test_override(aiohttp_client):\n    class DummyGreeter(GreeterService):\n        def greet(self, name: str) -&gt; str:\n            return f\"Hi, {name}\"\n\n    with get_app_container(app).override.injectable(\n        GreeterService,\n        new=DummyGreeter(),\n    ):\n        res = aiohttp_client.get(\"/greet?name=Test\")\n</code></pre> <p>See AIOHTTP integration tests for more examples.</p>"},{"location":"integrations/aiohttp/#lifecycle-management","title":"Lifecycle Management","text":"<p>The integration automatically manages the container lifecycle. It hooks into AIOHTTP's <code>on_cleanup</code> signal to ensure the container is properly closed and resources are released when the application stops.</p>"},{"location":"integrations/aiohttp/#routes-and-type-checker","title":"Routes and type checker","text":"<p>If you're using a type checker, then you may notice it showing type errors when adding dependencies to aio handlers. This is because the signature as defined in aiohttp only allows for <code>web.Request</code> in the signature.</p> <p>To address this, you can decorate the handler with <code>@wireup.integration.aiohttp.route</code>. This decorator is a no-op at runtime but provides the necessary type hints to satisfy type checkers.</p> <pre><code>from wireup.integration.aiohttp import route\n\n\n@router.get(\"/users\")\n@route\nasync def users_list(\n    request: web.Request,\n    user_repository: Injected[UserRepository],\n) -&gt; web.Response:\n    pass\n</code></pre>"},{"location":"integrations/aiohttp/#api-reference","title":"API Reference","text":"<ul> <li>aiohttp_integration</li> </ul>"},{"location":"integrations/aiohttp/class_based_handlers/","title":"Class-Based Handlers for AIOHTTP","text":"<p>Class-based handlers in Wireup provide a new mechanism for efficient dependency injection for AIOHTTP applications. They optimize performance by managing dependencies at startup rather than per request. Dependencies injected in the init method are zero-cost.</p>"},{"location":"integrations/aiohttp/class_based_handlers/#key-benefits","title":"Key Benefits","text":"<ul> <li>Request Performance: Zero overhead from dependency resolution during request handling.</li> <li>Stateful Handlers: Maintain state across requests.</li> <li>Route set: Group relevant resource endpoints together</li> </ul>"},{"location":"integrations/aiohttp/class_based_handlers/#example","title":"Example","text":"greeter.py<pre><code>class GreeterHandler:\n    router = web.RouteTableDef()  # (1)!\n\n    def __init__(self, greeter: GreeterService) -&gt; None:  # (2)!\n        self.greeter = greeter\n        self.counter = 0\n\n    @router.get(\"/greet\")\n    async def get_thing(\n        self,\n        request: web.Request,  # (3)!\n        auth_service: Injected[AuthenticationService],  # (4)!\n    ) -&gt; web.Response:\n        self.counter += 1\n\n        return web.json_response(\n            {\n                \"greeting\": self.greeter.greet(\n                    request.query.get(\"name\", \"world\")\n                ),\n                \"counter\": self.counter,\n            }\n        )\n</code></pre> <ol> <li>The class must contain a <code>web.RouteTableDef</code> instance named <code>router</code>. Use it to decorate routes inside this class.</li> <li>When injecting in the constructor the <code>Injected</code> syntax is not required.</li> <li>Like every AIOHTTP request handler, the first argument must be <code>web.Request</code>.</li> <li>Other scoped/transient dependencies can be requested in the routes. Here the <code>Injected[T]</code> annotation is required.</li> </ol> app.py<pre><code>wireup.integration.aiohttp.setup(container, app, handlers=[GreeterHandler])\n</code></pre> <p>Overriding: Handlers are created once on startup, their dependencies cannot be overridden once the application starts. If you need to override dependencies in the handler's <code>__init__</code>, then it must be done before application startup.</p>"},{"location":"integrations/click/","title":"Click Integration","text":"<p>Dependency injection for Click is available in the <code>wireup.integration.click</code> module.</p> <ul> <li> <p> Automatic Dependency Management</p> <p>Inject dependencies in Click commands.</p> </li> <li> <p> Shared business logic</p> <p>Wireup is framework-agnostic. Share the service layer between CLIs and other interfaces, such as a web application.</p> </li> </ul>"},{"location":"integrations/click/#initialize-the-integration","title":"Initialize the integration","text":"<p>First, create a container.</p> <pre><code>from typing import Annotated\nimport click\nfrom wireup import Inject, Injected, injectable\n\n\n@click.group()\ndef cli():\n    pass\n\n\ncontainer = wireup.create_sync_container(\n    injectables=[services], config={\"env\": \"development\", \"debug\": True}\n)\n</code></pre> <p>Then initialize the integration by calling <code>wireup.integration.click.setup</code> after adding all commands:</p> <pre><code># Initialize the integration.\n# Must be called after all commands have been added.\nwireup.integration.click.setup(container, cli)\n</code></pre>"},{"location":"integrations/click/#inject-in-click-commands","title":"Inject in Click Commands","text":"<p>To inject dependencies, add the type to the command's signature and annotate with <code>Injected[T]</code> or <code>Annotated[T, Inject(...)]</code>.</p> Click Command<pre><code>@cli.command()\ndef random_number(random: Injected[RandomService]):\n    click.echo(f\"Your lucky number is: {random.get_random()}\")\n\n\n@cli.command()\ndef env_info(\n    env: Annotated[str, Inject(config=\"env\")],\n    debug: Annotated[bool, Inject(config=\"debug\")],\n):\n    click.echo(f\"Environment: {env}\")\n    click.echo(f\"Debug mode: {debug}\")\n</code></pre>"},{"location":"integrations/click/#accessing-the-container","title":"Accessing the Container","text":"<p>To access the Wireup container directly, use the following:</p> <pre><code># Get application-wide container\nfrom wireup.integration.click import get_app_container\n\ncontainer = get_app_container(cli)\n</code></pre>"},{"location":"integrations/click/#testing","title":"Testing","text":"<p>When testing Click commands with dependency injection, services can be swapped out in tests by overriding services before executing the Click runner.</p> <pre><code>from click.testing import CliRunner\n\n\ndef test_random_number_command():\n    class MockRandomService:\n        def get_random(self):\n            return 4\n\n    # Create test container with mocked service\n    with container.override.injectable(RandomService, new=MockRandomService()):\n        runner = CliRunner()\n        result = runner.invoke(cli, [\"random-number\"])\n\n        assert result.exit_code == 0\n        assert \"Your lucky number is:\" in result.output\n</code></pre>"},{"location":"integrations/click/#api-reference","title":"API Reference","text":"<p>Visit API Reference for detailed information about the Click integration module.</p>"},{"location":"integrations/django/","title":"Django Integration","text":"<p>Wireup provides seamless integration with Django through the <code>wireup.integration.django</code> module, enabling dependency injection in Django applications.</p> <ul> <li> <p> Automatic Dependency Management</p> <p>Inject dependencies in routes and automatically manage container lifecycle.</p> </li> <li> <p> Request Objects</p> <p>Use Django request in Wireup dependencies.</p> </li> <li> <p> Django Settings</p> <p>The integration exposes Django settings to Wireup as config.</p> </li> <li> <p> Shared business logic</p> <p>Wireup is framework-agnostic. Share the service layer between web applications and other interfaces, such as a CLI.</p> </li> </ul>"},{"location":"integrations/django/#initialize-the-integration","title":"Initialize the integration","text":"<p>Add the following to Django settings:</p> settings.py<pre><code>import os\nfrom wireup.integration.django import WireupSettings\n\nINSTALLED_APPS = [\n    # ...existing code...\n    \"wireup.integration.django\"\n]\n\nMIDDLEWARE = [\n    \"wireup.integration.django.wireup_middleware\",\n    # ...existing code...\n]\n\nWIREUP = WireupSettings(\n    injectables=[\"mysite.polls.services\"]  # Injectable modules here\n)\n\n# Additional application settings\nS3_BUCKET_TOKEN = os.environ[\"S3_BUCKET_ACCESS_TOKEN\"]\n</code></pre>"},{"location":"integrations/django/#inject-django-settings","title":"Inject Django settings","text":"<p>Django settings can be injected into injectables:</p> mysite/polls/services/s3_manager.py<pre><code>from wireup import injectable, Inject\nfrom typing import Annotated\n\n\n@injectable\nclass S3Manager:\n    def __init__(\n        self,\n        # Reference configuration by name\n        token: Annotated[str, Inject(config=\"S3_BUCKET_TOKEN\")],\n    ) -&gt; None: ...\n\n    def upload(self, file: File) -&gt; None: ...\n</code></pre> <p>You can also use Django settings in factories:</p> mysite/polls/services/github_client.py<pre><code>from wireup import injectable\nfrom django.conf import settings\n\n\nclass GithubClient:\n    def __init__(self, api_key: str) -&gt; None: ...\n\n\n@injectable\ndef github_client_factory() -&gt; GithubClient:\n    return GithubClient(api_key=settings.GH_API_KEY)\n</code></pre>"},{"location":"integrations/django/#inject-the-current-request","title":"Inject the current request","text":"<p>The integration exposes the current Django request as a <code>scoped</code> lifetime dependency, which can be injected into <code>scoped</code> or <code>transient</code> injectables:</p> mysite/polls/services/auth_service.py<pre><code>from django.http import HttpRequest\nfrom wireup import injectable\n\n\n@injectable(lifetime=\"scoped\")\nclass AuthService:\n    def __init__(self, request: HttpRequest) -&gt; None:\n        self.request = request\n</code></pre>"},{"location":"integrations/django/#inject-dependencies-in-views","title":"Inject dependencies in views","text":"<p>To inject dependencies in views, request them by their type:</p> Sync ViewsAsync ViewsClass-Based Views app/views.py<pre><code>from django.http import HttpRequest, HttpResponse\nfrom mysite.polls.services import S3Manager\nfrom wireup import Injected\n\n\ndef upload_file_view(\n    request: HttpRequest, s3_manager: Injected[S3Manager]\n) -&gt; HttpResponse:\n    return HttpResponse(...)\n</code></pre> app/views.py<pre><code>from django.http import HttpRequest, HttpResponse\nfrom mysite.polls.services import S3Manager\nfrom wireup import Injected\n\n\nasync def upload_file_view(\n    request: HttpRequest, s3_manager: Injected[S3Manager]\n) -&gt; HttpResponse:\n    return HttpResponse(...)\n</code></pre> app/views.py<pre><code>from django.http import HttpRequest, HttpResponse\nfrom django.views import View\nfrom mysite.polls.services import S3Manager\nfrom wireup import Injected\n\n\nclass UploadFileView(View):\n    def __init__(self, s3_manager: Injected[S3Manager]) -&gt; None:\n        self.s3_manager = s3_manager\n\n    def post(self, request: HttpRequest) -&gt; HttpResponse:\n        return HttpResponse(...)\n</code></pre> <p>For more examples, see the Wireup Django integration tests.</p>"},{"location":"integrations/django/#forms-and-model-methods","title":"Forms and Model Methods","text":"<p>Use the <code>@inject</code> decorator to inject dependencies into Django Forms, Model methods, or any other function or method during a request.</p> forms.py<pre><code>from django import forms\nfrom wireup import Injected\nfrom wireup.integration.django import inject\n\n\nclass UserRegistrationForm(forms.Form):\n    username = forms.CharField()\n\n    @inject\n    def __init__(self, *args, user_service: Injected[UserService], **kwargs):\n        super().__init__(*args, **kwargs)\n        self.user_service = user_service\n\n    def clean_username(self):\n        username = self.cleaned_data[\"username\"]\n        if self.user_service.is_taken(username):\n            raise forms.ValidationError(\"Username taken\")\n        return username\n</code></pre>"},{"location":"integrations/django/#third-party-django-frameworks","title":"Third-party Django frameworks","text":"<p>If your project uses third-party packages to create views, such as Django REST framework or Django Ninja, you must use the <code>@inject</code> decorator explicitly.</p> <p>This approach should work for any Django-based framework as long as it relies on Django's <code>AppConfig</code> and middleware mechanisms.</p> Django REST FrameworkDjango Ninja app/views.py<pre><code>from rest_framework.decorators import api_view\nfrom rest_framework.request import Request\nfrom rest_framework.response import Response\nfrom rest_framework.views import APIView\nfrom rest_framework.viewsets import ViewSet\n\nfrom wireup import Injected\nfrom wireup.integration.django import inject\n\nfrom mysite.polls.services import S3Manager\n\n\n@api_view((\"GET\",))\n@inject\ndef drf_function_based_view(\n    request: Request, s3_manager: Injected[S3Manager]\n) -&gt; Response:\n    # Use the injected S3Manager instance\n    return Response(...)\n\n\nclass DRFClassBasedView(APIView):\n    @inject\n    def get(\n        self, request: Request, s3_manager: Injected[S3Manager]\n    ) -&gt; Response:\n        # Use the injected S3Manager instance\n        return Response(...)\n\n\nclass DRFViewSet(ViewSet):\n    @inject\n    def list(\n        self, request: Request, s3_manager: Injected[S3Manager]\n    ) -&gt; Response:\n        # Use the injected S3Manager instance\n        return Response(...)\n</code></pre> app/views.py<pre><code>from ninja import Router, Schema\n\nfrom wireup import Injected\nfrom wireup.integration.django import inject\n\nfrom mysite.polls.services import S3Manager\n\n\nrouter = Router()\n\n\nclass ItemSchema(Schema):\n    name: str\n    price: float\n\n\n@router.get(\"/items\")\n@inject\ndef list_items(request, s3_manager: Injected[S3Manager]):\n    # Use the injected S3Manager instance\n    return {\"items\": [...]}\n\n\n@router.post(\"/items\")\n@inject\ndef create_item(request, data: ItemSchema, s3_manager: Injected[S3Manager]):\n    # Both request body and injected service work together\n    return {\"name\": data.name, \"price\": data.price}\n</code></pre> <p>Best practice for mixing core and non-core Django views</p> <p>If your project shares core and non core-django views, consider disabling auto-injection and using <code>@inject</code> explicitly across all your views for consistency:</p> settings.py<pre><code>WIREUP = WireupSettings(\n    injectables=[\"mysite.polls.services\"],\n    auto_inject_views=False,  # Disable auto-injection\n)\n</code></pre> DoDon't <pre><code># Consistent approach: use @inject everywhere\n@inject\ndef core_django_view(\n    request: HttpRequest, service: Injected[MyService]\n) -&gt; HttpResponse:\n    return HttpResponse(...)\n\n\n@api_view((\"GET\",))\n@inject\ndef drf_view(request: Request, service: Injected[MyService]) -&gt; Response:\n    return Response(...)\n</code></pre> <pre><code># Inconsistent: mixing auto-injection and @inject\ndef core_django_view(\n    request: HttpRequest,\n    service: Injected[MyService],  # Auto-injected\n) -&gt; HttpResponse:\n    return HttpResponse(...)\n\n\n@api_view((\"GET\",))\n@inject  # Explicit injection\ndef drf_view(request: Request, service: Injected[MyService]) -&gt; Response:\n    return Response(...)\n</code></pre>"},{"location":"integrations/django/#accessing-the-container","title":"Accessing the container","text":"<p>To access the Wireup container directly, use the following functions:</p> <pre><code>from wireup.integration.django import get_app_container, get_request_container\n\n# Get application-wide container\napp_container = get_app_container()\n\n# Get request-scoped container\nrequest_container = get_request_container()\n</code></pre>"},{"location":"integrations/django/#testing","title":"Testing","text":"<p>For general testing tips with Wireup refer to the test docs. With Django you can override dependencies in the container as follows:</p> test_thing.py<pre><code>from wireup.integration.django import get_app_container\n\n\ndef test_override():\n    class DummyGreeter(GreeterService):\n        def greet(self, name: str):\n            return f\"Hi, {name}\"\n\n    with get_app_container().override.injectable(\n        GreeterService,\n        new=DummyGreeter(),\n    ):\n        res = self.client.get(\"/greet?name=Test\")\n        assert res.status_code == 200\n</code></pre> <p>Testing async views</p> <p>When testing async views, use Django's <code>AsyncClient</code> instead of the regular <code>Client</code>:</p> <pre><code>from django.test import AsyncClient\nimport pytest\n\n\n@pytest.fixture\ndef async_client():\n    return AsyncClient()\n\n\nasync def test_async_view(async_client):\n    response = await async_client.get(\"/async-endpoint/\")\n    assert response.status_code == 200\n</code></pre>"},{"location":"integrations/django/#closing-the-container","title":"Closing the Container","text":"<p>Django doesn't have built-in lifecycle events like FastAPI. If you use generator factories that require cleanup, register a shutdown handler using Python's <code>atexit</code> module:</p> myapp/__init__.py<pre><code>import atexit\nfrom wireup.integration.django import get_app_container\n\n\ndef close_container():\n    get_app_container().close()\n\n\natexit.register(close_container)\n</code></pre>"},{"location":"integrations/django/#api-reference","title":"API Reference","text":"<ul> <li>django_integration</li> </ul>"},{"location":"integrations/fastapi/","title":"FastAPI Integration","text":"<ul> <li> <p> Clean Injection</p> <p>Declare dependencies by using type annotations. No <code>Depends()</code> chains required.</p> </li> <li> <p> Zero Runtime Overhead</p> <p>Inject dependencies with zero runtime overhead using Class-Based Handlers.</p> <p> Learn more</p> </li> <li> <p> Access Anywhere</p> <p>Retrieve the container in middleware, decorators, and other places where FastAPI's DI can't reach.</p> <p> Learn more</p> </li> <li> <p> Framework-Agnostic</p> <p>Share your service layer with CLI tools, background workers, and other frameworks.</p> </li> </ul>"},{"location":"integrations/fastapi/#quick-start","title":"Quick Start","text":"<p>Here is a complete, copy-pasteable example to get you running in under 2 minutes.</p> <p>Create an async container, define your services, then initialize the integration by calling <code>wireup.integration.fastapi.setup</code> after adding all routers:</p> main.py<pre><code>import wireup\nfrom fastapi import FastAPI\nfrom wireup import injectable, Injected\nimport wireup.integration.fastapi\n\n\n# 1. Define a service (add @injectable)\n@injectable\nclass GreeterService:\n    def greet(self, name: str) -&gt; str:\n        return f\"Hello, {name}!\"\n\n\n# 2. Create the container\ncontainer = wireup.create_async_container(injectables=[GreeterService])\n\n# 3. Create the FastAPI app and define your routes\napp = FastAPI()\n\n\n@app.get(\"/\")\nasync def greet(greeter: Injected[GreeterService]):\n    return {\"message\": greeter.greet(\"World\")}\n\n\n# 4. Initialize Wireup (after all routes are added)\nwireup.integration.fastapi.setup(container, app)\n</code></pre> <p>Run the server with:</p> <pre><code>fastapi dev main.py\n</code></pre> See how Wireup compares to <code>Depends()</code> <p>This comparison shows the boilerplate reduction when using Wireup's type-based injection versus <code>Depends()</code> chains.</p> Before (Standard FastAPI)After (Wireup) <pre><code># Define your services\nclass UserRepository:\n    def __init__(self, db: Database) -&gt; None:\n        self.db = db\n\n\nclass UserService:\n    def __init__(self, repo: UserRepository) -&gt; None:\n        self.repo = repo\n\n\n# Create factory functions for each dependency\ndef get_db() -&gt; Database: ...\n\n\ndef get_user_repo(db: Annotated[Database, Depends(get_db)]) -&gt; UserRepository:\n    return UserRepository(db)\n\n\ndef get_user_service(\n    repo: Annotated[UserRepository, Depends(get_user_repo)],\n) -&gt; UserService:\n    return UserService(repo)\n\n\n# Wire up the dependency chain in the route\n@app.get(\"/users\")\nasync def list_users(\n    service: Annotated[UserService, Depends(get_user_service)],\n):\n    return service.find_all()\n</code></pre> <pre><code># Add @injectable\n@injectable\nclass UserRepository:\n    def __init__(self, db: Database) -&gt; None:\n        self.db = db\n\n\n@injectable\nclass UserService:\n    def __init__(self, repo: UserRepository) -&gt; None:\n        self.repo = repo\n\n\n# Inject directly by type\n@app.get(\"/users\")\nasync def list_users(service: Injected[UserService]):\n    return service.find_all()\n</code></pre>"},{"location":"integrations/fastapi/#features","title":"Features","text":""},{"location":"integrations/fastapi/#http-and-websocket-injection","title":"HTTP and WebSocket Injection","text":"<p>Inject dependencies in HTTP routes and WebSockets.</p> HTTP RouteWebSocket Route <pre><code>from typing import Annotated\nfrom fastapi import Depends\nfrom wireup import Injected, Inject\n\n\n@app.get(\"/random\")\nasync def target(\n    # Inject custom services\n    random_service: Injected[RandomService],\n    # Inject configuration values\n    is_debug: Annotated[bool, Inject(config=\"debug\")],\n    # You can still use regular FastAPI dependencies alongside Wireup\n    user_agent: Annotated[str | None, Header()] = None,\n): ...\n</code></pre> <pre><code>from fastapi import WebSocket\nfrom wireup import Injected\n\n\n@app.websocket(\"/ws\")\nasync def ws(websocket: WebSocket, greeter: Injected[GreeterService]): ...\n</code></pre>"},{"location":"integrations/fastapi/#class-based-handlers-zero-overhead","title":"Class-Based Handlers (Zero Overhead)","text":"<p>For the best performance and organization, use Class-Based Handlers. Dependencies injected into the constructor are resolved only once at startup, removing the overhead of dependency resolution from the request cycle entirely.</p> <pre><code>class UserHandler:\n    router = fastapi.APIRouter()\n\n    # Injected ONCE at startup (Zero runtime cost)\n    def __init__(self, user_service: UserProfileService) -&gt; None:\n        self.user_service = user_service\n\n    @router.get(\"/\")\n    async def list_all(self):\n        return self.user_service.find_all()\n</code></pre> <p> Read the Class-Based Handlers guide (similar to <code>@cbv</code> from <code>fastapi-utils</code>, but with zero per-request overhead)</p> <p>Performance Tip: Use WireupRoute</p> <p>Improve performance in function-based routes by using a custom <code>APIRoute</code> class. This reduces overhead in endpoints that use Wireup injection by avoiding redundant processing.</p> <pre><code>from fastapi import APIRouter\nfrom wireup.integration.fastapi import WireupRoute\n\nrouter = APIRouter(route_class=WireupRoute)\n</code></pre> <p>Under the hood: FastAPI processes all route parameters, including ones meant for Wireup. The <code>WireupRoute</code> class optimizes this by making Wireup-specific parameters only visible to Wireup, removing unnecessary processing by FastAPI's dependency injection system.</p>"},{"location":"integrations/fastapi/#injecting-request-websocket","title":"Injecting Request &amp; WebSocket","text":"<p>To inject the <code>Request</code> or <code>WebSocket</code> object into your scoped-lifetime services (e.g. for logging or auth), add <code>wireup.integration.fastapi</code> to your container and request <code>fastapi.Request</code> or <code>fastapi.WebSocket</code> in your dependencies.</p> <pre><code>import wireup\nimport wireup.integration.fastapi\n\ncontainer = wireup.create_async_container(\n    # Add the integration module to injectables\n    injectables=[services, wireup.integration.fastapi],\n)\n</code></pre> <pre><code>import fastapi\n\n\n@injectable(lifetime=\"scoped\")\nclass HttpAuthenticationService:\n    def __init__(self, request: fastapi.Request) -&gt; None: ...\n</code></pre>"},{"location":"integrations/fastapi/#testing","title":"Testing","text":"<p>For general testing tips with Wireup refer to the test docs. With the FastAPI integration, you can override dependencies in the container as follows.</p> test_thing.py<pre><code>from wireup.integration.fastapi import get_app_container\n\n\ndef test_override(client):\n    class DummyGreeter(GreeterService):\n        def greet(self, name: str) -&gt; str:\n            return f\"Hi, {name}\"\n\n    with get_app_container(app).override.injectable(\n        GreeterService,\n        new=DummyGreeter(),\n    ):\n        res = client.get(\"/greet?name=Test\")\n</code></pre> Pitfall: Why <code>lru_cache</code> leaks state in tests <p>In standard FastAPI applications, singletons are often implemented using <code>@lru_cache</code>. This can cause state to leak between tests because the cache persists globally in memory.</p> <pre><code># Standard FastAPI\n@lru_cache\ndef get_settings():\n    return Settings()\n\n\ndef test_one():\n    # Modifies the cached settings instance\n    get_settings().debug = True\n\n\ndef test_two():\n    # FAILS: This test inherits the modified state from test_one!\n    assert get_settings().debug is False\n</code></pre> <p>Wireup avoids this automatically.</p> <p>When you create a fresh container/app for each test (via a pytest fixture), Wireup creates fresh instances of all your services. There is no global cache to clear.</p> <p>See FastAPI integration tests for more examples.</p> <p>Warning</p> <p>FastAPI's lifespan events are required to close the Wireup container properly. Use a context manager when instantiating the test client if using class-based handlers or generator factories in the application.</p> <pre><code>@pytest.fixture()\ndef client(app: FastAPI) -&gt; Iterator[TestClient]:\n    with TestClient(app) as client:\n        yield client\n</code></pre> <p> Read the full Testing guide</p>"},{"location":"integrations/fastapi/#api-reference","title":"API Reference","text":"<ul> <li>fastapi_integration</li> </ul>"},{"location":"integrations/fastapi/class_based_handlers/","title":"Class Based Handlers","text":"<p>Wireup provides native support for Class-Based Handlers (also known as Controllers or Class-Based Views). This allows you to group related endpoints into a single class, sharing dependencies and logic.</p> <p>Coming from <code>fastapi-utils</code>?</p> <p>This is Wireup's equivalent to <code>@cbv</code> but with true zero-overhead constructor injection.</p>"},{"location":"integrations/fastapi/class_based_handlers/#zero-overhead","title":"Zero-Overhead","text":"<p>With standard FastAPI <code>Depends()</code>, dependencies are resolved on every request. Even for singletons (typically implemented via <code>@lru_cache</code>), FastAPI invokes its dependency injection mechanism to retrieve the same cached value.</p> <p>With Wireup's Class-Based Handlers, constructor dependencies are resolved exactly once when the application starts. This removes dependency resolution from the request cycle entirely, resulting in zero per-request overhead.</p>"},{"location":"integrations/fastapi/class_based_handlers/#when-to-use-what","title":"When to use what?","text":"Injection Type Lifecycle Performance Cost Best For Constructor (<code>__init__</code>) Startup Zero (Paid once) Singletons, Configuration, API Clients, Stateless Services Method (<code>Injected[...]</code>) Per Request Low (Normal DI cost) User Context, Database Sessions, Request-Scoped Data"},{"location":"integrations/fastapi/class_based_handlers/#usage-guide","title":"Usage Guide","text":""},{"location":"integrations/fastapi/class_based_handlers/#1-define-the-handler","title":"1. Define the Handler","text":"<p>Create a class with a <code>router</code> attribute. Use <code>WireupRoute</code> to enable method injection.</p> controllers/user_controller.py<pre><code>import fastapi\nfrom wireup import Injected\nfrom wireup.integration.fastapi import WireupRoute\n\n\nclass UserHandler:\n    # 1. Define a router. Use WireupRoute to enable injection in methods.\n    router = fastapi.APIRouter(\n        prefix=\"/users\", tags=[\"Users\"], route_class=WireupRoute\n    )\n\n    # 2. Inject Singletons/Config here (Zero Overhead)\n    def __init__(\n        self, user_service: UserProfileService, db_pool: DbPool\n    ) -&gt; None:\n        self.user_service = user_service\n        self.db_pool = db_pool\n\n    # 3. Standard FastAPI decorators work as expected\n    @router.get(\"/\")\n    async def list_users(self):\n        # reuse self.user_service without re-injection\n        return self.user_service.find_all()\n\n    # 4. Inject Request-Scoped dependencies in methods\n    @router.get(\"/me\")\n    async def get_profile(\n        self,\n        # This is injected fresh for every request\n        auth: Injected[AuthenticationService],\n    ) -&gt; fastapi.Response:\n        return self.user_service.get_profile(auth.current_user)\n</code></pre> <p>Why the different injection syntax?</p> <p>The handler class is instantiated by Wireup (like any <code>@injectable</code>), so constructor parameters use plain type hints. Route methods are called by FastAPI, so any additional dependencies need <code>Injected[T]</code> to distinguish them from regular FastAPI parameters like <code>Query</code>, <code>Path</code>, etc.</p>"},{"location":"integrations/fastapi/class_based_handlers/#2-register-the-handler","title":"2. Register the Handler","text":"<p>Pass your handler classes to <code>wireup.integration.fastapi.setup</code>. Do not include the router in the FastAPI app manually; Wireup handles this for you.</p> main.py<pre><code>wireup.integration.fastapi.setup(\n    container,\n    app,\n    class_based_handlers=[\n        UserHandler,\n        OrderHandler,\n        ProductHandler,\n    ],\n)\n</code></pre>"},{"location":"integrations/fastapi/class_based_handlers/#testing","title":"Testing","text":"<p>Class-Based Handlers are initialized during the FastAPI Lifespan (startup event). When testing, you must ensure the lifecycle events are triggered.</p> <p>The easiest way is to use <code>TestClient</code> as a context manager.</p> conftest.py<pre><code>import pytest\nfrom fastapi import FastAPI\nfrom fastapi.testclient import TestClient\n\n\n@pytest.fixture\ndef client(app: FastAPI):\n    # This triggers startup/shutdown events, initializing your handlers\n    with TestClient(app) as client:\n        yield client\n</code></pre>"},{"location":"integrations/fastapi/class_based_handlers/#overriding-dependencies","title":"Overriding Dependencies","text":"<p>To test with overridden dependencies (mocks, stubs, fakes, etc.), set up the override before creating the <code>TestClient</code>.</p> <pre><code>from wireup.integration.fastapi import get_app_container\n\n\ndef test_user_handler(app):\n    with get_app_container(app).override.injectable(\n        UserProfileService, new=MockUserService()\n    ):\n        # Start the client INSIDE the override block\n        # The handler is initialized with the mock during startup\n        with TestClient(app) as client:\n            client.get(\"/users/\")\n</code></pre> <p>Performance Tip</p> <p>If you have high-traffic endpoints, moving dependencies from <code>Injected[...]</code> (method) to <code>__init__</code> (constructor) can measurably improve latency by skipping the dependency resolution step entirely for those requests.</p>"},{"location":"integrations/fastapi/class_based_handlers/#next-steps","title":"Next Steps","text":"<ul> <li>FastAPI Integration - Full integration overview.</li> <li>Lifetimes &amp; Scopes - Understand when to use singletons vs scoped dependencies.</li> </ul>"},{"location":"integrations/fastapi/direct_container_access/","title":"Direct container access","text":"<p>Advanced Feature</p> <p>You should rarely need this. Prefer standard <code>@injectable</code> classes and method injection <code>Injected[T]</code> whenever possible. Direct container access couples your code to the Service Locator pattern, which is generally less testable and harder to maintain than Dependency Injection.</p> <p>Wireup primarily handles dependency injection in FastAPI routes. However, you can directly access the request or application container to retrieve services when needed outside of standard dependency injection.</p> <p>Some examples of when you might need to do this:</p> <ul> <li>Middleware: logging, tracing, authentication checks</li> <li>Route decorators: <code>@require_admin</code>, <code>@rate_limit</code>, etc.</li> <li>FastAPI Dependencies: when composing Wireup services with <code>Depends()</code></li> </ul> <pre><code>from wireup.integration.fastapi import get_app_container, get_request_container\n\n# Access the request-scoped container (used for the current request).\n# This is what you almost always want.\n# It has all the information the app container has in addition\n# to data specific to the current request.\nrequest_container = get_request_container()\n\n# Access the application-wide container (created via `wireup.create_async_container`).\n# Use this when you need the container outside of the request context lifecycle.\napp_container = get_app_container(app)\n</code></pre>"},{"location":"integrations/fastapi/direct_container_access/#container-availability","title":"Container Availability","text":"<p>The app container is always retrievable given an instance of the application.</p> <p>If you need the request-scoped container outside the route handler (middleware, FastAPI dependencies, decorators), enable <code>middleware_mode</code> during setup.</p> <pre><code>wireup.integration.fastapi.setup(container, app, middleware_mode=True)\n</code></pre> <p>Normally, the container is created just before the route handler is called, and only on endpoints with Wireup dependencies. With this mode enabled, the request-scoped container is created at the start of the request lifecycle, making it available everywhere. This offers the greatest flexibility but runs on every request.</p> <pre><code>@router.get(\"/users\")\n@require_authn  # Request container is available here\nasync def get_users(user_service: Injected[UserService]):  # And here\n    pass\n</code></pre>"},{"location":"integrations/fastapi/direct_container_access/#examples-using-middleware-mode","title":"Examples Using Middleware Mode","text":""},{"location":"integrations/fastapi/direct_container_access/#in-route-decorators","title":"In Route Decorators","text":"<pre><code>@contextlib.asynccontextmanager\nasync def require_permission(permission: str) -&gt; AsyncIterator[None]:\n    auth = await get_request_container().get(AuthService)\n\n    if not await auth.has_permission(permission):\n        raise HTTPException(status_code=403, detail=\"Insufficient permissions\")\n\n    yield\n\n\n@router.get(\"/users\")\n@require_permission(\"read_users\")\nasync def get_users(user_service: Injected[UserService]): ...\n</code></pre>"},{"location":"integrations/fastapi/direct_container_access/#in-middleware-requires-middleware-mode","title":"In Middleware (Requires Middleware Mode)","text":"<pre><code>from wireup.integration.fastapi import get_request_container\n\n\nasync def example_middleware(request: Request, call_next) -&gt; Response:\n    container = get_request_container()\n    ...\n    return await call_next(request)\n</code></pre>"},{"location":"integrations/fastapi/direct_container_access/#in-fastapi-dependencies-requires-middleware-mode","title":"In FastAPI Dependencies (Requires Middleware Mode)","text":"<pre><code>from wireup.integration.fastapi import get_request_container\n\n\nasync def get_example_dependency(\n    request: Request,\n    other_dependency: Annotated[Other, Depends(...)],\n):\n    container = get_request_container()\n    ...\n\n\n@router.get(\"/users\")\nasync def get_users(\n    example: Annotated[Example, Depends(get_example_dependency)],\n): ...\n</code></pre> <p>Warning</p> <p>Mixing Wireup and <code>fastapi.Depends</code> is discouraged and should be avoided unless necessary.</p> <p>Keep in mind that while accessing the Wireup container in FastAPI dependencies is possible, the reverse is not: Wireup services cannot depend on objects provided by <code>fastapi.Depends</code>.</p>"},{"location":"integrations/flask/","title":"Flask Integration","text":"<p>Dependency injection for Flask is available in the <code>wireup.integration.flask</code> module.</p> <ul> <li> <p> Automatic Dependency Management</p> <p>Inject dependencies in routes and automatically manage container lifecycle.</p> </li> <li> <p> Shared business logic</p> <p>Wireup is framework-agnostic. Share the service layer between web applications and other interfaces, such as a CLI.</p> </li> </ul>"},{"location":"integrations/flask/#initialize-the-integration","title":"Initialize the integration","text":"<p>First, create a sync container with your dependencies:</p> <pre><code>from flask import Flask\nfrom wireup import Inject, Injected, injectable\n\napp = Flask(__name__)\napp.config[\"FOO\"] = \"bar\"\n\ncontainer = wireup.create_sync_container(\n    injectables=[services],\n    config={\n        **app.config,  # Optionally expose flask configuration to the container\n        \"API_KEY\": \"secret\",\n    },\n)\n</code></pre> <p>Then initialize the integration by calling <code>wireup.integration.flask.setup</code> after adding all views and configuration:</p> <pre><code># Initialize the integration.\n# Must be called after views and configuration have been added.\nwireup.integration.flask.setup(container, app)\n</code></pre>"},{"location":"integrations/flask/#inject-in-flask-views","title":"Inject in Flask Views","text":"<p>To inject dependencies, add the type to the view's signature and annotate with <code>Injected[T]</code> or <code>Annotated[T, Inject(...)]</code>.</p> Flask View<pre><code>@app.get(\"/random\")\ndef get_random(random: Injected[RandomService]):\n    return {\"lucky_number\": random.get_random()}\n\n\n@app.get(\"/env\")\ndef get_environment(\n    is_debug: Annotated[bool, Inject(config=\"DEBUG\")],\n    foo: Annotated[str, Inject(config=\"FOO\")],\n):\n    return {\"debug\": is_debug, \"foo\": foo}\n</code></pre>"},{"location":"integrations/flask/#accessing-the-container","title":"Accessing the Container","text":"<p>To access the Wireup container directly, use the following functions:</p> <pre><code>from wireup.integration.flask import get_app_container, get_request_container\n\n# Get application-wide container\napp_container = get_app_container(app)\n\n# Get request-scoped container\nrequest_container = get_request_container()\n</code></pre>"},{"location":"integrations/flask/#testing","title":"Testing","text":"<p>For general testing tips with Wireup refer to the test docs. With the Flask integration, you can override dependencies in the container as follows.</p> test_thing.py<pre><code>from wireup.integration.flask import get_app_container\n\n\ndef test_override():\n    class DummyGreeter(GreeterService):\n        def greet(self, name: str) -&gt; str:\n            return f\"Hi, {name}\"\n\n    with get_app_container(app).override.injectable(\n        GreeterService,\n        new=DummyGreeter(),\n    ):\n        res = self.client.get(\"/greet?name=Test\")\n</code></pre> <p>See Flask integration tests for more examples.</p>"},{"location":"integrations/flask/#api-reference","title":"API Reference","text":"<ul> <li>flask_integration</li> </ul>"},{"location":"integrations/starlette/","title":"Starlette Integration","text":"<p>The <code>wireup.integration.starlette</code> module provides dependency injection for Starlette applications.</p> <ul> <li> <p> Automatic Dependency Management</p> <p>Automatically manage the container lifecycle and inject dependencies into endpoints.</p> </li> <li> <p> Shared Business Logic</p> <p>Wireup is framework-agnostic, allowing the service layer to be shared across web applications and other interfaces, such as CLIs.</p> </li> </ul>"},{"location":"integrations/starlette/#setting-up-the-integration","title":"Setting Up the Integration","text":"<p>First, create an async container with your dependencies:</p> <pre><code>from starlette.applications import Starlette\nfrom starlette.routing import Route\nimport wireup\n\napp = Starlette()\n\ncontainer = wireup.create_async_container(\n    injectables=[services],\n    config={\"DEBUG\": True},  # Optionally expose configuration to services\n)\n</code></pre> <p>Then set up the integration using <code>wireup.integration.starlette.setup</code>:</p> <pre><code># Set up the integration.\nwireup.integration.starlette.setup(container, app)\n</code></pre>"},{"location":"integrations/starlette/#injecting-dependencies-into-endpoints","title":"Injecting Dependencies into Endpoints","text":"<p>To inject dependencies, apply the <code>@inject</code> decorator from the <code>wireup.integration.starlette</code> module to endpoints and annotate parameters with <code>Injected[T]</code> or <code>Annotated[T, Inject(...)]</code>.</p> Starlette Endpoint<pre><code>from starlette.endpoints import HTTPEndpoint\nfrom starlette.requests import Request\nfrom starlette.responses import JSONResponse, PlainTextResponse\n\nfrom wireup import injectable, Injected\nfrom wireup.integration.starlette import inject\n\n\n@inject\nasync def get_random(\n    request: Request,\n    random: Injected[RandomService],\n) -&gt; JSONResponse:\n    return JSONResponse({\"lucky_number\": random.get_random()})\n\n\nclass HelloEndpoint(HTTPEndpoint):\n    @inject\n    async def get(\n        self,\n        request: Request,\n        greeter: Injected[GreeterService],\n    ) -&gt; PlainTextResponse:\n        greeting = greeter.greet(request.query_params.get(\"name\", \"World\"))\n\n        return PlainTextResponse(greeting)\n</code></pre>"},{"location":"integrations/starlette/#inject-starlette-request-or-websocket","title":"Inject Starlette request or WebSocket","text":"<p>To inject the current request/websocket in services, include the <code>wireup.integration.starlette</code> module in the injectables when creating the container.</p> <pre><code>container = wireup.create_async_container(\n    injectables=[..., wireup.integration.starlette],\n)\n</code></pre>"},{"location":"integrations/starlette/#using-starlette-request","title":"Using Starlette Request","text":"Example Service using Starlette Request<pre><code>@injectable(lifetime=\"scoped\")\nclass RequestContext:\n    def __init__(self, request: Request):\n        self.request = request\n\n    @property\n    def name(self) -&gt; str:\n        return self.request.query_params.get(\"name\", \"World\")\n</code></pre>"},{"location":"integrations/starlette/#accessing-the-container-directly","title":"Accessing the Container Directly","text":"<p>You can directly access the Wireup container using the following functions:</p> <pre><code>from wireup.integration.starlette import (\n    get_app_container,\n    get_request_container,\n)\n\n# Access the request-scoped container (used for the current request).\n# This is what you almost always want.\n# It has all the information the app container has in addition\n# to data specific to the current request.\n# You can get an instance of the request container in decorators or other middleware.\nrequest_container = get_request_container()\n\n# Access the application-wide container created with `wireup.create_async_container`.\n# Use this for operations outside the request lifecycle.\napp_container = get_app_container(app)\n</code></pre>"},{"location":"integrations/starlette/#testing","title":"Testing","text":"<p>For general testing tips, see the testing documentation. To override dependencies in the container during tests, use the following approach:</p> test_thing.py<pre><code>from wireup.integration.starlette import get_app_container\n\n\nclass UppercaseGreeter(GreeterService):\n    def greet(self, name: str) -&gt; str:\n        return super().greet(name).upper()\n\n\ndef test_override():\n    container = get_app_container(app)\n\n    with container.override.injectable(GreeterService, new=UppercaseGreeter()):\n        response = client.get(\"/hello\", params={\"name\": \"world\"})\n\n    assert response.text == \"HELLO WORLD\"\n</code></pre> <p>For more examples, see the Starlette integration tests.</p>"},{"location":"integrations/starlette/#lifecycle-management","title":"Lifecycle Management","text":"<p>The integration automatically manages the container lifecycle by hooking into Starlette's lifespan context to ensure the container is properly closed and resources are released when the application stops.</p>"},{"location":"integrations/starlette/#api-reference","title":"API Reference","text":"<ul> <li>starlette_integration</li> </ul>"}]}