{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Wireup","text":"<p>Performant, concise, and easy-to-use dependency injection container for Python 3.8+.</p> <p> </p>"},{"location":"#key-features","title":"Key features","text":"<ul> <li> <p> Dependency Injection</p> <p>Inject services and configuration using a clean and intuitive syntax.</p> <p>Getting Started</p> </li> <li> <p> Autoconfiguration</p> <p>Automatically inject dependencies based on their types without additional configuration for the most common use cases.</p> <p> Learn more</p> </li> <li> <p> Interfaces / Abstract classes</p> <p>Define abstract types and have the container automatically inject the implementation.</p> <p> Learn more</p> </li> <li> <p> Factory pattern</p> <p>Defer instantiation to specialized factories for full control over object creation when necessary.</p> <p> Learn more</p> </li> <li> <p> Singletons/Transient dependencies</p> <p>Declare dependencies as transient or singletons which tells the container whether to inject a fresh copy or reuse existing instances.</p> <p> Learn more</p> </li> <li> <p> Declarative/Imperative</p> <p>Configure services through annotations in a fully declarative style or build everything by code for full control over instantiation.</p> <p> Learn more</p> </li> </ul>"},{"location":"#framework-integrations","title":"Framework integrations","text":"<p>Simplified use with the following frameworks.</p> <ul> <li> Django</li> <li> FastAPI</li> <li> Flask</li> </ul>"},{"location":"#license","title":"License","text":"<p>This project is licensed under the terms of the MIT license.</p>"},{"location":"annotations/","title":"Annotations","text":"<p>Autowiring relies on annotations or hints to be able to inject dependencies. When it is not possible to automatically locate a given dependency, it must be annotated with additional metadata.</p>"},{"location":"annotations/#when-do-you-need-to-provide-annotations","title":"When do you need to provide annotations.","text":"Injecting Annotations required? What is required Services No Interface with only one implementation No Default implementation of an interface No Interface with multiple implementations Yes Qualifier Parameters Yes Parameter name Parameter expressions Yes Expression"},{"location":"annotations/#annotation-types","title":"Annotation types","text":"<p>Wireup supports two types of annotations. Using Python's <code>Annotated</code> and default values.</p>"},{"location":"annotations/#annotated","title":"Annotated","text":"<p>This is the preferred method for Python 3.9+ and moving forward. It is also recommended to backport this using <code>typing_extensions</code> for Python 3.8.</p> <pre><code>@container.autowire\ndef target(\n    env: Annotated[str, Inject(param=\"env_name\")],\n    logs_cache_dir: Annotated[str, Inject(expr=\"${cache_dir}/logs\")],\n):\n    ...\n</code></pre>"},{"location":"annotations/#default-values-deprecated","title":"Default values (deprecated)","text":"<p>This relies on the use of default values to inject parameters. Anything that can be passed to <code>Annotated</code> may also be used here.</p> <pre><code>@container.autowire\ndef target(\n    env: str = Inject(param=\"env_name\"), \n    logs_cache_dir: str = Inject(expr=\"${cache_dir}/logs\")\n):\n    ...\n</code></pre>"},{"location":"annotations/#explicit-injection-annotation","title":"Explicit injection annotation","text":"<p>Even though annotating services is optional, you CAN still annotate them to be explicit about what will  be injected. This also has the benefit of raising when the service does not exist instead of silently skipping this parameter.</p> <pre><code>@container.autowire\ndef target(random_service: Annotated[RandomService, Inject()]):\n    ...\n</code></pre>"},{"location":"configuration/","title":"Configuration","text":"<p>Wireup configuration can be injected through annotations or programmatically using factory functions.  You can also mix and match the two as necessary.</p>"},{"location":"configuration/#annotations","title":"@ Annotations","text":"<p>This declarative approach uses configuration metadata provided by decorators and annotations to define services and dependencies between them. It allows you to declare the final state and let the container handle the rest.</p> <p>This generally results in less boilerplate code compared to a programmatic approach and is how many popular frameworks operate.</p>"},{"location":"configuration/#programmatic","title":"\ud83c\udfed Programmatic","text":"<p>With a programmatic approach, you have full control over how services are created and can keep service definitions devoid of container references if this is important to you.</p> <p>This approach results in more code as you will need to write these factories and construct services yourself.</p> <p>This will also be somewhat familiar if you're coming from FastAPI, with the major difference being that you won't need to <code>Depends(get_service_from_function)</code> everywhere.</p> <p>Factories can request dependencies as usual and may use annotations for configuration.</p>"},{"location":"configuration/#annotation-based-configuration","title":"@ Annotation-based configuration","text":"<p>In addition to service objects, the container also holds configuration, called parameters.</p> <p>You can modify the parameters by updating the <code>container.params</code> dict.</p> <p>Warning</p> <p>Parameters represent application configuration.  They are not intended to pass values around or to be used as a global session object.</p> <p>Store only app configuration such as environment name, database url, mailer url etc.</p>"},{"location":"configuration/#injection","title":"Injection","text":""},{"location":"configuration/#by-name","title":"By name","text":"<p>To inject a parameter by name, annotate the type with <code>Inject(param=\"param_name\")</code>.</p> <pre><code>@container.autowire\ndef target(cache_dir: Annotated[str, Inject(param=\"cache_dir\")]) -&gt; None:\n    ...\n</code></pre> <pre><code>@service\nclass GithubClient:\n    def __init__(self, api_key: Annotated[str, Inject(param=\"gh_api_key\")]) -&gt; None:\n        ...\n</code></pre>"},{"location":"configuration/#parameter-expressions","title":"Parameter expressions","text":"<p>It is possible to interpolate parameters using a special syntax. This will enable you to retrieve several parameters at once and concatenate their values together.</p> <p>Note: As the result is a string, non-string parameters will be converted using <code>str()</code>.</p> <pre><code>@container.autowire\ndef target(logs_dir: Annotated[str, Inject(expr=\"${cache_dir}/${env}/logs\")]) -&gt; None:\n    ...\n</code></pre>"},{"location":"configuration/#class-based-configuration","title":"\ud83c\udfed Class-based configuration","text":"<p>While Wireup provides its own configuration mechanism in the form of parameters, it is entirely optional. If you prefer using typed classes for configuration, they are also supported via factories.</p> <p>The main idea is to register your settings as a service and inject it into factories like a regular dependency.</p>"},{"location":"configuration/#configuration","title":"Configuration","text":"<p>Assume your configuration is defined in an class such as this. Examples use pydantic-settings but any class will work exactly the same.</p> settings.py<pre><code>from pydantic_settings import BaseSettings\nfrom pydantic import Field, PostgresDsn\n\n\nclass Settings(BaseSettings):\n    gh_api_key: str = Field(alias=\"gh_api_key\")  \n    pg_dsn: PostgresDsn = Field(alias=\"pg_dsn\")  \n</code></pre>"},{"location":"configuration/#services","title":"Services","text":"<p>Next step would be to define a few services, such as <code>GithubClient</code> and a <code>DatabaseConnection</code>.</p> services/github_client.py<pre><code>@dataclass\nclass GithubClient:\n    api_key: str\n</code></pre> services/db.py<pre><code>@dataclass\nclass DatabaseConnection:\n    dsn: str\n</code></pre>"},{"location":"configuration/#factories","title":"Factories","text":"<p>To wire everything together we can use a few factories.</p> factories.py<pre><code>from wireup import service, container\n\n@service\ndef settings_factory() -&gt; Settings:\n    return Settings(...)\n\n\n# Now that settings is registered with the container \n# it is possible to inject it like a regular service.\n@service\ndef github_client_factory(settings: Settings) -&gt; GithubClient:\n    return GithubClient(api_key=settings.gh_api_key)\n\n\n@service\ndef database_connection_factory(settings: Settings) -&gt; DatabaseConnection:\n    return DatabaseConnection(dsn=str(settings.pg_dsn))\n</code></pre>"},{"location":"demo_app/","title":"Demo application","text":"<p>Check out maldoinc/wireup-demo  for a demo Flask application using Wireup.</p> <p>It shows creation, injection and testing in the context of a simple \"Blog\" application.</p>"},{"location":"factory_functions/","title":"Factory functions","text":"<p>Typically getting the necessary dependencies is enough to construct an object. However, there are scenarios where you need to delegate service creation to a special function called a  factory.</p>"},{"location":"factory_functions/#use-cases","title":"Use cases","text":"<ul> <li>Object construction needs additional logic or configuration.</li> <li>Depending on the runtime environment or configuration, you may need to create different objects  inheriting from the same base (See: Strategy Pattern) or configure them differently. </li> <li>Inject a model/dto which represents the result of an action, such as the current authenticated user.</li> <li>Inject a class from another library where it's not possible to add annotations.</li> </ul>"},{"location":"factory_functions/#usage","title":"Usage","text":"<p>In order for the container to inject these dependencies, you must register the factory function by using the <code>@service</code> decorator.</p> <p>When the container needs to inject a dependency, it checks known factories to see if any of them can create it.</p> <p>Good to know</p> <p>Return type annotation of the factory is required as it denotes what will be built.</p>"},{"location":"factory_functions/#examples","title":"Examples","text":""},{"location":"factory_functions/#inject-a-model","title":"Inject a model","text":"<p>Assume in the context of an application a class <code>User</code> exists and represents a user of the system. We can use a factory to inject a user model that represents the current authenticated user.</p> <pre><code>from wireup import service, ServiceLifetime\n\n# You may want to create a new type to make a distinction on the type of user this is.\nAuthenticatedUser = NewType(\"AuthenticatedUser\", User)\n\n\n@service(lifetime=ServiceLifetime.TRANSIENT)\ndef get_current_user(auth_service: AuthService) -&gt; AuthenticatedUser:\n    return AuthenticatedUser(auth_service.get_current_user())\n\n\n# Now it is possible to inject the authenticated user directly wherever it is necessary.\n@container.autowire\ndef get_user_logs(user: AuthenticatedUser):\n    ...\n</code></pre>"},{"location":"factory_functions/#implement-strategy-pattern","title":"Implement strategy pattern","text":"<p>Assume a base class <code>Notifier</code> with implementations that define how the notification is sent (IMAP, POP, WebHooks, etc.) Given a user it is possible to instantiate the correct type of notifier based on user preferences.</p> <pre><code>from wireup import service, ServiceLifetime\n\n\n@service(lifetime=ServiceLifetime.TRANSIENT)\ndef get_user_notifier(\n    user: AuthenticatedUser, \n    slack_notifier: SlackNotifier, \n    email_mailer: EmailNotifier\n) -&gt; Notifier:\n    notifier = ...  # get notifier type from preferences.\n\n    return notifier\n</code></pre> <p>When injecting <code>Notifier</code> the correct type will be injected based on the authenticated user's preferences.</p>"},{"location":"factory_functions/#inject-a-third-party-class","title":"Inject a third-party class","text":"<p>You can use factory functions to inject a class which you have not declared yourself and therefore cannot annotate.  Let's take redis client as an example. </p> @ Annotations\ud83c\udfed Programmatic <pre><code>from wireup import service\n\n\n@service\ndef redis_factory(redis_url: Annotated[str, Inject(param=\"redis_url\")]) -&gt; Redis:\n    return redis.from_url(redis_url)\n</code></pre> <pre><code>from wireup import service\n\n\n@service\ndef redis_factory(settings: Settings) -&gt; Redis:\n    return redis.from_url(settings.redis_url)\n</code></pre>"},{"location":"factory_functions/#links","title":"Links","text":"<ul> <li>Introduce to an existing project</li> </ul>"},{"location":"getting_started/","title":"Getting started","text":"<p>This walkthrough will introduce you to the most common use cases for a typical application. </p> <p>We'll build a simple weather forecast application that calls a remote weather service  and uses a distributed key-value store to cache results.</p>"},{"location":"getting_started/#1-setup","title":"1. Setup","text":""},{"location":"getting_started/#installation","title":"Installation","text":"<p>Install wireup using pip or your favorite package manager.</p> <pre><code>$ pip install wireup\n</code></pre>"},{"location":"getting_started/#configuration","title":"Configuration","text":"<p>Use Wireup the way you prefer</p> <p>The container can be configured through annotations or programmatically. It was designed with annotations in mind but all features are available with either approach.</p> <p>Sections below show how to achieve the same result using each method. Learn more.</p> <p>The first step is to initialize the container on application startup.</p> @ Annotations\ud83c\udfed Programmatic main.py<pre><code>import os\nfrom wireup import container, initialize_container\nfrom myapp import services\n\ndef create_app():\n    app = ...\n\n    # \u2b07\ufe0f Start the container: Register and initialize services.\n    initialize_container(\n        container,\n        # Parameters serve as service configuration.\n        parameters={\n            \"redis_url\": os.environ[\"APP_REDIS_URL\"],\n            \"weather_api_key\": os.environ[\"APP_WEATHER_API_KEY\"]\n        },\n        # Top-level modules containing service registrations.\n        service_modules=[services]\n    )\n\n    return app\n</code></pre> <p>Register application settings as a service.</p> services/config.py<pre><code>from pydantic_settings import BaseSettings\nfrom wireup import service\n\n@service\nclass Settings(BaseSettings):\n    redis_url: str = Field(alias=\"APP_REDIS_URL\")  \n    weather_api_key: str = Field(alias=\"APP_WEATHER_API_KEY\")  \n</code></pre> <p>In the application's entrypoint initialize wireup.</p> main.py<pre><code>from pydantic import Field\nfrom wireup import container, initialize_container\n\nfrom myapp import services\n\ndef create_app():\n    app = ...\n\n    # \u2b07\ufe0f Start the container: Register and initialize services.\n    # service_modules is a list of top-level modules containing registrations.\n    initialize_container(container, service_modules=[services])\n\n    return app\n</code></pre> <p>Now that the setup is complete, let's move on to the next step.</p>"},{"location":"getting_started/#2-define-services","title":"2. Define services","text":""},{"location":"getting_started/#keyvaluestore","title":"KeyValueStore","text":"<p>First, let's add a <code>KeyValueStore</code> service. We wrap Redis with a class that abstracts it. </p> <p>While we have the option to inject Redis directly,  in this example, we've chosen the abstraction route. </p> <p>The Redis client requires specific configuration details to establish a connection with the server, which we fetch from the configuration.</p> @ Annotations\ud83c\udfed Programmatic <p>With a declarative approach, the container uses configuration metadata  provided from decorators and annotations to define services and the dependencies between them.  This means that the service declaration is self-contained and does not require additional setup.</p> services/key_value_store.py<pre><code>from wireup import service, Inject\nfrom typing_extensions import Annotated\n\n@service  #(1)!\nclass KeyValueStore:\n    def __init__(self, dsn: Annotated[str, Inject(param=\"redis_url\")]) -&gt; None:  #(2)!\n        self.client = redis.from_url(dsn)\n\n    def get(self, key: str) -&gt; Any: ...\n    def set(self, key: str, value: Any): ...\n</code></pre> <ol> <li>Decorators do not modify the classes in any way and only serve to collect metadata.     This makes testing simpler, as you can still instantiate this like a regular class in your tests.</li> <li>Parameters must be annotated with the <code>Inject(param=name)</code> syntax. This tells the container which parameter to inject.</li> </ol> <p>The <code>@service</code> decorator marks this class as a service to be registered in the container. Decorators and annotations are read once during the call to <code>initialize_container</code>.</p> <p>With this approach, services are devoid of container references.  Registration and creation is handled by factory functions.</p> services/key_value_store.py<pre><code>class KeyValueStore:\n    def __init__(self, dsn: str) -&gt; None:\n        self.client = redis.from_url(dsn)\n\n    def get(self, key: str) -&gt; Any: ...\n    def set(self, key: str, value: Any): ...\n</code></pre> <p>The <code>@service</code> decorator makes this factory known with the container.. Decorators/annotations are read once during the call to <code>initialize_container</code>.  Return type is mandatory and denotes what will be built.</p> services/factories.py<pre><code>from wireup import service\n\n@service\ndef key_value_store_factory(settings: Settings) -&gt; KeyValueStore:\n    return KeyValueStore(dsn=settings.redis_url)\n</code></pre>"},{"location":"getting_started/#weatherservice","title":"WeatherService","text":"<p>Next, we add a weather service that will perform requests against a remote server and cache results as necessary.</p> @ Annotations\ud83c\udfed Programmatic <p>The <code>api_key</code> field contains the value of the <code>weather_api_key</code> parameter as specified in the annotation.  <code>KeyValueStore</code> will be automatically injected without requiring additional metadata.</p> services/weather.py<pre><code>from wireup import service\n\n@service #(1)!\n@dataclass # TIP: Use alongside dataclasses to simplify init code.\nclass WeatherService:\n    api_key: Annotated[str, Inject(param=\"weather_api_key\")]\n    kv_store: KeyValueStore\n\n    async def get_forecast(self, lat: float, lon: float) -&gt; WeatherForecast:\n        raise NotImplementedError\n</code></pre> <ol> <li> <ul> <li>Injection is supported for regular classes as well as dataclasses.</li> <li>With dataclasses it is important that the <code>@dataclass</code> decorator is applied before <code>@service</code>.</li> </ul> </li> <li> <ul> <li>Use type hints to indicate which dependency to inject.</li> <li>Dependencies are automatically discovered and injected.</li> </ul> </li> </ol> services/weather.py<pre><code>@dataclass \nclass WeatherService:\n    api_key: str\n    kv: KeyValueStore\n\n    async def get_forecast(self, lat: float, lon: float) -&gt; WeatherForecast:\n        raise NotImplementedError\n</code></pre> services/factories.py<pre><code>from wireup import service\n\n@service\ndef weather_service_factory(settings: Settings, kv_store: KeyValueStore) -&gt; WeatherService:\n    return WeatherService(api_key=settings.weather_api_key, kv=kv_store)\n</code></pre> <p>That concludes service creation. The container knows how to build services and inject them as necessary.</p>"},{"location":"getting_started/#3-inject","title":"3. Inject","text":"<p>The final step would be to decorate functions where the container needs to perform injection. Decorate injection targets with <code>@container.autowire</code>.</p> views/posts.py<pre><code>@app.get(\"/weather/forecast\")\n@container.autowire # (1)!\nasync def get_forecast_view(weather_service: WeatherService):\n    return await weather_service.get_forecast(...)\n</code></pre> <ol> <li>Decorate methods where the library must perform injection.</li> </ol>"},{"location":"getting_started/#conclusion","title":"Conclusion","text":"<p>This concludes the \"Getting Started\" walkthrough, covering the most common dependency injection use cases.</p> <p>Good to know</p> <ul> <li>The <code>@container.autowire</code> decorator is not needed for services.</li> <li>When using the FastAPI, or Flask integrations, decorating views with <code>@container.autowire</code> is no longer required.</li> <li>Wireup can perform injection on both sync and async targets.</li> </ul>"},{"location":"getting_started/#next-steps","title":"Next Steps","text":"<p>While Wireup is framework-agnostic, usage can be further simplified in following frameworks:</p> <ul> <li>Django</li> <li>FastAPI</li> <li>Flask</li> </ul>"},{"location":"getting_started/#links","title":"Links","text":"<ul> <li>Services</li> <li>Configuration</li> <li>Factory functions</li> </ul>"},{"location":"interfaces/","title":"Interfaces","text":"<p>Sometimes you might want to inject an interface rather than the concrete implementation directly.  Since Python doesn't have built-in interfaces, you can use any class marked as abstract.</p> <p>This method makes testing easier as you can create dummy implementations of these services in your tests in order to control their behavior.</p>"},{"location":"interfaces/#example","title":"Example","text":"<p>The following code registers <code>Engine</code> as an interface. This implies that <code>Engine</code> can't be directly injected.  Instead, a dependency that implements the interface must also be registered in the container.</p> <p>To use interfaces, register a dependency that directly inherits the interface  with the container. When injecting, ask for the interface itself, not the implementations.</p> <pre><code>from wireup import abstract, container, service\n\n\n@abstract\nclass Engine(abc.ABC):\n    @abc.abstractmethod\n    def get_type(self) -&gt; EngineType:\n        raise NotImplementedError\n\n\n@service\nclass CombustionEngine(Engine):\n    @override\n    def get_type(self) -&gt; EngineType:\n        return EngineType.COMBUSTION\n\n\n@container.autowire\ndef target(engine: Engine):\n    engine_type = engine.get_type()  # Returns EngineType.COMBUSTION\n    ...\n</code></pre>"},{"location":"interfaces/#multiple-implementations","title":"Multiple implementations","text":"<p>If an interface has multiple implementations, associate each of them with a qualifier. This is essentially a tag used to differentiate between implementations.</p> <pre><code>@service(qualifier=\"electric\")\nclass ElectricEngine(Engine):\n    def get_type(self):\n        return EngineType.ELECTRIC\n\n\n@service(qualifier=\"combustion\")\nclass CombustionEngine(Engine):\n    def get_type(self) -&gt; EngineType:\n        return EngineType.COMBUSTION\n</code></pre> <p>When injecting an interface with multiple implementing dependencies, you need to specify a qualifier to indicate  which concrete class should be resolved.</p> <pre><code>@container.autowire\ndef target(\n    engine: Annotated[Engine, Inject(qualifier=\"electric\")],\n    combustion: Annotated[Engine, Inject(qualifier=\"combustion\")],\n):\n    ...\n</code></pre> <p>Tip</p> <p>Qualifiers can be anything hashable, not just strings! For the above example, <code>EngineType</code> enum members could have been used as qualifiers just as well.</p>"},{"location":"interfaces/#default-implementation","title":"Default implementation","text":"<p>If there are many implementations associated with a given interface, you may want to associate one of them as the default implementation.</p> <p>To accomplish that, omit the qualifier when registering the implementation.</p> <pre><code>@service  # &lt;-- Qualifier being absent will make this the default impl.\nclass ElectricEngine(Engine):\n    pass\n\n@service(qualifier=\"combustion\")\nclass CombustionEngine(Engine):\n    pass\n</code></pre> <p>In the above example when asking for <code>Engine</code> the container will inject <code>ElectricEngine</code>. To inject the other implementations  you need to specify the qualifier as usual.</p>"},{"location":"introduce_to_an_existing_project/","title":"Introduce to an existing project","text":"<p>For large existing projects, you may want to gradually add wireup to the project. One of the issues you will run into sooner or later is being able to share resources between code that uses DI and the rest of the application  which does not. </p> <p>This is especially useful to allow the container to inject dependencies created elsewhere.</p> <p>Think of a database connection. Your application probably already has one. Instead of opening a second connection using a new database service, instruct the container on how to get the connection by using factory functions.</p> <p>Another case might be an existing service that is already constructed elsewhere, and you want to be able to inject it.</p>"},{"location":"introduce_to_an_existing_project/#using-factory-functions","title":"Using Factory functions","text":"<p>In order to expose such resources to the container, use factory functions.</p> <pre><code>from wireup import service\n\n@service\ndef db_connection_factory() -&gt; Connection:\n    return get_existing_db_configuration(...)\n</code></pre> <p>Now it is possible to inject <code>Connection</code> just like any other dependency. </p>"},{"location":"introduce_to_an_existing_project/#links","title":"Links","text":"<ul> <li>Factory functions</li> </ul>"},{"location":"multiple_registrations/","title":"Multiple registrations","text":"<p>Registering the same class multiple times is supported under different qualifiers through factories. </p> <p>A use case for this would be to have multiple services connected to resources of the same underlying type,  such as maintaining two database connections: a main and a read-only copy.</p>"},{"location":"multiple_registrations/#example","title":"Example","text":"<p>Assume an application with two databases: A main one and a read-only replica. In these scenarios, the main connection handles writes, and the read-only one will handle reads.</p>"},{"location":"multiple_registrations/#service-registration-via-factories","title":"Service registration via factories","text":"db_service.py<pre><code>from typing import Annotated\nfrom wireup import service, Inject\n\n# Define a class that holds the base methods for interacting with the db.\nclass DatabaseService:\n    def __init__(self, dsn: str) -&gt; None:\n        self.__connection = ...\n\n    def query(self) -&gt; ...:\n        return self.__connection.query(...)\n\n\n# Define a factory which creates and registers the service interacting with the main db.\n# Register this directly without using a qualifier, this will be injected\n# when services depend on DatabaseService.\n@service\ndef main_db_connection_factory(\n    dsn: Annotated[str, Inject(param=\"APP_DB_DSN\")]\n) -&gt; DatabaseService:\n    return DatabaseService(dsn)\n\n# This factory registers the function using the qualifier \"readonly\"\n# and requests the parameter that corresponds to the read replica DSN.\n@service(qualifier=\"readonly\")\ndef read_db_connection_factory(\n    dsn: Annotated[str, Inject(param=\"APP_READ_DB_DSN\")]\n) -&gt; DatabaseService:\n    return DatabaseService(dsn)\n</code></pre>"},{"location":"multiple_registrations/#usage","title":"Usage","text":"thing_repository.py<pre><code>from dataclasses import dataclass\nfrom wireup import service\n\n\n@service\n@dataclass\nclass ThingRepository:\n    # Main db connection can be injected directly as it is registered\n    # without a qualifier, this makes it the \"default\" implementation.\n    main_db_connection: DatabaseService\n\n    # To inject the read connection the qualifier must be specified.\n    read_db_connection: Annotated[DatabaseService, Inject(qualifier=\"readonly\")]\n\n    def create_thing(self, ...) -&gt; None:\n        return self.main_db_connection...\n\n    def find_by_id(self, pk: int) -&gt; Thing:\n        return self.read_db_connection...\n</code></pre>"},{"location":"services/","title":"Services","text":"<p>Use service objects to implement functionality in your application. Services can depend on configuration or other services.</p>"},{"location":"services/#registration","title":"Registration","text":"<p>Wireup does not enforce a code structure. Services may live anywhere in the application but must  be registered with the container.  Top-level modules containing registrations must also be declared in the <code>initialize_container</code> call.</p> <p>To register a class as a service you can decorate it with <code>@service</code> or <code>@abstract</code>.</p>"},{"location":"services/#lifetime","title":"Lifetime","text":"<p>By default, the container will keep in memory only a single copy of each service.  If you need to generate fresh instances every time a service is injected,  then it needs to be registered with the <code>lifetime</code> parameter set to <code>TRANSIENT</code>.</p>"},{"location":"services/#injection","title":"Injection","text":"<p>Injection will be performed based on type hints. Most of the time no manual configuration is needed.</p> <p>Tip</p> <p>Refer to the documentation regarding Annotations for the exact details on when you need to explicitly annotate your dependencies.</p>"},{"location":"services/#autowiring","title":"Autowiring","text":"<p>To perform injection the method must be decorated with <code>@container.autowire</code>. This does not apply to services which do not need the autowire decorator.</p>"},{"location":"testing/","title":"Testing","text":""},{"location":"testing/#unit-tests","title":"Unit tests","text":"<p>Unit testing service objects is meant to be easy as the container does not interfere in any way with the underlying classes.</p> <p>Classes can be instantiated as usual in tests, and you need to pass dependencies  such as services or parameters to them yourself.</p> <p>To specify custom behavior for tests, provide a custom implementation  or a subclass that returns test data as a dependency instead of mocks.</p> <p>It is also possible to use the container to build a part of your dependencies by calling <code>container.get(ThingService)</code> which will return a <code>ThingService</code> instance.</p>"},{"location":"testing/#overriding","title":"Overriding","text":"<p>Sometimes you need to be able to swap a service object on the fly for a different one such as a mock.</p> <p>The <code>container.override</code> property provides access to a number of useful methods and context managers which help with overriding dependencies  (See override manager).</p> <p>Good to know</p> <ul> <li>Overriding only applies to future autowire calls.</li> <li>Once a singleton service has been instantiated, it is not possible to directly replace any of its direct or transitive dependencies via overriding as the object is already in memory.<ul> <li>You will need to call <code>container.clear_initialized_objects()</code> and then override the  desired service. This will make the container use the override when the  new copy of the service is being built.</li> </ul> </li> <li>When using injecting interfaces and/or qualifiers, override the interface and/or qualifier  rather than the implementation that will be injected.</li> </ul>"},{"location":"testing/#examples","title":"Examples","text":""},{"location":"testing/#context-manager","title":"Context Manager","text":"<pre><code>random_mock = MagicMock()\n# Chosen by fair dice roll. Guaranteed to be random.\nrandom_mock.get_random.return_value = 4\n\nwith self.container.override.service(target=RandomService, new=random_mock):\n    # Assuming in the context of a web app:\n    # /random endpoint has a dependency on RandomService\n    # requests to inject RandomService during the lifetime\n    # of this context manager will result in random_mock being injected instead.\n    response = client.get(\"/random\")\n</code></pre>"},{"location":"testing/#python-unittest","title":"Python unittest","text":"<p>Use the setup method to replace a service with a mock for the duration of the test. </p> <pre><code>class SomeEndpointTest(unittest.TestCase):\n    def setUp(self) -&gt; None:\n        self.db_service = MagicMock()\n\n        # Drop references to initialized objects.\n        # Services or autowire targets requesting DBService\n        # will get the mocked object instead.\n        container.clear_initialized_objects()\n        container.override.service(DbService, new=self.db_service)\n</code></pre>"},{"location":"testing/#pytest","title":"Pytest","text":"<p>Similar to the above example but this uses pytest's autouse to achieve the same result.</p> <pre><code>@pytest.fixture(autouse=True)\ndef setup_container(db_service_mock: MagicMock) -&gt; None:\n    container.clear_initialized_objects()\n    container.override.service(DbService, new=db_service_mock)\n\ndef test_something_with_mocked_db_service(client: TestClient, db_service_mock: MagicMock):\n    # Set up the db service mock\n    db_service_mock.get_things.return_value = ...\n    response = client.get(\"/some/path\")\n\n    # Assert response and mock calls.\n</code></pre>"},{"location":"versioning/","title":"Versioning","text":"<p>This library adheres to Semantic Versioning (Semver) principles to ensure predictable versioning and compatibility for its users. </p> <ul> <li>Semver consists of three distinct version components: MAJOR, MINOR, and PATCH, separated by dots (e.g., 1.2.3). </li> <li>Changes in the MAJOR version indicate backward-incompatible changes, such as breaking API alterations. </li> <li>MINOR version updates signify new, backward-compatible features or enhancements, while PATCH versions are reserved for backward-compatible bug fixes. </li> <li>Releases with a MAJOR version of 0 are considered pre-release and as such, the api is considered unstable.   Minor-version releases may contain breaking changes as the api evolves.</li> <li>The following is considered public API</li> <li>Direct exports of the <code>wireup</code> package.</li> <li>Accessible objects from the public interface of the above exported objects.</li> </ul> <p>Tip</p> <p>When using a pre-release version, pin the constraint to <code>0.x.*</code> so that you don't accidentally upgrade to a version with breaking changes, but are still able to get bug-fix releases.</p>"},{"location":"class/dependency_container/","title":"DependencyContainer","text":"<p>Dependency Injection and Service Locator container registry.</p> <p>This contains all the necessary information to initialize registered classes. Objects instantiated by the container are lazily loaded and initialized only on first use.</p> <p>Provides the following decorators: <code>register</code>, <code>abstract</code> and <code>autowire</code>. Use register on factory functions and concrete classes which are to be injected from the container. Abstract classes are to be used as interfaces and will not be injected directly, rather concrete classes which implement them will be injected instead.</p> <p>Use the <code>autowire</code> decorator on methods where dependency injection must be performed. Services will be injected automatically where possible. Parameters will have to be annotated as they cannot be located from type alone.</p>"},{"location":"class/dependency_container/#wireup.ioc.dependency_container.DependencyContainer-attributes","title":"Attributes","text":""},{"location":"class/dependency_container/#wireup.ioc.dependency_container.DependencyContainer.context","title":"<code>context: InitializationContext</code>  <code>property</code>","text":"<p>The initialization context for registered targets. A map between an injection target and its dependencies.</p>"},{"location":"class/dependency_container/#wireup.ioc.dependency_container.DependencyContainer.override","title":"<code>override: OverrideManager</code>  <code>property</code>","text":"<p>Override registered container services with new values.</p>"},{"location":"class/dependency_container/#wireup.ioc.dependency_container.DependencyContainer.params","title":"<code>params: ParameterBag</code>  <code>property</code>","text":"<p>Parameter bag associated with this container.</p>"},{"location":"class/dependency_container/#wireup.ioc.dependency_container.DependencyContainer-functions","title":"Functions","text":""},{"location":"class/dependency_container/#wireup.ioc.dependency_container.DependencyContainer.__init__","title":"<code>__init__(parameter_bag)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>parameter_bag</code> <code>ParameterBag</code> <p>ParameterBag instance holding parameter information.</p> required"},{"location":"class/dependency_container/#wireup.ioc.dependency_container.DependencyContainer.abstract","title":"<code>abstract(klass)</code>","text":"<p>Register a type as an interface.</p> <p>This type cannot be initialized directly and one of the components implementing this will be injected instead.</p>"},{"location":"class/dependency_container/#wireup.ioc.dependency_container.DependencyContainer.autowire","title":"<code>autowire(fn)</code>","text":"<p>Automatically inject resources from the container to the decorated methods.</p> <p>Any arguments which the container does not know about will be ignored so that another decorator or framework can supply their values. This decorator can be used on both async and blocking methods.</p> <ul> <li>Classes will be automatically injected.</li> <li>Parameters need to be annotated in order for container to be able to resolve them</li> <li>When injecting an interface for which there are multiple implementations you need to supply a qualifier   using annotations.</li> </ul>"},{"location":"class/dependency_container/#wireup.ioc.dependency_container.DependencyContainer.clear_initialized_objects","title":"<code>clear_initialized_objects()</code>","text":"<p>Drop references to initialized singleton objects.</p> <p>Calling this will cause the container to drop references to initialized singletons and cause it to create new instances when they are requested to be injected.</p> <p>This can be useful in tests in a <code>unittest.TestCase.setUp</code> method or pytest autouse=True fixture, allowing you to have a fresh copy of the container with no previously initialized instances to make test cases independent of each-other.</p>"},{"location":"class/dependency_container/#wireup.ioc.dependency_container.DependencyContainer.get","title":"<code>get(klass, qualifier=None)</code>","text":"<p>Get an instance of the requested type.</p> <p>Use this to locate services by their type but strongly prefer using injection instead.</p> <p>Parameters:</p> Name Type Description Default <code>qualifier</code> <code>Qualifier | None</code> <p>Qualifier for the class if it was registered with one.</p> <code>None</code> <code>klass</code> <code>type[T]</code> <p>Class of the dependency already registered in the container.</p> required <p>Returns:</p> Type Description <code>T</code> <p>An instance of the requested object. Always returns an existing instance when one is available.</p>"},{"location":"class/dependency_container/#wireup.ioc.dependency_container.DependencyContainer.is_type_known","title":"<code>is_type_known(klass)</code>","text":"<p>Given a class type return True if's registered in the container as a service or interface.</p>"},{"location":"class/dependency_container/#wireup.ioc.dependency_container.DependencyContainer.register","title":"<code>register(obj=None, *, qualifier=None, lifetime=ServiceLifetime.SINGLETON)</code>","text":"<p>Register a dependency in the container. Dependency must be either a class or a factory function.</p> <ul> <li>Use as a decorator without parameters @container.register on a factory function or class to register it.</li> <li>Use as a decorator with parameters to specify qualifier and lifetime, @container.register(qualifier=...).</li> <li>Call it directly with @container.register(some_class_or_factory, qualifier=..., lifetime=...).</li> </ul>"},{"location":"class/dependency_container/#wireup.ioc.dependency_container.DependencyContainer.warmup","title":"<code>warmup()</code>","text":"<p>Initialize all singleton dependencies registered in the container.</p> <p>This should be executed once all services are registered with the container. Targets of autowire will not be affected.</p>"},{"location":"class/django_integration/","title":"django_integration","text":""},{"location":"class/django_integration/#wireup.integration.django.apps-attributes","title":"Attributes","text":""},{"location":"class/django_integration/#wireup.integration.django.apps-classes","title":"Classes","text":""},{"location":"class/django_integration/#wireup.integration.django.apps.WireupConfig","title":"<code>WireupConfig</code>","text":"<p>               Bases: <code>AppConfig</code></p> <p>Integrate wireup with Django.</p>"},{"location":"class/django_integration/#wireup.integration.django.apps-functions","title":"Functions","text":""},{"location":"class/fastapi_integration/","title":"fastapi_integration","text":""},{"location":"class/fastapi_integration/#wireup_init_fastapi_integration","title":"wireup_init_fastapi_integration","text":"<p>Integrate wireup with a fastapi application.</p> <p>This must be called once all views have been registered.  Decorates all views where container objects are being used making  the <code>@container.autowire</code> decorator no longer needed.</p> <p>Parameters:</p> Name Type Description Default <code>app</code> <code>FastAPI</code> <p>The application instance</p> required <code>service_modules</code> <code>list[ModuleType]</code> <p>A list of python modules where application services reside. These will be loaded to trigger container registrations.</p> required <code>dependency_container</code> <code>DependencyContainer</code> <p>The instance of the dependency container. The default wireup singleton will be used when this is unset. This will be a noop and have no performance penalty for views which do not use the container.</p> <code>container</code>"},{"location":"class/flask_integration/","title":"flask_integration","text":""},{"location":"class/flask_integration/#wireup_init_flask_integration","title":"wireup_init_flask_integration","text":"<p>Integrate wireup with a flask application.</p> <p>This must be called once all flask configuration and views have been registered.  Updates the container with flask configuration and decorates all views where container objects  are being used making the <code>@container.autowire</code> decorator no longer needed.</p> <p>Parameters:</p> Name Type Description Default <code>flask_app</code> <code>Flask</code> <p>The flask application instance</p> required <code>service_modules</code> <code>list[ModuleType]</code> <p>A list of python modules where application services reside. These will be loaded to trigger container registrations.</p> required <code>dependency_container</code> <code>DependencyContainer</code> <p>The instance of the dependency container. The default wireup singleton will be used when this is unset. This will be a noop and have no performance penalty for views which do not use the container.</p> <code>container</code> <code>config_prefix</code> <code>str | None</code> <p>If set to a value all registered configuration will be prefixed with config and be accessible via \"prefix.config_name\". E.g: app.DEBUG.</p> <code>None</code>"},{"location":"class/initialization_context/","title":"InitializationContext","text":"<p>The initialization context for registered targets. A map between an injection target and its dependencies.</p> <p>Container uses this to determine what to inject for each target.</p>"},{"location":"class/initialization_context/#wireup.ioc.initialization_context.InitializationContext-attributes","title":"Attributes","text":""},{"location":"class/initialization_context/#wireup.ioc.initialization_context.InitializationContext.dependencies","title":"<code>dependencies: Mapping[AutowireTarget, dict[str, AnnotatedParameter]]</code>  <code>property</code>","text":"<p>Read-only view of the dependency definitions.</p>"},{"location":"class/initialization_context/#wireup.ioc.initialization_context.InitializationContext.lifetime","title":"<code>lifetime: Mapping[type, ServiceLifetime]</code>  <code>property</code>","text":"<p>Read-only view of service lifetime mapping.</p>"},{"location":"class/initialization_context/#wireup.ioc.initialization_context.InitializationContext-functions","title":"Functions","text":""},{"location":"class/initialization_context/#wireup.ioc.initialization_context.InitializationContext.__init__","title":"<code>__init__()</code>","text":"<p>Create a new InitializationContext.</p>"},{"location":"class/initialization_context/#wireup.ioc.initialization_context.InitializationContext.add_dependency","title":"<code>add_dependency(target, parameter_name, value)</code>","text":"<p>Update the mapping of dependencies for a particular target.</p> <p>Registers a new dependency for the parameter in parameter_name. Target must have been already initialized prior to calling this.</p>"},{"location":"class/initialization_context/#wireup.ioc.initialization_context.InitializationContext.init_target","title":"<code>init_target(target, lifetime=None)</code>","text":"<p>Initialize the context for a particular target.</p> <p>Returns true on first call. If the target is already registered it returns False.</p>"},{"location":"class/initialization_context/#wireup.ioc.initialization_context.InitializationContext.remove_dependencies","title":"<code>remove_dependencies(target, names_to_remove)</code>","text":"<p>Remove dependencies with names in <code>names_to_remove</code> from the given target.</p> <p>Target must have been already initialized prior to calling this.</p>"},{"location":"class/override_manager/","title":"OverrideManager","text":"<p>Enables overriding of services registered with the container.</p>"},{"location":"class/override_manager/#wireup.ioc.override_manager.OverrideManager-functions","title":"Functions","text":""},{"location":"class/override_manager/#wireup.ioc.override_manager.OverrideManager.clear","title":"<code>clear()</code>","text":"<p>Clear active service overrides.</p>"},{"location":"class/override_manager/#wireup.ioc.override_manager.OverrideManager.delete","title":"<code>delete(target, qualifier=None)</code>","text":"<p>Clear active override for the <code>target</code> service.</p>"},{"location":"class/override_manager/#wireup.ioc.override_manager.OverrideManager.service","title":"<code>service(target, new, qualifier=None)</code>","text":"<p>Override the <code>target</code> service with <code>new</code> for the duration of the context manager.</p> <p>Subsequent autowire calls to <code>target</code> will result in <code>new</code> being injected.</p> <p>Parameters:</p> Name Type Description Default <code>target</code> <code>type</code> <p>The target service to override.</p> required <code>qualifier</code> <code>Qualifier | None</code> <p>The qualifier of the service to override. Set this if service is registered with the qualifier parameter set to a value.</p> <code>None</code> <code>new</code> <code>Any</code> <p>The new object to be injected instead of <code>target</code>.</p> required"},{"location":"class/override_manager/#wireup.ioc.override_manager.OverrideManager.services","title":"<code>services(overrides)</code>","text":"<p>Override a number of services with new for the duration of the context manager.</p>"},{"location":"class/override_manager/#wireup.ioc.override_manager.OverrideManager.set","title":"<code>set(target, new, qualifier=None)</code>","text":"<p>Override the <code>target</code> service with <code>new</code>.</p> <p>Subsequent autowire calls to <code>target</code> will result in <code>new</code> being injected.</p> <p>Parameters:</p> Name Type Description Default <code>target</code> <code>type</code> <p>The target service to override.</p> required <code>qualifier</code> <code>Qualifier | None</code> <p>The qualifier of the service to override. Set this if service is registered with the qualifier parameter set to a value.</p> <code>None</code> <code>new</code> <code>Any</code> <p>The new object to be injected instead of <code>target</code>.</p> required"},{"location":"class/parameter_bag/","title":"ParameterBag","text":"<p>Parameter flat key-value store for use with a container.</p> <p>Allows storing and retrieving of parameters in the bag. Templated strings can be used to interpolate a string referencing parameters.</p>"},{"location":"class/parameter_bag/#wireup.ioc.parameter.ParameterBag-functions","title":"Functions","text":""},{"location":"class/parameter_bag/#wireup.ioc.parameter.ParameterBag.__init__","title":"<code>__init__()</code>","text":"<p>Initialize an empty ParameterBag.</p> <p>ParameterBag holds a flat key-value store of parameter values. __bag: A dictionary to store parameter values. __cache: A cache for interpolated values. __param_cache: A dictionary to keep track of which cache entries involve each parameter.</p>"},{"location":"class/parameter_bag/#wireup.ioc.parameter.ParameterBag.get","title":"<code>get(param)</code>","text":"<p>Get the value of a parameter.</p> <p>If the parameter is templated, interpolate it first by replacing placeholders with parameter values.</p> <p>Parameters:</p> Name Type Description Default <code>param</code> <code>ParameterReference</code> <p>The parameter to retrieve.</p> required <p>Returns:</p> Type Description <code>Any</code> <p>The parameter's value.</p>"},{"location":"class/parameter_bag/#wireup.ioc.parameter.ParameterBag.get_all","title":"<code>get_all()</code>","text":"<p>Get all parameters stored in the bag.</p> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>A dictionary containing all parameter names and their values.</p>"},{"location":"class/parameter_bag/#wireup.ioc.parameter.ParameterBag.put","title":"<code>put(name, val)</code>","text":"<p>Put a parameter value into the bag. This overwrites any previous values.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the parameter.</p> required <code>val</code> <code>Any</code> <p>The value of the parameter.</p> required"},{"location":"class/parameter_bag/#wireup.ioc.parameter.ParameterBag.update","title":"<code>update(new_params)</code>","text":"<p>Update the bag with new set of parameters.</p> <p>Parameters from new_params will overwrite any existing parameters set with the same name.</p> <p>Parameters:</p> Name Type Description Default <code>new_params</code> <code>dict[str, Any]</code> <p>A dictionary of parameter names and their updated values.</p> required"},{"location":"class/parameter_enum/","title":"ParameterEnum","text":"<p>               Bases: <code>Enum</code></p> <p>Enum with a <code>.wire</code> method allowing easy injection of members.</p> <p>Allows you to add application parameters as enum members and their names as values. When you need to inject a parameter instead of referencing it by name you can annotate the parameter with the wire function call or set that as the default value.</p> <p>This will inject a parameter by name and won't work with expressions.</p>"},{"location":"class/parameter_enum/#wireup.ParameterEnum-functions","title":"Functions","text":""},{"location":"class/parameter_enum/#wireup.ParameterEnum.wire","title":"<code>wire()</code>","text":"<p>Inject the parameter this enumeration member represents.</p> <p>Equivalent of <code>Inject(param=EnumParam.enum_member.value)</code></p>"},{"location":"class/wireup/","title":"wireup","text":""},{"location":"class/wireup/#wireup.container","title":"<code>wireup.container = DependencyContainer(ParameterBag())</code>  <code>module-attribute</code>","text":"<p>Singleton DI container instance.</p> <p>Use when your application only needs one container.</p>"},{"location":"class/wireup/#wireup.wire","title":"<code>wireup.wire(*, param=None, expr=None, qualifier=None)</code>","text":"<p>Inject resources from the container to autowired method arguments.</p>"},{"location":"integrations/","title":"Integrations","text":"<p>Wireup is framework-agnostic and can be used in any project, but it also provides integrations for the following frameworks:</p> <ul> <li> Django</li> <li> FastAPI</li> <li> Flask</li> </ul>"},{"location":"integrations/django/","title":"Django","text":"<p>Dependency injection for Django is available via the provided integration in <code>wireup.integration.django</code>.</p>"},{"location":"integrations/django/#installation","title":"Installation","text":"<p>To install the integration, add <code>wireup.integration.django</code> to <code>INSTALLED_APPS</code> and define a new <code>WIREUP</code> setting.</p> settings.py<pre><code>import os\nfrom wireup.integration.django import WireupSettings\n\nINSTALLED_APPS = [\n    ...,\n    \"wireup.integration.django\"\n]\n\nWIREUP = WireupSettings(\n    # This is a list of top-level modules containing service registrations.\n    # It can be either a list of strings or module types.\n    service_modules=[\"mysite.polls.services\"]\n)\n\n# Additional application settings.\nS3_BUCKET_ACCESS_TOKEN = os.environ[\"S3_BUCKET_ACCESS_TOKEN\"]\n</code></pre>"},{"location":"integrations/django/#usage","title":"Usage","text":""},{"location":"integrations/django/#define-some-services","title":"Define some services","text":"mysite/polls/services/s3_manager.py<pre><code>from wireup import service\n\n\n@service\n@dataclass\nclass S3Manager:\n    # Reference configuration by name.\n    # This is the same name this appears in settings.\n    access_token: Annotated[str, Inject(param=\"S3_BUCKET_ACCESS_TOKEN\")]\n\n    def upload(self, file: File) -&gt; None: ...\n</code></pre> <p>It is also possible to use django settings in factories.</p> mysite/polls/services/github_client.py<pre><code>@dataclass\nclass GithubClient:\n    api_key: str\n</code></pre> mysite/polls/services/factories.py<pre><code>from wireup import service\n\n\n@service\ndef github_client_factory() -&gt; GithubClient:\n    return GithubClient(settings.GH_API_KEY)\n</code></pre>"},{"location":"integrations/django/#use-in-views","title":"Use in views","text":"app/views.py<pre><code>from wireup import container\n\n\n@container.autowire\ndef upload_file_view(request: HttpRequest, s3_manager: S3Manager) -&gt; HttpResponse:\n    return HttpResponse(...)\n</code></pre> <p>Class-based views are also supported. You can autowire the <code>__init__</code> or the handler method as necessary. </p> <p>For more examples see the Wireup Django integration tests.</p>"},{"location":"integrations/django/#api-reference","title":"Api Reference","text":"<ul> <li>django_integration</li> </ul>"},{"location":"integrations/fastapi/","title":"FastAPI","text":"<p>Dependency injection for FastAPI is available in the <code>wireup.integration.fastapi_integration</code> module.</p> <p>Features:</p> <ul> <li>Automatically decorate Flask views and blueprints where the container is being used.<ul> <li>Eliminates the need for <code>@container.autowire</code> in views.</li> <li>Views without container references will not be decorated.</li> <li>Services must be annotated with <code>Inject()</code>.</li> </ul> </li> <li>Can: Mix FastAPI dependencies and Wireup in views</li> <li>Can: Autowire FastAPI target with <code>@container.autowire</code>.</li> <li>Cannot: Use FastAPI dependencies in Wireup service objects.</li> </ul> <p>Tip</p> <p>As FastAPI does not have a fixed configuration mechanism, you need to expose  configuration to the container. See configuration docs for more details.</p>"},{"location":"integrations/fastapi/#examples","title":"Examples","text":"<pre><code>app = FastAPI()\n\n@app.get(\"/random\")\nasync def target(\n    # Inject annotation tells wireup that this argument should be injected.\n    random_service: Annotated[RandomService, Inject()],\n    is_debug: Annotated[bool, Inject(param=\"env.debug\")],\n\n    # This is a regular FastAPI dependency.\n    lucky_number: Annotated[int, Depends(get_lucky_number)]\n):\n    return {\n      \"number\": random_service.get_random(), \n      \"lucky_number\": lucky_number,\n      \"is_debug\": is_debug,\n    }\n\n# Update container configuration.\n# See Configuration page for more information.\ncontainer.params.update(Settings().model_dump())\n\n# Initialize the integration.\n# Must be called after views have been registered.\n# Pass to service_modules a list of top-level modules where your services reside.\nwireup_init_fastapi_integration(app, service_modules=[services])\n</code></pre>"},{"location":"integrations/fastapi/#api-reference","title":"Api Reference","text":"<ul> <li>fastapi_integration</li> </ul>"},{"location":"integrations/flask/","title":"Flask","text":"<p>Dependency injection for Flask is available in the<code>wireup.integration.flask_integration</code> module.</p> <p>Features:</p> <ul> <li>Automatically decorate Flask views and blueprints where the container is being used.<ul> <li>Eliminates the need for <code>@container.autowire</code> in views.</li> <li>Views without container references will not be decorated.</li> </ul> </li> <li>Expose Flask configuration in the container's parameters.</li> </ul>"},{"location":"integrations/flask/#examples","title":"Examples","text":"<pre><code>app = Flask(__name__)\napp.config[\"FOO\"] = \"bar\"\n\n@app.get(\"/random\")\ndef get_random(random: RandomService):\n    return {\"lucky_number\": random.get_random()}\n\n@app.get(\"/env\")\ndef get_environment(\n    is_debug: Annotated[bool, Inject(param=\"DEBUG\")], \n    foo: Annotated[str, Inject(param=\"FOO\")]\n):\n    return {\"debug\": is_debug, \"foo\": foo}\n\n\nif __name__ == '__main__':\n    # Initialize the integration.\n    # Must be called after views and configuration have been added.\n    # Pass to service_modules a list of top-level modules where your services reside.\n    wireup_init_flask_integration(app, service_modules=[services])\n    app.run()\n</code></pre>"},{"location":"integrations/flask/#api-reference","title":"Api Reference","text":"<ul> <li>flask_integration</li> <li>ParameterEnum</li> </ul>"}]}