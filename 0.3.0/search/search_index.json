{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"WireUp","text":"<p>Dependency injection library designed to provide a powerful and flexible way to manage and inject dependencies making it easier to develop, test, and maintain Python codebases.</p>"},{"location":"#key-features","title":"Key features","text":"Dependency Injection                  Effortlessly inject dependencies into your views, classes or functions using a clean and intuitive syntax.                    Configuration Management                  Manage and inject application configuration values supporting parameter interpolation and referencing.                    Multiple Containers                  Use the provided container or instantiate and use multiple ones depending on your project's needs.                    Interfaces / Abstract classes                  Define abstract types and have the container automatically inject the implementation.                    Lazy loading                  Dependencies injected by the library are lazily loaded and will be only initialized on first use.                    Singletons                  Dependencies are initialized only once and all references to it will reuse the same instance.                   Factory pattern                  Defer instantiation to specialized factories for full control over object creation when necessary.                    Framework Agnostic                  Seamlessly integrate with popular web frameworks like Django, Flask and FastAPI         to simplify dependency management."},{"location":"#license","title":"License","text":"<p>This project is licensed under the terms of the MIT license.</p>"},{"location":"annotations/","title":"Annotations","text":"<p>WireUp relies on various kind of type annotations or hints to be able to autowire dependencies. When it is not possible to automatically locate a given dependency the argument must be annotated with additional metadata.</p>"},{"location":"annotations/#when-do-you-need-to-provide-annotations","title":"When do you need to provide annotations.","text":"<p>Not needed when injecting:</p> <ul> <li>Services</li> <li>Injecting an interface which has only one implementing service</li> </ul> <p>Annotations required when injecting:</p> <ul> <li>Parameters</li> <li>Parameter expressions</li> <li>Injecting an interface which has multiple implementing services.</li> </ul>"},{"location":"annotations/#annotation-types","title":"Annotation types","text":"<p>Wireup supports two types of annotations. Using Python's <code>Annotated</code> or by using default values.</p>"},{"location":"annotations/#annotated","title":"Annotated","text":"<p>This is the preferred method for Python 3.9+ and moving forward. It is also recommended to backport this using <code>typing_extensions</code> for Python 3.8.</p> <pre><code>@container.autowire\ndef target(\n    env: Annotated[str, Wire(param=\"env_name\")],\n    logs_cache_dir: Annotated[str, Wire(expr=\"${cache_dir}/logs\")]\n):\n    ...\n</code></pre>"},{"location":"annotations/#default-values","title":"Default values","text":"<p>This relies on the use of default values to inject parameters. Anything that can be passed to <code>Annotated</code> may also be used here.</p> <pre><code>@container.autowire\ndef target(\n    env: str = wire(param=\"env_name\"), \n    logs_cache_dir: str = wire(expr=\"${cache_dir}/logs\")\n):\n    ...\n</code></pre>"},{"location":"demo_app/","title":"Demo application","text":"<p>Check out maldoinc/wireup-demo  for a demo Flask application using WireUp.</p> <p>It shows creation, injection and testing in the context of a simple \"Blog\" application.</p>"},{"location":"factory_functions/","title":"Factory functions","text":"<p>Factory functions allow the container to wire dependencies that require additional logic to create  or be able to inject objects it doesn't own.</p> <p>Typically getting the necessary dependencies is enough to construct an object. However, there are scenarios where you need to delegate the creation of an object to a special function called a  factory.</p>"},{"location":"factory_functions/#use-cases","title":"Use cases","text":"<p>Some of the use cases for factories are as follows:</p> <ul> <li>Object construction needs additional logic or configuration.</li> <li>Depending on the runtime environment or configuration, you may need to create different objects  inheriting from the same base (See: Strategy Pattern) or configure them differently. </li> <li>Gradually introduce DI into an existing project where the container should be able to inject dependencies created elsewhere.  Such as injecting the same database connection as the rest of the application.</li> <li>Eliminate services which have only one method that returns the same object and instead inject the object directly.<ul> <li>Register the result of a service's method as its own service. Instead of calling <code>db_service.get_db()</code> every time,   inject the session directly.</li> </ul> </li> </ul>"},{"location":"factory_functions/#usage","title":"Usage","text":"<p>In order for the container to inject these dependencies you must register the factory function. You can do this by using the <code>@container.register</code> decorator or by calling <code>container.register(fn)</code> directly.</p> <p>When the container needs to inject a dependency it checks known factories to see if any of them can create it.</p> <p>Info</p> <p>The return type of the function tells the container what type of dependency it can create.</p> <p>Warning</p> <p>Factories can only depend on objects known by the container!</p>"},{"location":"factory_functions/#links","title":"Links","text":"<ul> <li>Introduce to an existing project</li> </ul>"},{"location":"interfaces/","title":"Working with Interfaces","text":"<p>When autowiring dependencies, you might want to inject an interface rather than  the concrete implementation directly. Since Python doesn't have built-in interfaces, you can leverage any class  that's marked as abstract within the container.</p> <p>The following code registers <code>Engine</code> as an interface. This implies that <code>Engine</code> can't be directly injected.  Instead, a dependency that implements the interface must be present and also be registered in the container.</p> <pre><code>@container.abstract\nclass Engine:\n    def do_thing(self):\n        ...\n</code></pre> <p>To autowire interfaces, you can simply register a dependency that implements the interface within the container.  When injecting, ask for the interface itself, not its concrete implementation.</p> <pre><code>@container.register\nclass CombustionEngine(Engine):\n    def do_thing(self):\n        return \"I'm a Combustion Engine\"\n\n\n@container.autowire\ndef do_engine_things(engine: Engine):\n    return engine.do_thing() # Returns \"I'm a Combustion Engine\"\n</code></pre> <p>In scenarios where there are multiple implementations of an interface, each implementation must be  associated with a qualifier.</p> <pre><code>@container.register(qualifier=\"electric\")\nclass ElectricEngine(Engine):\n    def do_thing(self):\n        return \"I'm an Electric Engine\"\n\n\n@container.register(qualifier=\"combustion\")\nclass CombustionEngine(Engine):\n    def do_thing(self):\n        return \"I'm a Combustion Engine\"\n</code></pre> <p>While injecting an interface with multiple implementing dependencies, you need to specify a qualifier to indicate  which concrete class should be resolved.</p> <pre><code>container.autowire\ndef target(\n    engine: Annotated[Engine, Wire(qualifier=\"electric\")],\n    combustion: Annotated[Engine, Wire(qualifier=\"combustion\")],\n):\n    ...\n</code></pre>"},{"location":"introduce_to_an_existing_project/","title":"Introduce to an existing project","text":"<p>It can be challenging to add DI to an existing project which doesn't yet use it. One of the issues you will run into sooner or later is being able to share resources between code which uses DI and the rest of the application  which does not. </p> <p>This is especially useful to allow the container to inject dependencies created elsewhere.</p> <p>Think of a database connection. Your application probably already has one. Instead of opening a second connection using a new database service, you can instruct the container how to get the connection either via a service or by using factory functions.</p> <p>Another case might be an existing service that is already constructed, and you want to inject.</p>"},{"location":"introduce_to_an_existing_project/#using-a-service","title":"Using a Service","text":"<p>A typical way to solve this would involve create a service with a single method  that uses existing functionality to get the desired object and simply returns it.</p> <pre><code># Example of a service acting as a factory\n@container.register\n@dataclass\nclass DbConnectionService:\n    self.conn = get_db_connection_from_somewhere()\n</code></pre> <p>Here, it is possible inject <code>DbConnectionService</code> and call <code>.conn</code> to get the connection. While this works, it's not the best way to go.</p>"},{"location":"introduce_to_an_existing_project/#using-factory-functions","title":"Using Factory functions","text":"<p>To handle this more elegantly, WireUp lets you register functions as factories.  You can do this by using the <code>@container.register</code> decorator or by calling <code>container.register(fn)</code> directly.</p> <pre><code>@container.register\ndef get_db_connection_from_somewhere() -&gt; Connection:\n    return ...\n\n# Alternatively\n\ncontainer.register(get_db_connection_from_somewhere)\n</code></pre> <p>Now it is possible to inject <code>Connection</code> just like any other dependency. </p>"},{"location":"introduce_to_an_existing_project/#links","title":"Links","text":"<ul> <li>Factory functions</li> </ul>"},{"location":"manual_configuration/","title":"Manual configuration","text":"<p>WireUp provides convenient decorators and functions for you to use and perform dependency injection. If using decorators or functions such as <code>wire</code> not appropriate for your application then manual container configuration is also possible.</p>"},{"location":"manual_configuration/#using-wireup-without-registration-decorators","title":"Using wireup without registration decorators","text":"<p>In addition to using <code>@container.register</code> to register each dependency, automatic registration is also possible by using the <code>container.regiter_all_in_module(module, pattern = \"*\")</code> method.</p> <p>Module represents the top level module containing all your dependencies, optionally a <code>fnmatch</code> pattern can be specified to only register classes that match the pattern. This is the equivalent of using <code>@container.register</code> on each.</p> <pre><code>container.register_all_in_module(app.service, \"*Service\")\n</code></pre>"},{"location":"manual_configuration/#interfaces","title":"Interfaces","text":"<p>Even though It's not possible to automatically register abstract types and implementation using qualifiers.  Manual registration is still possible.</p> <pre><code>container.abstract(FooBase)\ncontainer.register(FooBar, qualifier=\"bar\")\ncontainer.register(FooBaz, qualifier=\"baz\")\n</code></pre>"},{"location":"manual_configuration/#manually-wiring-parameters","title":"Manually wiring parameters","text":"<p>Given that parameters can't be resolved from type annotations alone, they must be annotated.</p> <p>To achieve the same outcome without relying on annotations, you can use the container's  initialization context. This allows you to manually provide data that the library would  otherwise gather from the decorators or annotations.</p> <pre><code>container.register_all_in_module(app.services, \"*Service\")\n\n# Register parameters individually using add_param\ncontainer.initialization_context.add_param(\n    klass=DbService,\n    argument_name=\"connection_str\",\n    parameter_ref=\"connection_str\",\n)\ncontainer.initialization_context.add_param(\n    klass=DbService,\n    argument_name=\"connection_str\",\n    parameter_ref=TemplatedString(\"${cache_dir}/${auth_user}/db\"),\n)\n\n# Alternatively, you can update the context in bulk using a dictionary.\n# When using interpolated strings, make sure you wrap the string with TemplatedString.\ncontainer.initialization_context.update(\n    DbService,\n    {\n        \"connection_str\": \"connection_str\",\n        \"cache_dir\": TemplatedString(\"${cache_dir}/${USER}/db\"),\n    },\n)\n</code></pre> <p>Configuration can also be stored in JSON or YAML documents that can be read and used to update the container accordingly.</p>"},{"location":"multiple_containers/","title":"Multiple containers","text":"<p>As each container has its own state and does not modify the underlying classes, use of multiple containers is possible. A few things to keep in mind when using multiple containers.</p> <ul> <li>The default <code>wireup.container</code> is simply an instance just like any other.</li> <li>If a dependency belongs to multiple containers you can use decorators on them, but it is preferable you manage register dependencies without the decorators.</li> <li>To wire parameters use initialization context or the <code>wire</code> method. The <code>wire</code> method is not bound to any single container but merely provides hints as to what should be injected. These hints can be read by any container when calling autowire.</li> <li>Use of <code>@autowire</code> decorator with multiple containers is unsupported. To bind parameters and dependencies to a method call <code>instance.autowire(fn)()</code>. The autowire method will return a function where all the arguments that the container knows about are passed.</li> </ul>"},{"location":"parameters/","title":"Parameters","text":"<p>In addition to service objects, the container also holds configuration, called parameters.</p> <p>Parameters are stored as a flat key-value store. They are able to retrieved at a later time by  services when being constructed. They serve as configuration for services.  Think of a database url or environment name.</p>"},{"location":"parameters/#management","title":"Management","text":"<p>Parameters are put in the container using its <code>params</code> property and are referenced by their name. It is possible to add items by calling the <code>.put(name, value)</code> method, or in bulk or by calling <code>.update(dict)</code>  using a dictionary of name-value pairs.</p> <p>To retrieve a parameter by name directly from the container you can call <code>container.params.get(name)</code>.</p> <p>Note</p> <p>Although the value of the parameters can be anything, they cannot depend on anything else. As such, autowiring services or other parameters on them is not possible.</p>"},{"location":"parameters/#injection","title":"Injection","text":"<p>Contrary to services, it is not possible to autowire a parameter solely by its type. To enable autowiring you must annotate the function parameter with the parameter name or expression being injected.</p>"},{"location":"parameters/#by-name","title":"By name","text":"<p>To inject a parameter by name simply call <code>wire(param=\"param_name\")</code>.</p> <pre><code>@container.autowire\ndef do_something_cool(cache_dir: Annotated[str, Wire(param=\"cache_dir\")]) -&gt; None:\n    ...\n</code></pre>"},{"location":"parameters/#parameter-expressions","title":"Parameter expressions","text":"<p>It is possible to interpolate parameters using a special syntax. This will enable you to retrieve several parameters at once and concatenate their values together or simply format the value of a single parameter.</p> <pre><code>@container.autowire\ndef do_something_cool(logs_cache_dir: Annotated[str, Wire(expr=\"${cache_dir}/${env}/logs\")]) -&gt; None:\n    ...\n</code></pre>"},{"location":"parameters/#parameter-enums","title":"Parameter enums","text":"<p>Parameter enums represent an alternative for those who do not want to rely on strings and want to have a typed way to refer to parameter names. You can achieve this by creating a new type inheriting from <code>ParameterEnum</code>.</p> <p><pre><code>class AppParameters(ParameterEnum):\n    cache_dir = \"cache_dir\"\n    # ... other params follow\n</code></pre> Using this we can use the enum member whenever we want to refer to a particular parameter. The main feature of the enum is a <code>wire()</code> method which is syntactic sugar for <code>wire(param=AppParameters.cache_dir.value)</code></p> <pre><code>container.params.put(AppParameters.cache_dir.value, \"/var/cache\")\n\n@container.autowire\ndef do_something_cool(cache_dir: str = AppParameters.cache_dir.wire()) -&gt; None:\n    ...\n</code></pre>"},{"location":"quickstart/","title":"Quickstart","text":"<p>Demonstration of a simple application with two services (classes that provide functionality) and parameters (app configuration) showing automatic dependency resolution and injection (autowiring)  for services and a simple web view called \"greet\".</p> <p>1. Register dependencies</p> <pre><code>from wireup import container\n\n# Parameters serve as configuration for services. \n# Think of a database url or environment name.\ncontainer.params.update({\n    \"db.connection_str\": os.environ.get(\"DATABASE_URL\") # (1)!\n    \"cache_dir\": gettempdir(),\n    \"env\": os.environ.get(\"ENV\", \"dev\")\n})\n\n\n# Constructor injection is supported for regular classes as well as dataclasses\n@container.register # (2)!\nclass DbService:\n   # Inject a parameter by name\n   connection_str: Annotated[str, Wire(param=\"db.connection_str\")],\n   # Or by interpolating multiple parameters into a string\n   cache_dir: Annotated[str, Wire(expr=\"${cache_dir}/${env}/db\")],\n\n@container.register\n@dataclass\nclass UserRepository:\n    db: DbService  # Services may also depend on other dependencies. (3)!\n</code></pre> <ol> <li>Even though there are dots in parameter names, that not imply any nested structure. The parameter bag is a    flat key-value store.</li> <li>Decorators do not modify the classes in any way and only serve to collect metadata. This behavior can make    testing a lot simpler as you can still instantiate this like a regular class in your tests.</li> <li>Use type hints to tell the library what object to inject.</li> </ol> <p>2. Inject</p> <pre><code>@app.route(\"/greet/&lt;str:name&gt;\")\n@container.autowire  # (1)!\n# Classes are automatically injected based on annotated type. \n# Parameters will be located based on their annotation metadata.\n# Unknown arguments will not be processed.\ndef greet(\n    name: str, \n    user_repository: UserRepository,  \n    env: Annotated[str, Wire(param=\"env\")]\n): \n    ...\n</code></pre> <ol> <li>Decorate all methods where the library must perform injection.     We know that this will be used in conjunction with many other libraries, so WireUp will not throw on unknown    parameters in order to let other decorators to do their job.</li> </ol> <p>Installation</p> <pre><code># Install using poetry:\npoetry add wireup\n\n# Install using pip:\npip install wireup\n</code></pre>"},{"location":"services/","title":"Services","text":"<p>Services are classes known by the container that provide functionality.</p> <p>Contrary to static utility classes or methods they usually rely on other services or parameters to provide a part of their functionality.</p> <p>Examples refer to the default container provided by the library in <code>wireup.container</code> but any other instance can be used in its place. The process is meant to be simple and the short Quickstart page shows by example and already contains all the key concepts you need to know about.</p>"},{"location":"services/#registration","title":"Registration","text":"<p>Declaration and usage of services is designed to be as simple as possible. They may live anywhere in the application but must be registered with the container.</p> <p>To register a class as a service the following options are available.</p> <ul> <li>Decorate the class using the <code>container.register</code>.</li> <li>Call <code>container.register(YourService)</code> directly on the service.</li> <li>Use <code>container.register_all_in_module</code>.   (See: Manual Configuration)</li> </ul>"},{"location":"services/#injection","title":"Injection","text":"<p>The container will perform autowiring based on the type hints given. No manual configuration is needed to inject services.</p> <p>To perform autowiring the method to be autowired must be decorated with <code>@container.autowire</code>. Given the nature of Python decorators it is also possible to simply call it as a regular function which will return a callable with arguments the containers knows about already bound.</p>"},{"location":"services/#lifetime","title":"Lifetime","text":"<p>Services live in the container and their references are kept in it. As such, it should be avoided that they contain data about any particular request as injected parameters are cached on their first autowire call.</p> <p>The container should be configured once, at application startup and used throughout its execution. Even though you can modify the container or parameters at runtime it is generally advised not to.</p>"},{"location":"class/dependency_container/","title":"DependencyContainer","text":"<p>Dependency Injection and Service Locator container registry.</p> <p>This contains all the necessary information to initialize registered classes. Objects instantiated by the container are lazily loaded and initialized only on first use.</p> <p>Provides the following decorators: <code>register</code>, <code>abstract</code> and <code>autowire</code>. Use register on factory functions and concrete classes which are to be injected from the container. Abstract classes are to be used as interfaces and will not be injected directly, rather concrete classes which implement them will be injected instead.</p> <p>Use the <code>autowire</code> decorator on methods where dependency injection must be performed. Services will be injected automatically where possible. Parameters will have to be annotated as they cannot be located from type alone.</p> <p>Note</p> <p>Fastapi users MUST use <code>= .wire()</code> method without arguments when injecting dependencies.</p>"},{"location":"class/dependency_container/#wireup.ioc.dependency_container.DependencyContainer-functions","title":"Functions","text":""},{"location":"class/dependency_container/#wireup.ioc.dependency_container.DependencyContainer.__init__","title":"<code>__init__(parameter_bag)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>parameter_bag</code> <code>ParameterBag</code> <p>ParameterBag instance holding parameter information.</p> required"},{"location":"class/dependency_container/#wireup.ioc.dependency_container.DependencyContainer.abstract","title":"<code>abstract(klass)</code>","text":"<p>Register a type as an interface.</p> <p>This type cannot be initialized directly and one of the components implementing this will be injected instead.</p>"},{"location":"class/dependency_container/#wireup.ioc.dependency_container.DependencyContainer.autowire","title":"<code>autowire(fn)</code>","text":"<p>Automatically inject resources from the container to the decorated methods.</p> <p>Any arguments which the container does not know about will be ignored so that another decorator or framework can supply their values. This decorator can be used on both async and blocking methods.</p> <ul> <li>Classes will be automatically injected.</li> <li>Parameters need to be annotated in order for container to be able to resolve them</li> <li>When injecting an interface for which there are multiple implementations you need to supply a qualifier   using annotations.</li> </ul>"},{"location":"class/dependency_container/#wireup.ioc.dependency_container.DependencyContainer.get","title":"<code>get(klass, qualifier=None)</code>","text":"<p>Get an instance of the requested type.</p> <p>Use this to locate services by their type but strongly prefer using injection instead.</p> <p>Parameters:</p> Name Type Description Default <code>qualifier</code> <code>ContainerProxyQualifierValue</code> <p>Qualifier for the class if it was registered with one.</p> <code>None</code> <code>klass</code> <code>type[__T]</code> <p>Class of the dependency already registered in the container.</p> required <p>Returns:</p> Type Description <code>__T</code> <p>An instance of the requested object. Always returns an existing instance when one is available.</p>"},{"location":"class/dependency_container/#wireup.ioc.dependency_container.DependencyContainer.register","title":"<code>register(obj=None, *, qualifier=None)</code>","text":"<p>Register a dependency in the container.</p> <p>Use <code>@register</code> without parameters on a class or with a single parameter <code>@register(qualifier=name)</code> to register this with a given name when there are multiple implementations of the interface this implements.</p> <p>Use <code>@register</code> on a function to register that function as a factory method which produces an object that matches its return type.</p> <p>The container stores all necessary metadata for this class and the underlying class remains unmodified.</p>"},{"location":"class/dependency_container/#wireup.ioc.dependency_container.DependencyContainer.register_all_in_module","title":"<code>register_all_in_module(module, pattern='*')</code>","text":"<p>Register all modules inside a given module.</p> <p>Useful when your components reside in one place, and you'd like to avoid having to <code>@register</code> each of them. Alternatively this can be used if you want to use the library without having to rely on decorators.</p> <p>See Also: <code>self.initialization_context</code> to wire parameters without having to use a default value.</p> <p>Parameters:</p> Name Type Description Default <code>module</code> <code>ModuleType</code> <p>The package name to recursively search for classes.</p> required <code>pattern</code> <code>str</code> <p>A pattern that will be fed to fnmatch to determine if a class will be registered or not.</p> <code>'*'</code>"},{"location":"class/dependency_initialization_context/","title":"DependencyInitializationContext","text":"<p>Contains information about initializing a particular dependency.</p> <p>Use in cases where you want to avoid using <code>.wire</code> calls for parameter injection.</p>"},{"location":"class/dependency_initialization_context/#wireup.ioc.container_util.DependencyInitializationContext-functions","title":"Functions","text":""},{"location":"class/dependency_initialization_context/#wireup.ioc.container_util.DependencyInitializationContext.__init__","title":"<code>__init__()</code>","text":"<p>Initialize an empty context.</p>"},{"location":"class/dependency_initialization_context/#wireup.ioc.container_util.DependencyInitializationContext.add_param","title":"<code>add_param(klass, argument_name, parameter_ref)</code>","text":"<p>Add a parameter to the context.</p> <p>Parameters:</p> Name Type Description Default <code>klass</code> <code>type</code> <p>The class type which this parameter belongs to</p> required <code>argument_name</code> <code>str</code> <p>The name of the parameter in the klass initializer.</p> required <code>parameter_ref</code> <code>ParameterReference</code> <p>A reference to a parameter in the bag.</p> required"},{"location":"class/dependency_initialization_context/#wireup.ioc.container_util.DependencyInitializationContext.update","title":"<code>update(klass, params)</code>","text":"<p>Merge the context information for a particular type.</p> <p>Updates the context with the values from the new dictionary. Parameters from the argument will overwrite any existing ones with the same name. Behaves the same as the standard dict.update. Parameter values will be wrapped in ParameterWrapper.</p> <p>Parameters:</p> Name Type Description Default <code>klass</code> <code>type</code> <p>The class type to be updated</p> required <code>params</code> <code>dict[str, ParameterReference]</code> <p>A dictionary of parameter references. Keys map to the parameter name and values contain references to parameters in the bag.</p> required"},{"location":"class/parameter_bag/","title":"ParameterBag","text":"<p>Parameter flat key-value store for use with a container.</p> <p>Allows storing and retrieving of parameters in the bag. Templated strings can be used to interpolate a string referencing parameters.</p>"},{"location":"class/parameter_bag/#wireup.ioc.parameter.ParameterBag-functions","title":"Functions","text":""},{"location":"class/parameter_bag/#wireup.ioc.parameter.ParameterBag.__init__","title":"<code>__init__()</code>","text":"<p>Initialize an empty ParameterBag.</p> <p>ParameterBag holds a flat key-value store of parameter values. __bag: A dictionary to store parameter values. __cache: A cache for interpolated values. __param_cache: A dictionary to keep track of which cache entries involve each parameter.</p>"},{"location":"class/parameter_bag/#wireup.ioc.parameter.ParameterBag.get","title":"<code>get(param)</code>","text":"<p>Get the value of a parameter.</p> <p>If the parameter is templated, interpolate it first by replacing placeholders with parameter values.</p> <p>Parameters:</p> Name Type Description Default <code>param</code> <code>ParameterReference</code> <p>The parameter to retrieve.</p> required <p>Returns:</p> Type Description <code>Any</code> <p>The parameter's value.</p>"},{"location":"class/parameter_bag/#wireup.ioc.parameter.ParameterBag.get_all","title":"<code>get_all()</code>","text":"<p>Get all parameters stored in the bag.</p> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>A dictionary containing all parameter names and their values.</p>"},{"location":"class/parameter_bag/#wireup.ioc.parameter.ParameterBag.put","title":"<code>put(name, val)</code>","text":"<p>Put a parameter value into the bag. This overwrites any previous values.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the parameter.</p> required <code>val</code> <code>Any</code> <p>The value of the parameter.</p> required"},{"location":"class/parameter_bag/#wireup.ioc.parameter.ParameterBag.update","title":"<code>update(new_params)</code>","text":"<p>Update the bag with new set of parameters.</p> <p>Parameters from new_params will overwrite any existing parameters set with the same name.</p> <p>Parameters:</p> Name Type Description Default <code>new_params</code> <code>dict[str, Any]</code> <p>A dictionary of parameter names and their updated values.</p> required"},{"location":"class/parameter_enum/","title":"ParameterEnum","text":"<p>             Bases: <code>Enum</code></p> <p>Enum with a <code>.wire</code> method allowing easy injection of members.</p> <p>Allows you to add application parameters as enum members and their names as values. When you need to inject a parameter instead of referencing it by name you can annotate the parameter with the wire function call or set that as the default value.</p> <p>This will inject a parameter by name and won't work with expressions.</p>"},{"location":"class/parameter_enum/#wireup.ParameterEnum-functions","title":"Functions","text":""},{"location":"class/parameter_enum/#wireup.ParameterEnum.wire","title":"<code>wire()</code>","text":"<p>Inject the parameter this enumeration member represents.</p> <p>Equivalent of <code>wire(param=EnumParam.enum_member.value)</code></p>"},{"location":"class/wireup/","title":"wireup","text":""},{"location":"class/wireup/#wireup.container","title":"<code>wireup.container = DependencyContainer(ParameterBag())</code>  <code>module-attribute</code>","text":"<p>Singleton DI container instance.</p> <p>Use when your application only needs one container.</p>"},{"location":"class/wireup/#wireup.wire","title":"<code>wireup.wire(*, param=None, expr=None, qualifier=None)</code>","text":"<p>Inject resources from the container to autowired method arguments.</p> <p>Arguments are exclusive and only one of them must be used at any time.</p> <p>Note</p> <p>Methods MUST be still decorated with autowire for this to work.</p> <p>Parameters:</p> Name Type Description Default <code>param</code> <code>str | None</code> <p>Inject a given parameter by name.</p> <code>None</code> <code>expr</code> <code>str | None</code> <p>Inject a string value using a templated string. Parameters inside <code>${}</code> will be replaced with their corresponding value.</p> <code>None</code> <code>qualifier</code> <code>ContainerProxyQualifierValue</code> <p>Qualify which implementation to bind when there are multiple components implementing an interface that is registered in the container via <code>@abstract</code>.</p> <code>None</code>"}]}