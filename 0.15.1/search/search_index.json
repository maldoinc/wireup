{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Wireup","text":"<p>Performant, concise, and easy-to-use dependency injection container for Python 3.8+.</p> <p> </p>"},{"location":"#key-features","title":"Key features","text":"<ul> <li> <p> Dependency Injection</p> <p>Inject services and configuration using a clean and intuitive syntax.</p> <p>Getting Started</p> </li> <li> <p> Autoconfiguration</p> <p>Automatically inject dependencies based on their types without additional configuration for the most common use cases.</p> <p> Learn more</p> </li> <li> <p> Interfaces / Abstract classes</p> <p>Define abstract types and have the container automatically inject the implementation.</p> <p> Learn more</p> </li> <li> <p> Factory pattern</p> <p>Defer instantiation to specialized factories for full control over object creation when necessary.</p> <p> Learn more</p> </li> <li> <p> Singletons/Transient dependencies</p> <p>Declare dependencies as transient or singletons which tells the container whether to inject a fresh copy or reuse existing instances.</p> <p> Learn more</p> </li> <li> <p> Declarative/Imperative</p> <p>Configure services through annotations in a fully declarative style or build everything by code for full control over instantiation.</p> <p> Learn more</p> </li> </ul>"},{"location":"#framework-integrations","title":"Framework integrations","text":"<p>Simplified use with the following frameworks.</p> <ul> <li> Django</li> <li> FastAPI</li> <li> Flask</li> </ul>"},{"location":"#license","title":"License","text":"<p>This project is licensed under the terms of the MIT license.</p>"},{"location":"annotations/","title":"Annotations","text":"<p>Autowiring relies on annotations or hints to be able to inject dependencies. When it is not possible to automatically locate a given dependency, it must be annotated with additional metadata.</p>"},{"location":"annotations/#when-do-you-need-to-provide-annotations","title":"When do you need to provide annotations.","text":"Injecting Annotations required? What is required Services No Interface with only one implementation No Default implementation of an interface No Interface with multiple implementations Yes Qualifier Parameters Yes Parameter name Parameter expressions Yes Expression"},{"location":"annotations/#annotation-types","title":"Annotation types","text":"<p>Wireup supports two types of annotations. Using Python's <code>Annotated</code> and default values.</p>"},{"location":"annotations/#annotated","title":"Annotated","text":"<p>This is the preferred method for Python 3.9+ and moving forward. It is also recommended to backport this using <code>typing_extensions</code> for Python 3.8.</p> <pre><code>@container.autowire\ndef target(\n    env: Annotated[str, Inject(param=\"env_name\")],\n    logs_cache_dir: Annotated[str, Inject(expr=\"${cache_dir}/logs\")],\n):\n    ...\n</code></pre>"},{"location":"annotations/#default-values-deprecated","title":"Default values (deprecated)","text":"<p>This relies on the use of default values to inject parameters. Anything that can be passed to <code>Annotated</code> may also be used here.</p> <pre><code>@container.autowire\ndef target(\n    env: str = Inject(param=\"env_name\"), \n    logs_cache_dir: str = Inject(expr=\"${cache_dir}/logs\")\n):\n    ...\n</code></pre>"},{"location":"annotations/#explicit-injection-annotation","title":"Explicit injection annotation","text":"<p>Even though annotating services is optional, you CAN still annotate them to be explicit about what will  be injected. This also has the benefit of raising when the service does not exist instead of silently skipping this parameter.</p> <pre><code>@container.autowire\ndef target(random_service: Annotated[RandomService, Inject()]):\n    ...\n</code></pre>"},{"location":"configuration/","title":"Configuration","text":"<p>Wireup configuration can be injected through annotations or programmatically using factory functions.  You can also mix and match the two as necessary.</p> <p>Annotations: This declarative approach uses configuration metadata provided by decorators and annotations to define services and dependencies between them. It allows you to declare the final state and let the container handle the rest.</p> <p>This generally results in less boilerplate code compared to a programmatic approach and is how many popular frameworks operate.</p> <p>\ud83c\udfed Programmatic: With a programmatic approach, you have full control over how services are created and can keep service definitions free of container references if this is important to you.</p> <p>This approach results in more code as you will need to write these factories and construct services yourself.</p> <p>This will also be somewhat familiar if you're coming from FastAPI, with the major difference being that you won't need to <code>Depends(get_service_from_function)</code> everywhere.</p> <p>Factories can request dependencies as usual and may use annotations for configuration.</p>"},{"location":"configuration/#annotation-based-configuration","title":"@ Annotation-based configuration","text":"<p>In addition to service objects, the container also holds configuration, called parameters that can be used to configure services.</p> <p>Warning</p> <p>Parameters represent application configuration.  They are not intended to pass values around or to be used as a global session object.</p> <p>Store only app configuration such as environment name, database url, mailer url etc.</p>"},{"location":"configuration/#injection","title":"Injection","text":""},{"location":"configuration/#by-name","title":"By name","text":"<p>To inject a parameter by name, annotate the type with <code>Inject(param=\"param_name\")</code>.</p> <pre><code>@service\nclass GithubClient:\n    def __init__(self, api_key: Annotated[str, Inject(param=\"gh_api_key\")]) -&gt; None:\n        ...\n</code></pre>"},{"location":"configuration/#parameter-expressions","title":"Parameter expressions","text":"<p>It is possible to interpolate parameters using a special syntax. This will enable you to retrieve several parameters at once and concatenate their values together.</p> <p>Note: As the result is a string, non-string parameters will be converted using <code>str()</code>.</p> <pre><code>def target(logs_dir: Annotated[str, Inject(expr=\"${cache_dir}/${env}/logs\")]) -&gt; None:\n    ...\n</code></pre>"},{"location":"configuration/#class-based-configuration","title":"\ud83c\udfed Class-based configuration","text":"<p>While Wireup provides its own configuration mechanism in the form of parameters, it is entirely optional. If you prefer using typed classes for configuration, they are also supported via factories.</p> <p>The main idea is to register your settings as a service and inject it into factories like a regular dependency.</p>"},{"location":"configuration/#configuration","title":"Configuration","text":"<p>Assume your configuration is defined in an class such as this. Examples use pydantic-settings but any class will work exactly the same.</p> settings.py<pre><code>from pydantic_settings import BaseSettings\nfrom pydantic import Field, PostgresDsn\n\n\nclass Settings(BaseSettings):\n    gh_api_key: str = Field(alias=\"gh_api_key\")  \n    pg_dsn: PostgresDsn = Field(alias=\"pg_dsn\")  \n</code></pre>"},{"location":"configuration/#services","title":"Services","text":"<p>Next step would be to define a few services, such as <code>GithubClient</code> and a <code>DatabaseConnection</code>.</p> services/github_client.py<pre><code>@dataclass\nclass GithubClient:\n    api_key: str\n</code></pre> services/db.py<pre><code>@dataclass\nclass DatabaseConnection:\n    dsn: str\n</code></pre>"},{"location":"configuration/#factories","title":"Factories","text":"<p>To wire everything together we can use a few factories.</p> factories.py<pre><code>from wireup import service, container\n\n@service\ndef settings_factory() -&gt; Settings:\n    return Settings(...)\n\n\n# Now that settings is registered with the container \n# it is possible to inject it like a regular service.\n@service\ndef github_client_factory(settings: Settings) -&gt; GithubClient:\n    return GithubClient(api_key=settings.gh_api_key)\n\n\n@service\ndef database_connection_factory(settings: Settings) -&gt; DatabaseConnection:\n    return DatabaseConnection(dsn=str(settings.pg_dsn))\n</code></pre>"},{"location":"demo_app/","title":"Demo application","text":"<p>Check out maldoinc/wireup-demo  for a demo Flask application using Wireup.</p> <p>It shows creation, injection and testing in the context of a simple \"Blog\" application.</p>"},{"location":"factory_functions/","title":"Factory functions","text":"<p>Typically getting the necessary dependencies is enough to construct an object. However, there are scenarios where you need to delegate service creation to a special function called a  factory.</p>"},{"location":"factory_functions/#use-cases","title":"Use cases","text":"<ul> <li>Object construction needs additional logic or configuration.</li> <li>Depending on the runtime environment or configuration, you may need to create different objects  inheriting from the same base (See: Strategy Pattern) or configure them differently. </li> <li>Inject a model/dto which represents the result of an action, such as the current authenticated user.</li> <li>Inject a class from another library where it's not possible to add annotations.</li> <li>Inject strings, ints and other built-in types.</li> </ul>"},{"location":"factory_functions/#usage","title":"Usage","text":"<p>In order for the container to inject these dependencies, you must register the factory function by using the <code>@service</code> decorator.</p> <p>When the container needs to inject a dependency, it checks known factories to see if any of them can create it.</p> <p>Good to know</p> <p>Return type annotation of the factory is required as it denotes what will be built.</p>"},{"location":"factory_functions/#examples","title":"Examples","text":""},{"location":"factory_functions/#use-a-generator-function-yield-instead-of-return","title":"Use a generator function (yield instead of return)","text":"<p>Use this when your service needs to perform cleanup.</p> <pre><code>@service\ndef db_session_factory() -&gt; Iterator[Session]:\n    db = Session()\n    try:\n        yield db\n    finally:\n        db.close()\n</code></pre> <pre><code>@service\ndef db_session_factory() -&gt; Iterator[Session]:\n    with contextlib.closing(Session()) as db:\n        yield db\n</code></pre> <p>Async generators are also supported. <pre><code>async def client_session_factory() -&gt; ClientSession:\n    async with ClientSession() as sess:\n        yield sess\n</code></pre></p> <p>Make sure to close the container at the end. Use <code>container.close()</code> or <code>container.aclose()</code> if you use async generators. For transient dependencies, the container will automatically perform cleanup after the injected method finishes executing.</p>"},{"location":"factory_functions/#inject-a-model","title":"Inject a model","text":"<p>Assume in the context of an application a class <code>User</code> exists and represents a user of the system. We can use a factory to inject a user model that represents the current authenticated user.</p> <pre><code>from wireup import service, ServiceLifetime\n\n# You may want to create a new type to make a distinction on the type of user this is.\nAuthenticatedUser = NewType(\"AuthenticatedUser\", User)\n\n\n@service(lifetime=ServiceLifetime.TRANSIENT)\ndef get_current_user(auth_service: AuthService) -&gt; AuthenticatedUser:\n    return AuthenticatedUser(auth_service.get_current_user())\n\n\n# Now it is possible to inject the authenticated user directly wherever it is necessary.\n@container.autowire\ndef get_user_logs(user: AuthenticatedUser):\n    ...\n</code></pre>"},{"location":"factory_functions/#implement-strategy-pattern","title":"Implement strategy pattern","text":"<p>Assume a base class <code>Notifier</code> with implementations that define how the notification is sent (IMAP, POP, WebHooks, etc.) Given a user it is possible to instantiate the correct type of notifier based on user preferences.</p> <pre><code>from wireup import service, ServiceLifetime\n\n\n@service(lifetime=ServiceLifetime.TRANSIENT)\ndef get_user_notifier(\n    user: AuthenticatedUser, \n    slack_notifier: SlackNotifier, \n    email_mailer: EmailNotifier\n) -&gt; Notifier:\n    notifier = ...  # get notifier type from preferences.\n\n    return notifier\n</code></pre> <p>When injecting <code>Notifier</code> the correct type will be injected based on the authenticated user's preferences.</p>"},{"location":"factory_functions/#inject-a-third-party-class","title":"Inject a third-party class","text":"<p>You can use factory functions to inject a class which you have not declared yourself and therefore cannot annotate.  Let's take redis client as an example. </p> @ Annotations\ud83c\udfed Programmatic <pre><code>from wireup import service\n\n\n@service\ndef redis_factory(redis_url: Annotated[str, Inject(param=\"redis_url\")]) -&gt; Redis:\n    return redis.from_url(redis_url)\n</code></pre> <pre><code>from wireup import service\n\n\n@service\ndef redis_factory(settings: Settings) -&gt; Redis:\n    return redis.from_url(settings.redis_url)\n</code></pre>"},{"location":"factory_functions/#inject-built-in-types","title":"Inject built-in types","text":"<p>If you want to inject resources which are just strings, ints, or other built-in types then you can use a factory in combination with <code>NewType</code>.</p> factories.py<pre><code>AuthenticatedUsername = NewType(\"AuthenticatedUsername\", str)\n\n@service\ndef authenticated_username_factory(auth: SomeAuthService) -&gt; AuthenticatedUsername:\n    return AuthenticatedUsername(...)\n</code></pre> <p>This can now be injected as usual by annotating the dependency with the new type.</p>"},{"location":"factory_functions/#links","title":"Links","text":"<ul> <li>Introduce to an existing project</li> </ul>"},{"location":"future_annotations/","title":"Use with __future__ annotations","text":"<p>Wireup has support for string types or <code>from __future__ import annotations</code>.  To enable this, you must install the <code>eval_type_backport</code> package, also used in Pydantic and FastAPI among others.</p> <p>Good to know</p> <ul> <li>Services/factories must be defined at the module level. Registering types declared inside functions is not supported.</li> <li>Types used by Wireup MUST NOT be moved into <code>TYPE_CHECKING</code> blocks. Doing so, makes them unavailable at runtime for inspection.</li> </ul> <p>Take the following code for example. Ruff/flake8 will suggest to move the <code>Iterator</code> and <code>Thing</code> imports into a type checking block, but doing so prevents the import from happening during runtime and as such Wireup will not be able to resolve the type.</p> <p>You should pay extra attention to this if you use the <code>TCH</code> rules from Ruff.</p> <pre><code>from collections.abc import Iterator\n\n@service\ndef thing_factory() -&gt; Iterator[Thing]:\n    yield Thing()\n\n\n@service\n@dataclass\nclass ExampleService:\n    thing: Thing\n</code></pre>"},{"location":"getting_started/","title":"Getting started","text":"<p>Wireup is a Performant, concise, and easy-to-use Dependency Injection container for Python 3.8+.</p> <p>Dependency Injection (DI) is a design pattern where objects receive their dependencies externally instead of creating them. Wireup manages the creation, injection, and lifecycle management of dependencies. It uses typing to automatically resolve dependencies where required, reducing boilerplate and supports modern Python features such as async and generators.</p> <p>It can function standalone as a DI container or service locator and also integrates with popular frameworks such as Django, FastAPI and Flask.</p>"},{"location":"getting_started/#quickstart","title":"Quickstart","text":"<p>To showcase the basics of Wireup, we will create a container able to inject the following:</p> <ul> <li>A <code>WeatherService</code> that queries a fictional weather api, needs an api key and, a <code>KeyValueStore</code> to cache request data and an async http client</li> <li><code>KeyValueStore</code> itself needs a <code>redis_url</code> denoting the server it will connect to to query/store data.</li> </ul> <p>These services will then be retrieved in a <code>/weather/forecast</code> endpoint that requires <code>WeatherService</code> to provide weather information.</p> <pre><code>graph LR\n    A --&gt; C\n    B --&gt; D\n    C --&gt; D\n    D --&gt; E\n    F --&gt; D\n\n    A[\u2699\ufe0f redis_url]\n    B[\u2699\ufe0f weather_api_key]\n    C[\ud83d\udc0d KeyValueStore]\n    D[\ud83d\udc0d WeatherService]\n    E[\ud83c\udf0e /weather/forecast]\n    F[\ud83c\udfed HttpClient]</code></pre>"},{"location":"getting_started/#1-setup","title":"1. Setup","text":"<p>Install wireup using pip or your favorite package manager.</p> <pre><code>$ pip install wireup\n</code></pre> <p>The first step is to create a container.</p> container.py<pre><code>import wireup\n\ncontainer = wireup.create_container(\n    # Parameters serve as application/service configuration.\n    parameters={\n        \"redis_url\": os.environ[\"APP_REDIS_URL\"],\n        \"weather_api_key\": os.environ[\"APP_WEATHER_API_KEY\"],\n    },\n    # Let the container know where service registrations are located.\n    service_modules=[services]\n)\n</code></pre> <p>Parameters are configuration your application needs. Such as an api key, database url, or other settings. Service modules is a list of top-level python modules containing service definitions this container needs to know about.</p> Read: Global variables <p>Using this approach means relying on global state, which ties your application to a single container instance.  This might be sufficient for you and that's okay but, if you want to avoid global state, it's better to create  the container within your application factory and provide a way to access it from the created application instance.</p> <p>With the available integrations, global state is neither necessary nor recommended.</p>"},{"location":"getting_started/#2-define-services","title":"2. Define services","text":"<p>The container uses configuration metadata from annotations and types to define services and the dependencies between them. This means that the service declaration is self-contained and does not require additional setup for most use cases.</p>"},{"location":"getting_started/#keyvaluestore","title":"\ud83d\udc0d <code>KeyValueStore</code>","text":"<p>To create <code>KeyValueStore</code>, all we need is the <code>redis_url</code> parameter. The <code>@service</code> decorator tells Wireup this is a service, and we simply need to tell the container via annotated types to fetch the value of the <code>redis_url</code> parameter for <code>dsn</code>. </p> services/key_value_store.py<pre><code>from wireup import service, Inject\nfrom typing_extensions import Annotated\n\n@service  #(1)!\nclass KeyValueStore:\n    def __init__(self, dsn: Annotated[str, Inject(param=\"redis_url\")]) -&gt; None:  #(2)!\n        self.client = redis.from_url(dsn)\n</code></pre> <ol> <li>Decorators are used to collect metadata.      This makes testing simpler, as you can still instantiate this like a regular class in your tests.</li> <li>Parameters must be annotated with the <code>Inject(param=name)</code> syntax. This tells the container which parameter to inject.</li> </ol>"},{"location":"getting_started/#weatherservice","title":"\ud83d\udc0d <code>WeatherService</code>","text":"<p>Creating <code>WeatherService</code> is also straightforward. The <code>@service</code> decorator is used to let Wireup know this is a service and we use the same syntax as above for the <code>api_key</code>. Class dependencies do not need additional annotations in this case.</p> services/weather_service.py<pre><code>@service\nclass WeatherService:\n    def __init(\n        self,\n        api_key: Annotated[str, Inject(param=\"weather_api_key\")], #(1)!\n        kv_store: KeyValueStore, #(2)!\n        client: aiohttp.ClientSession, #(2)!\n    ) -&gt; None:\n        self.api_key = api_key\n        self.kv_store = kv_store\n</code></pre> <ol> <li>Same as above, weather api key needs the parameter name for the container to inject it.</li> <li><code>KeyValueStore</code> and <code>aiohttp.ClientSession</code> can be injected only by type and requires no additional configuration.</li> </ol>"},{"location":"getting_started/#aiohttpclientsession","title":"\ud83c\udfed <code>aiohttp.ClientSession</code>","text":"<p>The http client making requests cannot be instantiated directly as we need to enter an async context manager. To accomodate such cases, Wireup allows you to use functions to create dependencies.  These can be sync/async as well as regular or generator functions if cleanup needs to take place.</p> <p>Factories can define their dependencies in the function's signature.</p> <p>Note: When using generator factories make sure to call <code>container.close</code> (or <code>container.aclose()</code> for async generators) when the application is terminating for the necessary cleanup to take place.</p> services/factories.py<pre><code>@service\nasync def make_http_client() -&gt; AsyncIterator[aiohttp.ClientSession]:\n    async with aiohttp.ClientSession() as client:\n        yield client\n</code></pre> <p>Use Wireup without annotations</p> <p>If using annotations is not suitable for your project, you can use factories as shown above to create all dependencies.</p> <p>This lets you keep service definitions devoid of Wireup references. Learn more</p>"},{"location":"getting_started/#3-use","title":"3. Use","text":"<p>Use the container as a service locator or apply it as a decorator.</p> Injection via decoratorService Locator <p>The container instance provides an <code>autowire</code> method that when applied to a function will cause the container to pass the dependencies when the function is called.</p> views/posts.py<pre><code>@app.get(\"/weather/forecast\")\n@container.autowire\nasync def get_forecast_view(weather_service: WeatherService):\n    return await weather_service.get_forecast(...)\n</code></pre> <p>Alternatively you can use the container's ability to function as a service locator. Simply call <code>.get</code> on the container instance with the type you wish to retrieve.</p> views/posts.py<pre><code>@app.get(\"/weather/forecast\")\nasync def get_forecast_view():\n    weather_service = container.get(WeatherService)\n    return await weather_service.get_forecast(...)\n</code></pre>"},{"location":"getting_started/#35-integrate","title":"3.5 Integrate","text":"<p>While Wireup is framework-agnostic, usage can be simplified when using it alongside one of the integrations. A key benefit of the integrations, is removing the need to have a global container variable and the need to decorate injection targets in the frameworks.</p> <p>Each integration also comes with additional goodies specific to that framework.</p> <ul> <li>Django</li> <li>FastAPI</li> <li>Flask</li> </ul>"},{"location":"getting_started/#4-test","title":"4. Test","text":"<p>Wireup does not patch your services, which means they can be instantiated and tested independently of the container.</p> <p>To substitute dependencies on autowired targets such as views in a web application you can override dependencies with new ones on the fly.</p> <pre><code>with container.override.service(WeatherService, new=test_weather_service):\n    response = client.get(\"/weather/forecast\")\n</code></pre> <p>Requests to inject <code>WeatherService</code> during the lifetime of the context manager  will result in <code>test_weather_service</code> being injected instead.</p>"},{"location":"getting_started/#conclusion","title":"Conclusion","text":"<p>This concludes the \"Getting Started\" walkthrough, covering the most common dependency injection use cases.</p> <p>Info</p> <ul> <li>The <code>@container.autowire</code> decorator is not needed for services.</li> <li>When using the provided integrations, decorating views with <code>@container.autowire</code> is no longer required.</li> <li>Wireup can perform injection on both sync and async targets.</li> <li>Every container you create is separate from the rest and has its own state.</li> </ul>"},{"location":"getting_started/#next-steps","title":"Next Steps","text":"<ul> <li>Services</li> <li>Configuration</li> <li>Factory functions</li> </ul>"},{"location":"interfaces/","title":"Interfaces","text":"<p>Sometimes you might want to inject an interface rather than the concrete implementation directly.  Since Python doesn't have built-in interfaces, you can use any class marked as abstract.</p> <p>This method makes testing easier as you can create dummy implementations of these services in your tests in order to control their behavior.</p>"},{"location":"interfaces/#example","title":"Example","text":"<p>The following code registers <code>Engine</code> as an interface. This implies that <code>Engine</code> can't be directly injected.  Instead, a dependency that implements the interface must also be registered in the container.</p> <p>To use interfaces, register a dependency that directly inherits the interface  with the container. When injecting, ask for the interface itself, not the implementations.</p> <pre><code>from wireup import abstract, container, service\n\n\n@abstract\nclass Engine(abc.ABC):\n    @abc.abstractmethod\n    def get_type(self) -&gt; EngineType:\n        raise NotImplementedError\n\n\n@service\nclass CombustionEngine(Engine):\n    @override\n    def get_type(self) -&gt; EngineType:\n        return EngineType.COMBUSTION\n\n\n@container.autowire\ndef target(engine: Engine):\n    engine_type = engine.get_type()  # Returns EngineType.COMBUSTION\n    ...\n</code></pre>"},{"location":"interfaces/#multiple-implementations","title":"Multiple implementations","text":"<p>If an interface has multiple implementations, associate each of them with a qualifier. This is essentially a tag used to differentiate between implementations.</p> <pre><code>@service(qualifier=\"electric\")\nclass ElectricEngine(Engine):\n    def get_type(self):\n        return EngineType.ELECTRIC\n\n\n@service(qualifier=\"combustion\")\nclass CombustionEngine(Engine):\n    def get_type(self) -&gt; EngineType:\n        return EngineType.COMBUSTION\n</code></pre> <p>When injecting an interface with multiple implementing dependencies, you need to specify a qualifier to indicate  which concrete class should be resolved.</p> <pre><code>@container.autowire\ndef target(\n    engine: Annotated[Engine, Inject(qualifier=\"electric\")],\n    combustion: Annotated[Engine, Inject(qualifier=\"combustion\")],\n):\n    ...\n</code></pre> <p>Tip</p> <p>Qualifiers can be anything hashable, not just strings! For the above example, <code>EngineType</code> enum members could have been used as qualifiers just as well.</p>"},{"location":"interfaces/#default-implementation","title":"Default implementation","text":"<p>If there are many implementations associated with a given interface, you may want to associate one of them as the default implementation.</p> <p>To accomplish that, omit the qualifier when registering the implementation.</p> <pre><code>@service  # &lt;-- Qualifier being absent will make this the default impl.\nclass ElectricEngine(Engine):\n    pass\n\n@service(qualifier=\"combustion\")\nclass CombustionEngine(Engine):\n    pass\n</code></pre> <p>In the above example when asking for <code>Engine</code> the container will inject <code>ElectricEngine</code>. To inject the other implementations  you need to specify the qualifier as usual.</p>"},{"location":"introduce_to_an_existing_project/","title":"Introduce to an existing project","text":"<p>For large existing projects, you may want to gradually add wireup to the project. One of the issues you will run into sooner or later is being able to share resources between code that uses DI and the rest of the application  which does not. </p> <p>This is especially useful to allow the container to inject dependencies created elsewhere.</p> <p>Think of a database connection. Your application probably already has one. Instead of opening a second connection using a new database service, instruct the container on how to get the connection by using factory functions.</p> <p>Another case might be an existing service that is already constructed elsewhere, and you want to be able to inject it.</p>"},{"location":"introduce_to_an_existing_project/#using-factory-functions","title":"Using Factory functions","text":"<p>In order to expose such resources to the container, use factory functions.</p> <pre><code>from wireup import service\n\n@service\ndef db_connection_factory() -&gt; Connection:\n    return get_existing_db_configuration(...)\n</code></pre> <p>Now it is possible to inject <code>Connection</code> just like any other dependency. </p>"},{"location":"introduce_to_an_existing_project/#links","title":"Links","text":"<ul> <li>Factory functions</li> </ul>"},{"location":"multiple_registrations/","title":"Multiple registrations","text":"<p>Registering the same class multiple times is supported under different qualifiers through factories. </p> <p>A use case for this would be to have multiple services connected to resources of the same underlying type,  such as maintaining two database connections: a main and a read-only copy.</p>"},{"location":"multiple_registrations/#example","title":"Example","text":"<p>Assume an application with two databases: A main one and a read-only replica. In these scenarios, the main connection handles writes, and the read-only one will handle reads.</p>"},{"location":"multiple_registrations/#service-registration-via-factories","title":"Service registration via factories","text":"db_service.py<pre><code>from typing import Annotated\nfrom wireup import service, Inject\n\n# Define a class that holds the base methods for interacting with the db.\nclass DatabaseService:\n    def __init__(self, dsn: str) -&gt; None:\n        self.__connection = ...\n\n    def query(self) -&gt; ...:\n        return self.__connection.query(...)\n\n\n# Define a factory which creates and registers the service interacting with the main db.\n# Register this directly without using a qualifier, this will be injected\n# when services depend on DatabaseService.\n@service\ndef main_db_connection_factory(\n    dsn: Annotated[str, Inject(param=\"APP_DB_DSN\")]\n) -&gt; DatabaseService:\n    return DatabaseService(dsn)\n\n# This factory registers the function using the qualifier \"readonly\"\n# and requests the parameter that corresponds to the read replica DSN.\n@service(qualifier=\"readonly\")\ndef read_db_connection_factory(\n    dsn: Annotated[str, Inject(param=\"APP_READ_DB_DSN\")]\n) -&gt; DatabaseService:\n    return DatabaseService(dsn)\n</code></pre>"},{"location":"multiple_registrations/#usage","title":"Usage","text":"thing_repository.py<pre><code>from dataclasses import dataclass\nfrom wireup import service\n\n\n@service\n@dataclass\nclass ThingRepository:\n    # Main db connection can be injected directly as it is registered\n    # without a qualifier, this makes it the \"default\" implementation.\n    main_db_connection: DatabaseService\n\n    # To inject the read connection the qualifier must be specified.\n    read_db_connection: Annotated[DatabaseService, Inject(qualifier=\"readonly\")]\n\n    def create_thing(self, ...) -&gt; None:\n        return self.main_db_connection...\n\n    def find_by_id(self, pk: int) -&gt; Thing:\n        return self.read_db_connection...\n</code></pre>"},{"location":"services/","title":"Services","text":"<p>Use service objects to implement functionality in your application. Services can depend on configuration or other services.</p>"},{"location":"services/#registration","title":"Registration","text":"<p>Wireup does not enforce a code structure. Services may live anywhere, but must be registered with the container. </p> <p>To register a class as a service you can decorate it with <code>@service</code> or <code>@abstract</code>. In addition, the modules where services reside must be passed to the <code>service_modules</code> parameter in the <code>wireup.create_container</code> call.</p> <p>Good to know</p> <p>Note that you don't need to register each module separately, only the top level modules are sufficient as the container will perform a recursive scan.</p>"},{"location":"services/#lifetime","title":"Lifetime","text":"<p>By default, the container will keep in memory only a single copy of each service.  If you need to generate fresh instances every time a service is injected,  then it needs to be registered with the <code>lifetime</code> parameter set to <code>TRANSIENT</code>.</p>"},{"location":"services/#injection","title":"Injection","text":"<p>To request a service in another serivce simply set the type in the init method. The name of the argument does not matter, only the type is used to detect dependencies.</p> <pre><code>@service\nclass FooService:\n    def __init__(self, bar: BarService) -&gt; None: ...\n</code></pre> <p>Most of the time no additional configuration is needed.</p> <p>Tip</p> <p>Refer to the documentation regarding Annotations for the exact details on when you need to explicitly annotate your dependencies.</p>"},{"location":"testing/","title":"Testing","text":""},{"location":"testing/#unit-tests","title":"Unit tests","text":"<p>Unit testing service objects is meant to be easy as the container does not interfere in any way with the underlying classes.</p> <p>Classes can be instantiated as usual in tests, and you need to pass dependencies  such as services or parameters to them yourself.</p> <p>To specify custom behavior for tests, provide a custom implementation  or a subclass that returns test data as a dependency instead of mocks.</p> <p>It is also possible to use the container to build a part of your dependencies by calling <code>container.get(T)</code> which will return an instance of <code>T</code>.</p>"},{"location":"testing/#overriding","title":"Overriding","text":"<p>Sometimes you need to be able to swap a service object on the fly for a different one such as a mock.</p> <p>The <code>container.override</code> property provides access to a number of useful methods and context managers which help with overriding dependencies  (See override manager).</p> <p>Good to know</p> <ul> <li>Overriding only applies to future autowire calls.</li> <li>Once a singleton service has been instantiated, it is not possible to directly replace any of its direct or transitive dependencies via overriding as the object is already in memory.</li> <li>When injecting interfaces and/or qualifiers, override the interface and/or qualifier  rather than the implementation that will be injected.</li> </ul> <p>Tip</p> <p>If you're using an integration to get the container instance you can use the <code>wireup.integration.xxx.get_container</code>  method. This returns the container associated with your application.</p>"},{"location":"testing/#examples","title":"Examples","text":""},{"location":"testing/#context-manager","title":"Context Manager","text":"<pre><code>random_mock = MagicMock()\n# Chosen by fair dice roll. Guaranteed to be random.\nrandom_mock.get_random.return_value = 4\n\nwith container.override.service(target=RandomService, new=random_mock):\n    # Assuming in the context of a web app:\n    # /random endpoint has a dependency on RandomService\n    # requests to inject RandomService during the lifetime\n    # of this context manager will result in random_mock being injected instead.\n    response = client.get(\"/random\")\n</code></pre>"},{"location":"testing/#pytest","title":"Pytest","text":"<p>Similar to the above example but this uses pytest's autouse to achieve the same result. Also shows how to use <code>get_container</code> when using integrations.</p> app.py<pre><code>def create_app():\n    app = ...\n\n    container = wireup.create_container(...)\n    # Example shows FastAPI but any integration will work the same.\n    wireup.integration.fastapi.setup(container, app)\n\n    return app\n</code></pre> conftest.py<pre><code># This is a function scoped fixture which means \n# you'll get a fresh copy of the application and container every time.\n@pytest.fixture\ndef app():\n    return create_app()\n</code></pre> some_test_file.py<pre><code>from wireup.integration.fastapi import get_container\n\ndef test_something_with_mocked_db_service(client: TestClient, app):\n    with get_container(app).override.service(DBService, new=...):\n        response = client.get(\"/some/path\")\n\n    # Assert response and mock calls.\n</code></pre> <p>It is also possible to add a fixture to fetch the container to avoid the <code>get_container</code> call.</p> conftest.py<pre><code>from wireup.integration.fastapi import get_container\n\n@pytest.fixture\ndef container(app) -&gt; DependencyContainer:\n    return get_container(app)\n</code></pre> some_test_file.py<pre><code>def test_override(client: TestClient, container: DependencyContainer):\n    with container.override.service(DBService, new=...):\n        response = client.get(\"/some/path\")\n\n    # Assert response and mock calls.\n</code></pre>"},{"location":"versioning/","title":"Versioning","text":"<p>This library adheres to Semantic Versioning (Semver) principles to ensure predictable versioning and compatibility for its users. </p> <ul> <li>Semver consists of three distinct version components: MAJOR, MINOR, and PATCH, separated by dots (e.g., 1.2.3). </li> <li>Changes in the MAJOR version indicate backward-incompatible changes, such as breaking API alterations. </li> <li>MINOR version updates signify new, backward-compatible features or enhancements, while PATCH versions are reserved for backward-compatible bug fixes. </li> <li>Releases with a MAJOR version of 0 are considered pre-release and as such, the api is considered unstable.   Minor-version releases may contain breaking changes as the api evolves.</li> <li>The following is considered public API</li> <li>Direct exports of the <code>wireup</code> package.</li> <li>Accessible objects from the public interface of the above exported objects.</li> </ul> <p>Tip</p> <p>When using a pre-release version, pin the constraint to <code>0.x.*</code> so that you don't accidentally upgrade to a version with breaking changes, but are still able to get bug-fix releases.</p>"},{"location":"class/dependency_container/","title":"DependencyContainer","text":"<p>               Bases: <code>BaseContainer</code></p> <p>Dependency Injection and Service Locator container registry.</p> <p>This contains all the necessary information to initialize registered classes. Objects instantiated by the container are lazily loaded and initialized only on first use.</p> <p>Provides the following decorators: <code>register</code>, <code>abstract</code> and <code>autowire</code>. Use register on factory functions and concrete classes which are to be injected from the container. Abstract classes are to be used as interfaces and will not be injected directly, rather concrete classes which implement them will be injected instead.</p> <p>Use the <code>autowire</code> decorator on methods where dependency injection must be performed. Services will be injected automatically where possible. Parameters will have to be annotated as they cannot be located from type alone.</p>"},{"location":"class/dependency_container/#wireup.ioc.dependency_container.DependencyContainer-attributes","title":"Attributes","text":""},{"location":"class/dependency_container/#wireup.ioc.dependency_container.DependencyContainer.context","title":"<code>context: InitializationContext</code>  <code>property</code>","text":"<p>The initialization context for registered targets. A map between an injection target and its dependencies.</p>"},{"location":"class/dependency_container/#wireup.ioc.dependency_container.DependencyContainer.params","title":"<code>params: ParameterBag</code>  <code>property</code>","text":"<p>Parameter bag associated with this container.</p>"},{"location":"class/dependency_container/#wireup.ioc.dependency_container.DependencyContainer-functions","title":"Functions","text":""},{"location":"class/dependency_container/#wireup.ioc.dependency_container.DependencyContainer.__init__","title":"<code>__init__(parameter_bag)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>parameter_bag</code> <code>ParameterBag</code> <p>ParameterBag instance holding parameter information.</p> required"},{"location":"class/dependency_container/#wireup.ioc.dependency_container.DependencyContainer.abstract","title":"<code>abstract(klass)</code>","text":"<p>Register a type as an interface.</p> <p>This type cannot be initialized directly and one of the components implementing this will be injected instead.</p>"},{"location":"class/dependency_container/#wireup.ioc.dependency_container.DependencyContainer.aclose","title":"<code>aclose()</code>  <code>async</code>","text":"<p>Consume generator factories allowing them to properly release resources.</p>"},{"location":"class/dependency_container/#wireup.ioc.dependency_container.DependencyContainer.autowire","title":"<code>autowire(fn)</code>","text":"<p>Automatically inject resources from the container to the decorated methods.</p> <p>Any arguments which the container does not know about will be ignored so that another decorator or framework can supply their values. This decorator can be used on both async and blocking methods.</p> <ul> <li>Classes will be automatically injected.</li> <li>Parameters need to be annotated in order for container to be able to resolve them</li> <li>When injecting an interface for which there are multiple implementations you need to supply a qualifier   using annotations.</li> </ul>"},{"location":"class/dependency_container/#wireup.ioc.dependency_container.DependencyContainer.clear_initialized_objects","title":"<code>clear_initialized_objects()</code>","text":"<p>Drop references to initialized singleton objects.</p> <p>Calling this will cause the container to drop references to initialized singletons and cause it to create new instances when they are requested to be injected.</p> <p>This can be useful in tests in a <code>unittest.TestCase.setUp</code> method or pytest autouse=True fixture, allowing you to have a fresh copy of the container with no previously initialized instances to make test cases independent of each-other.</p>"},{"location":"class/dependency_container/#wireup.ioc.dependency_container.DependencyContainer.close","title":"<code>close()</code>","text":"<p>Consume generator factories allowing them to properly release resources.</p>"},{"location":"class/dependency_container/#wireup.ioc.dependency_container.DependencyContainer.get","title":"<code>get(klass, qualifier=None)</code>","text":"<p>Get an instance of the requested type.</p> <p>Use this to locate services by their type but strongly prefer using injection instead.</p> <p>Parameters:</p> Name Type Description Default <code>qualifier</code> <code>Qualifier | None</code> <p>Qualifier for the class if it was registered with one.</p> <code>None</code> <code>klass</code> <code>type[T]</code> <p>Class of the dependency already registered in the container.</p> required <p>Returns:</p> Type Description <code>T</code> <p>An instance of the requested object. Always returns an existing instance when one is available.</p>"},{"location":"class/dependency_container/#wireup.ioc.dependency_container.DependencyContainer.register","title":"<code>register(obj=None, *, qualifier=None, lifetime=ServiceLifetime.SINGLETON)</code>","text":"<p>Register a dependency in the container. Dependency must be either a class or a factory function.</p> <ul> <li>Use as a decorator without parameters @container.register on a factory function or class to register it.</li> <li>Use as a decorator with parameters to specify qualifier and lifetime, @container.register(qualifier=...).</li> <li>Call it directly with @container.register(some_class_or_factory, qualifier=..., lifetime=...).</li> </ul>"},{"location":"class/dependency_container/#wireup.ioc.dependency_container.DependencyContainer.warmup","title":"<code>warmup()</code>","text":"<p>Initialize all singleton dependencies registered in the container.</p> <p>This should be executed once all services are registered with the container. Targets of autowire will not be affected.</p>"},{"location":"class/django_integration/","title":"Django","text":""},{"location":"class/django_integration/#wireup.integration.django-classes","title":"Classes","text":""},{"location":"class/django_integration/#wireup.integration.django.WireupSettings","title":"<code>WireupSettings</code>  <code>dataclass</code>","text":"<p>Class containing Wireup settings specific to Django.</p>"},{"location":"class/django_integration/#wireup.integration.django.WireupSettings-attributes","title":"Attributes","text":""},{"location":"class/django_integration/#wireup.integration.django.WireupSettings.perform_warmup","title":"<code>perform_warmup: bool = True</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Setting this to true will cause the container to create instances of services at application startup. When set to false, services are created on first use.</p>"},{"location":"class/django_integration/#wireup.integration.django.WireupSettings.service_modules","title":"<code>service_modules: List[Union[str, ModuleType]]</code>  <code>instance-attribute</code>","text":"<p>List of modules containing wireup service registrations.</p>"},{"location":"class/fastapi_integration/","title":"FastAPI","text":""},{"location":"class/fastapi_integration/#wireupintegrationfastapi","title":"wireup.integration.fastapi","text":""},{"location":"class/fastapi_integration/#wireup.integration.fastapi-classes","title":"Classes","text":""},{"location":"class/fastapi_integration/#wireup.integration.fastapi-functions","title":"Functions","text":""},{"location":"class/fastapi_integration/#wireup.integration.fastapi.get_container","title":"<code>get_container(app)</code>","text":"<p>Return the container associated with the given application.</p>"},{"location":"class/fastapi_integration/#wireup.integration.fastapi.setup","title":"<code>setup(container, app)</code>","text":"<p>Integrate Wireup with FastAPI.</p> <p>This will automatically inject dependencies on FastAPI routers.</p>"},{"location":"class/flask_integration/","title":"Flask","text":""},{"location":"class/flask_integration/#wireupintegrationflask","title":"wireup.integration.flask","text":""},{"location":"class/flask_integration/#wireup.integration.flask-classes","title":"Classes","text":""},{"location":"class/flask_integration/#wireup.integration.flask-functions","title":"Functions","text":""},{"location":"class/flask_integration/#wireup.integration.flask.get_container","title":"<code>get_container(app)</code>","text":"<p>Return the container associated with the given application.</p>"},{"location":"class/flask_integration/#wireup.integration.flask.setup","title":"<code>setup(container, app, *, import_flask_config=False)</code>","text":"<p>Integrate Wireup with Flask.</p> <p>This can import Flask config in the container and will automatically inject dependencies in views.</p>"},{"location":"class/initialization_context/","title":"InitializationContext","text":"<p>The initialization context for registered targets. A map between an injection target and its dependencies.</p> <p>Container uses this to determine what to inject for each target.</p>"},{"location":"class/initialization_context/#wireup.ioc.initialization_context.InitializationContext-attributes","title":"Attributes","text":""},{"location":"class/initialization_context/#wireup.ioc.initialization_context.InitializationContext.dependencies","title":"<code>dependencies: Mapping[AutowireTarget, dict[str, AnnotatedParameter]]</code>  <code>property</code>","text":"<p>Read-only view of the dependency definitions.</p>"},{"location":"class/initialization_context/#wireup.ioc.initialization_context.InitializationContext.lifetime","title":"<code>lifetime: Mapping[AutowireTarget, ServiceLifetime]</code>  <code>property</code>","text":"<p>Read-only view of service lifetime mapping.</p>"},{"location":"class/initialization_context/#wireup.ioc.initialization_context.InitializationContext-functions","title":"Functions","text":""},{"location":"class/initialization_context/#wireup.ioc.initialization_context.InitializationContext.__init__","title":"<code>__init__()</code>","text":"<p>Create a new InitializationContext.</p>"},{"location":"class/initialization_context/#wireup.ioc.initialization_context.InitializationContext.add_dependency","title":"<code>add_dependency(target, parameter_name, value)</code>","text":"<p>Update the mapping of dependencies for a particular target.</p> <p>Registers a new dependency for the parameter in parameter_name. Target must have been already initialized prior to calling this.</p>"},{"location":"class/initialization_context/#wireup.ioc.initialization_context.InitializationContext.init_target","title":"<code>init_target(target, lifetime=None)</code>","text":"<p>Initialize the context for a particular target.</p> <p>Returns true on first call. If the target is already registered it returns False.</p>"},{"location":"class/initialization_context/#wireup.ioc.initialization_context.InitializationContext.remove_dependencies","title":"<code>remove_dependencies(target, names_to_remove)</code>","text":"<p>Remove dependencies with names in <code>names_to_remove</code> from the given target.</p> <p>Target must have been already initialized prior to calling this.</p>"},{"location":"class/initialization_context/#wireup.ioc.initialization_context.InitializationContext.remove_dependency_type","title":"<code>remove_dependency_type(target, type_to_remove)</code>","text":"<p>Remove dependencies with the given type from the target.</p> <p>Target must have been already initialized prior to calling this.</p>"},{"location":"class/override_manager/","title":"OverrideManager","text":"<p>Enables overriding of services registered with the container.</p>"},{"location":"class/override_manager/#wireup.ioc.override_manager.OverrideManager-functions","title":"Functions","text":""},{"location":"class/override_manager/#wireup.ioc.override_manager.OverrideManager.clear","title":"<code>clear()</code>","text":"<p>Clear active service overrides.</p>"},{"location":"class/override_manager/#wireup.ioc.override_manager.OverrideManager.delete","title":"<code>delete(target, qualifier=None)</code>","text":"<p>Clear active override for the <code>target</code> service.</p>"},{"location":"class/override_manager/#wireup.ioc.override_manager.OverrideManager.service","title":"<code>service(target, new, qualifier=None)</code>","text":"<p>Override the <code>target</code> service with <code>new</code> for the duration of the context manager.</p> <p>Subsequent autowire calls to <code>target</code> will result in <code>new</code> being injected.</p> <p>Parameters:</p> Name Type Description Default <code>target</code> <code>type</code> <p>The target service to override.</p> required <code>qualifier</code> <code>Qualifier | None</code> <p>The qualifier of the service to override. Set this if service is registered with the qualifier parameter set to a value.</p> <code>None</code> <code>new</code> <code>Any</code> <p>The new object to be injected instead of <code>target</code>.</p> required"},{"location":"class/override_manager/#wireup.ioc.override_manager.OverrideManager.services","title":"<code>services(overrides)</code>","text":"<p>Override a number of services with new for the duration of the context manager.</p>"},{"location":"class/override_manager/#wireup.ioc.override_manager.OverrideManager.set","title":"<code>set(target, new, qualifier=None)</code>","text":"<p>Override the <code>target</code> service with <code>new</code>.</p> <p>Subsequent autowire calls to <code>target</code> will result in <code>new</code> being injected.</p> <p>Parameters:</p> Name Type Description Default <code>target</code> <code>type</code> <p>The target service to override.</p> required <code>qualifier</code> <code>Qualifier | None</code> <p>The qualifier of the service to override. Set this if service is registered with the qualifier parameter set to a value.</p> <code>None</code> <code>new</code> <code>Any</code> <p>The new object to be injected instead of <code>target</code>.</p> required"},{"location":"class/parameter_bag/","title":"ParameterBag","text":"<p>Parameter flat key-value store for use with a container.</p> <p>Allows storing and retrieving of parameters in the bag. Templated strings can be used to interpolate a string referencing parameters.</p>"},{"location":"class/parameter_bag/#wireup.ioc.parameter.ParameterBag-functions","title":"Functions","text":""},{"location":"class/parameter_bag/#wireup.ioc.parameter.ParameterBag.__init__","title":"<code>__init__()</code>","text":"<p>Initialize an empty ParameterBag.</p> <p>ParameterBag holds a flat key-value store of parameter values. __bag: A dictionary to store parameter values. __cache: A cache for interpolated values. __param_cache: A dictionary to keep track of which cache entries involve each parameter.</p>"},{"location":"class/parameter_bag/#wireup.ioc.parameter.ParameterBag.get","title":"<code>get(param)</code>","text":"<p>Get the value of a parameter.</p> <p>If the parameter is templated, interpolate it first by replacing placeholders with parameter values.</p> <p>Parameters:</p> Name Type Description Default <code>param</code> <code>ParameterReference</code> <p>The parameter to retrieve.</p> required <p>Returns:</p> Type Description <code>Any</code> <p>The parameter's value.</p>"},{"location":"class/parameter_bag/#wireup.ioc.parameter.ParameterBag.get_all","title":"<code>get_all()</code>","text":"<p>Get all parameters stored in the bag.</p> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>A dictionary containing all parameter names and their values.</p>"},{"location":"class/parameter_bag/#wireup.ioc.parameter.ParameterBag.put","title":"<code>put(name, val)</code>","text":"<p>Put a parameter value into the bag. This overwrites any previous values.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the parameter.</p> required <code>val</code> <code>Any</code> <p>The value of the parameter.</p> required"},{"location":"class/parameter_bag/#wireup.ioc.parameter.ParameterBag.update","title":"<code>update(new_params)</code>","text":"<p>Update the bag with new set of parameters.</p> <p>Parameters from new_params will overwrite any existing parameters set with the same name.</p> <p>Parameters:</p> Name Type Description Default <code>new_params</code> <code>dict[str, Any]</code> <p>A dictionary of parameter names and their updated values.</p> required"},{"location":"class/parameter_enum/","title":"ParameterEnum","text":"<p>               Bases: <code>Enum</code></p> <p>Enum with a <code>.wire</code> method allowing easy injection of members.</p> <p>Allows you to add application parameters as enum members and their names as values. When you need to inject a parameter instead of referencing it by name you can annotate the parameter with the wire function call or set that as the default value.</p> <p>This will inject a parameter by name and won't work with expressions.</p>"},{"location":"class/parameter_enum/#wireup.ParameterEnum-functions","title":"Functions","text":""},{"location":"class/parameter_enum/#wireup.ParameterEnum.wire","title":"<code>wire()</code>","text":"<p>Inject the parameter this enumeration member represents.</p> <p>Equivalent of <code>Inject(param=EnumParam.enum_member.value)</code></p>"},{"location":"class/wireup/","title":"wireup","text":""},{"location":"class/wireup/#wireup.create_container","title":"<code>wireup.create_container(*, service_modules=None, parameters=None)</code>","text":"<p>Create a container with the given parameters and register all services found in service modules.</p>"},{"location":"class/wireup/#wireup.service","title":"<code>wireup.service(obj=None, *, qualifier=None, lifetime=ServiceLifetime.SINGLETON)</code>","text":"<p>Mark the decorated class as a service.</p> <p>If used on a function it will register it as a factory for the class denoted by its return type.</p>"},{"location":"class/wireup/#wireup.abstract","title":"<code>wireup.abstract(cls)</code>","text":"<p>Mark the decorated class as a service.</p>"},{"location":"class/wireup/#wireup.Inject","title":"<code>wireup.Inject(*, param=None, expr=None, qualifier=None)</code>","text":"<p>Inject resources from the container to autowired method arguments.</p> <p>Arguments are exclusive and only one of them must be used at any time.</p> <p>Note</p> <p>Methods MUST be still decorated with autowire for this to work.</p> <p>Parameters:</p> Name Type Description Default <code>param</code> <code>str | None</code> <p>Inject a given parameter by name.</p> <code>None</code> <code>expr</code> <code>str | None</code> <p>Inject a string value using a templated string. Parameters inside <code>${}</code> will be replaced with their corresponding value.</p> <code>None</code> <code>qualifier</code> <code>Qualifier | None</code> <p>Qualify which implementation to bind when there are multiple components implementing an interface that is registered in the container via <code>@abstract</code>.</p> <code>None</code>"},{"location":"class/wireup/#wireup.ServiceLifetime","title":"<code>wireup.ServiceLifetime</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Determines the lifetime of a service.</p>"},{"location":"class/wireup/#wireup.ServiceLifetime-attributes","title":"Attributes","text":""},{"location":"class/wireup/#wireup.ServiceLifetime.SINGLETON","title":"<code>SINGLETON = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Singleton services are initialized once and reused throughout the lifetime of the container.</p>"},{"location":"class/wireup/#wireup.ServiceLifetime.TRANSIENT","title":"<code>TRANSIENT = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Transient services will have a fresh instance initialized on every injection.</p>"},{"location":"integrations/","title":"Integrations","text":"<p>Wireup is framework-agnostic and can be used in any project, but it also provides integrations for the following frameworks:</p> <ul> <li> Django</li> <li> FastAPI</li> <li> Flask</li> </ul>"},{"location":"integrations/django/","title":"Django","text":"<p>Dependency injection for Django is available via the provided integration in <code>wireup.integration.django</code>.</p> <p>Features:</p> <ul> <li> Inject dependencies in Django views.<ul> <li>Supports functions and class-based views.</li> <li>Eliminates the need for <code>@container.autowire</code>.</li> </ul> </li> <li> Expose <code>django.http.HttpRequest</code> as a wireup dependency.<ul> <li>Available as a <code>TRANSIENT</code> scoped dependency, your services can ask for a django request object.</li> </ul> </li> </ul>"},{"location":"integrations/django/#installation","title":"Installation","text":"<p>To install the integration, add <code>wireup.integration.django</code> to <code>INSTALLED_APPS</code>, define a new <code>WIREUP</code> setting and add the wireup middleware.</p> settings.py<pre><code>import os\nfrom wireup.integration.django import WireupSettings\n\nINSTALLED_APPS = [\n    ...,\n    \"wireup.integration.django\"\n]\n\nMIDDLEWARE = [\"wireup.integration.django.wireup_middleware\"]\n\nWIREUP = WireupSettings(\n    # This is a list of top-level modules containing service registrations.\n    # It can be either a list of strings or module types.\n    service_modules=[\"mysite.polls.services\"]\n)\n\n# Additional application settings.\nS3_BUCKET_ACCESS_TOKEN = os.environ[\"S3_BUCKET_ACCESS_TOKEN\"]\n</code></pre>"},{"location":"integrations/django/#usage","title":"Usage","text":""},{"location":"integrations/django/#define-some-services","title":"Define some services","text":"mysite/polls/services/s3_manager.py<pre><code>from wireup import service\n\n\n@service\n@dataclass\nclass S3Manager:\n    # Reference configuration by name.\n    # This is the same name this appears in settings.\n    access_token: Annotated[str, Inject(param=\"S3_BUCKET_ACCESS_TOKEN\")]\n\n    def upload(self, file: File) -&gt; None: ...\n</code></pre> <p>It is also possible to use django settings in factories.</p> mysite/polls/services/github_client.py<pre><code>@dataclass\nclass GithubClient:\n    api_key: str\n</code></pre> mysite/polls/services/factories.py<pre><code>from wireup import service\n\n\n@service\ndef github_client_factory() -&gt; GithubClient:\n    return GithubClient(settings.GH_API_KEY)\n</code></pre>"},{"location":"integrations/django/#inject","title":"Inject","text":"<p>To perform injection simply request the dependencies in the view.</p> app/views.py<pre><code>def upload_file_view(request: HttpRequest, s3_manager: S3Manager) -&gt; HttpResponse:\n    return HttpResponse(...)\n</code></pre> <p>Class-based views are also supported, you can specify dependencies in your class' <code>__init__</code> function. </p> <p>For more examples see the Wireup Django integration tests.</p>"},{"location":"integrations/django/#testing","title":"Testing","text":"<p>For general testing tips with Wireup refer to the test docs.  With Django you can override dependencies in the container as follows:</p> test_thing.py<pre><code>from wireup.integration.django.apps import get_container\n\ndef test_override():\n    class DummyGreeter(GreeterService):\n        def greet(self, name: str) -&gt; str:\n            return f\"Hi, {name}\"\n\n    with get_container().override.service(GreeterService, new=DummyGreeter()):\n        res = self.client.get(\"/greet?name=Test\")\n</code></pre>"},{"location":"integrations/django/#api-reference","title":"Api Reference","text":"<ul> <li>django_integration</li> </ul>"},{"location":"integrations/fastapi/","title":"FastAPI","text":"<p>Dependency injection for FastAPI is available in the <code>wireup.integration.fastapi_integration</code> module.</p> <p>Features:</p> <ul> <li> Inject dependencies in FastAPI routes.<ul> <li>Eliminates the need for <code>@container.autowire</code>.</li> </ul> </li> <li> Expose <code>fastapi.Request</code> as a wireup dependency.<ul> <li>Available as a <code>TRANSIENT</code> scoped dependency, your services can ask for a fastapi request object.</li> </ul> </li> <li> Can: Mix Wireup and FastAPI dependencies in routes.</li> <li> Cannot: Use FastAPI dependencies in Wireup service objects.</li> </ul>"},{"location":"integrations/fastapi/#getting-started","title":"Getting Started","text":"main.py<pre><code>app = FastAPI()\n\n@app.get(\"/random\")\nasync def target(\n    # Inject annotation tells wireup that this argument should be injected.\n    # Inject() annotation is required otherwise fastapi will think it's a pydantic model.\n    random_service: Annotated[RandomService, Inject()],\n    is_debug: Annotated[bool, Inject(param=\"env.debug\")],\n\n    # This is a regular FastAPI dependency.\n    lucky_number: Annotated[int, Depends(get_lucky_number)]\n): ...\n\n@app.websocket(\"/ws\")\nasync def ws(websocket: WebSocket, greeter: Annotated[GreeterService, Inject()]):\n    ...\n\n# Initialize the integration.\n# Must be called after all routers have been added.\n# service_modules is a list of top-level modules with service registrations.\ncontainer = wireup.create_container(\n    service_modules=[services], \n    parameters=get_settings_dict()\n)\nwireup.integration.fastapi.setup(container, app)\n</code></pre> <p>Wireup integration performs injection only in fastapi routes. If you're not storing the container in a global variable,  you can always get a reference to it wherever you have a fastapi application reference by using <code>wireup.integration.fastapi.get_container</code>.</p> example_middleware.py<pre><code>from wireup.integration.fastapi import get_container\n\nasync def example_middleware(request: Request, call_next) -&gt; Response:\n    container = get_container(request.app)\n    ...\n\n    return await call_next(request)\n</code></pre> <p>In the same way, you can get a reference to it in a fastapi dependency. <pre><code>from wireup.integration.fastapi import get_container\n\nasync def example_dependency(request: Request, other_dependency: Depends(...)):\n    container = get_container(request.app)\n    ...\n</code></pre></p>"},{"location":"integrations/fastapi/#fastapi-request","title":"FastAPI request","text":"<p>A key feature of the integration is to expose <code>fastapi.Request</code> and <code>starlette.requests.Request</code> objects in wireup.</p> <p>Services depending on it should be transient, so that you get a fresh copy  every time with the current request being processed.</p> <pre><code>@service(lifetime=ServiceLifetime.TRANSIENT)\nclass HttpAuthenticationService:\n    def __init__(self, request: fastapi.Request) -&gt; None: ...\n\n\n@service(lifetime=ServiceLifetime.TRANSIENT)\ndef example_factory(request: fastapi.Request) -&gt; ExampleService: ...\n</code></pre>"},{"location":"integrations/fastapi/#testing","title":"Testing","text":"<p>For general testing tips with Wireup refer to the test docs.  With the FastAPI integration you can override dependencies in the container as follows.</p> test_thing.py<pre><code>from wireup.integration.fastapi import get_container\n\ndef test_override():\n    class DummyGreeter(GreeterService):\n        def greet(self, name: str) -&gt; str:\n            return f\"Hi, {name}\"\n\n    with get_container(app).override.service(GreeterService, new=DummyGreeter()):\n        res = self.client.get(\"/greet?name=Test\")\n</code></pre> <p>See FastAPI integration tests for more examples.</p>"},{"location":"integrations/fastapi/#api-reference","title":"Api Reference","text":"<ul> <li>fastapi_integration</li> </ul>"},{"location":"integrations/flask/","title":"Flask","text":"<p>Dependency injection for Flask is available in the<code>wireup.integration.flask_integration</code> module.</p> <p>Features:</p> <ul> <li>Automatically decorate Flask views and blueprints where the container is being used.<ul> <li>Eliminates the need for <code>@container.autowire</code> in views.</li> <li>Views without container references will not be decorated.</li> </ul> </li> <li>Expose Flask configuration in the container's parameters.</li> </ul>"},{"location":"integrations/flask/#examples","title":"Examples","text":"<pre><code>app = Flask(__name__)\napp.config[\"FOO\"] = \"bar\"\n\n@app.get(\"/random\")\ndef get_random(random: RandomService):\n    return {\"lucky_number\": random.get_random()}\n\n@app.get(\"/env\")\ndef get_environment(\n    is_debug: Annotated[bool, Inject(param=\"DEBUG\")], \n    foo: Annotated[str, Inject(param=\"FOO\")]\n):\n    return {\"debug\": is_debug, \"foo\": foo}\n\n\ncontainer = wireup.create_container(\n    # service_modules is a list of top-level modules with service registrations.\n    service_modules=[services],\n    parameters={\"FOO\": \"bar\"}\n)\n\n# Initialize the integration.\n# Must be called after views and configuration have been added.\nwireup.integration.flask.setup(container, app, import_flask_config=True)\n\napp.run()\n</code></pre>"},{"location":"integrations/flask/#testing","title":"Testing","text":"<p>For general testing tips with Wireup refer to the test docs.  With the Flask integration you can override dependencies in the container as follows.</p> test_thing.py<pre><code>from wireup.integration.flask import get_container\n\ndef test_override():\n    class DummyGreeter(GreeterService):\n        def greet(self, name: str) -&gt; str:\n            return f\"Hi, {name}\"\n\n    with get_container(app).override.service(GreeterService, new=DummyGreeter()):\n        res = self.client.get(\"/greet?name=Test\")\n</code></pre> <p>See Flask integration tests for more examples.</p>"},{"location":"integrations/flask/#api-reference","title":"Api Reference","text":"<ul> <li>flask_integration</li> </ul>"}]}