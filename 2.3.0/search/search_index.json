{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Wireup","text":"<p>Performant, concise and type-safe Dependency Injection for Python 3.8+</p> <p> </p> <p>What is Dependency Injection?</p> <p>Dependency Injection (DI) is a design pattern where dependencies are provided externally rather than created within objects. Wireup automates DI using Python's type system, with support for async, generators and other modern Python features.</p> <p>Zero Runtime Overhead</p> <p>New: Inject Dependencies in FastAPI with zero runtime overhead using Class-Based Handlers.</p>"},{"location":"#features","title":"Features","text":""},{"location":"#simple-type-safe-di","title":"\u2728 Simple &amp; Type-Safe DI","text":"<p>Inject services and configuration using a clean and intuitive syntax without boilerplate.</p> Basic UsageNo Annotations <pre><code>@service\nclass Database:\n    pass\n\n@service\nclass UserService:\n    def __init__(self, db: Database) -&gt; None:\n        self.db = db\n\ncontainer = wireup.create_sync_container(services=[Database, UserService])\nuser_service = container.get(UserService) # \u2705 Dependencies resolved.\n</code></pre> <pre><code># Clean domain objects: No annotations\nclass Database:\n    pass\n\nclass UserService:\n    def __init__(self, db: Database) -&gt; None:\n        self.db = db\n\n# Register services via factories\n@service\ndef database_factory() -&gt; Database:\n    return Database()\n\n@service\ndef user_service_factory(db: Database) -&gt; UserService:\n    return UserService(db)\n\ncontainer = wireup.create_sync_container(\n    services=[database_factory, user_service_factory]\n)\nuser_service = container.get(UserService) # \u2705 Dependencies resolved.\n</code></pre>"},{"location":"#function-injection","title":"\ud83c\udfaf Function Injection","text":"<p>Inject dependencies directly into functions with a simple decorator.</p> <pre><code>@inject_from_container(container)\ndef process_users(service: Injected[UserService]):\n    # \u2705 UserService injected.\n    pass\n</code></pre>"},{"location":"#interfaces-abstract-classes","title":"\ud83d\udcdd Interfaces &amp; Abstract Classes","text":"<p>Define abstract types and have the container automatically inject the implementation.</p> <pre><code>@abstract\nclass Notifier(abc.ABC):\n    pass\n\n@service\nclass SlackNotifier(Notifier):\n    pass\n\nnotifier = container.get(Notifier) # \u2705 SlackNotifier instance.\n</code></pre>"},{"location":"#managed-service-lifetimes","title":"\ud83d\udd04 Managed Service Lifetimes","text":"<p>Declare dependencies as singletons, scoped, or transient to control whether to inject a fresh copy or reuse existing instances.</p> SingletonScopedTransient <p>One instance per application. <code>@service(lifetime=\"singleton\")</code> is the default.</p> <pre><code>@service\nclass Database:\n    pass\n</code></pre> <p>One instance per scope/request, shared within that scope/request.</p> <pre><code>@service(lifetime=\"scoped\")\nclass RequestContext:\n    def __init__(self) -&gt; None:\n        self.request_id = uuid4()\n</code></pre> <p>When full isolation and clean state is required. Every request to create transient services results in a new instance.</p> <pre><code>@service(lifetime=\"transient\")\nclass OrderProcessor:\n    pass\n</code></pre>"},{"location":"#flexible-creation-patterns","title":"\ud83c\udfed Flexible Creation Patterns","text":"<p>Defer instantiation to specialized factories when complex initialization or cleanup is required. Full support for async and generators. Wireup handles cleanup at the correct time depending on the service lifetime.</p> SynchronousAsync <pre><code>class WeatherClient:\n    def __init__(self, client: requests.Session) -&gt; None:\n        self.client = client\n\n@service\ndef weather_client_factory() -&gt; Iterator[WeatherClient]:\n    with requests.Session() as session:\n        yield WeatherClient(client=session)\n</code></pre> <pre><code>class WeatherClient:\n    def __init__(self, client: aiohttp.ClientSession) -&gt; None:\n        self.client = client\n\n@service\nasync def weather_client_factory() -&gt; AsyncIterator[WeatherClient]:\n    async with aiohttp.ClientSession() as session:\n        yield WeatherClient(client=session)\n</code></pre>"},{"location":"#improved-safety","title":"\ud83d\udee1\ufe0f Improved Safety","text":"<p>Wireup is mypy strict compliant and will not introduce type errors. It will also warn at the earliest possible stage about configuration errors to avoid surprises at runtime.</p> Container CreationFunction InjectionIntegrationsParameter Checks <p>The container will raise errors at creation time about missing dependencies or other issues.</p> <pre><code>@service\nclass Foo:\n    def __init__(self, unknown: NotManagedByWireup) -&gt; None:\n        pass\n\ncontainer = wireup.create_sync_container(services=[Foo])\n# \u274c Parameter 'unknown' of 'Foo' depends on an unknown service 'NotManagedByWireup'.\n</code></pre> <p>Injected functions will raise errors at module import time rather than when called.</p> <pre><code>@inject_from_container(container)\ndef my_function(oops: Injected[NotManagedByWireup]):\n    pass\n\n# \u274c Parameter 'oops' of 'my_function' depends on an unknown service 'NotManagedByWireup'.\n</code></pre> <p>Wireup integrations assert that requested injections in the framework are valid. <pre><code>@app.get(\"/\")\ndef home(foo: Injected[NotManagedByWireup]):\n    pass\n\nwireup.integration.flask.setup(container, app)\n# \u274c Parameter 'foo' of 'home' depends on an unknown service 'NotManagedByWireup'.\n</code></pre></p> <p>Configuration parameters are also checked for validity. <pre><code>class Database:\n    def __init__(self, url: Annotated[str, Inject(param=\"db_url\")]) -&gt; None:\n        self.db = db\n\n# \u274c Parameter 'url' of Type 'Database' depends on an unknown Wireup parameter 'db_url'.\n</code></pre></p>"},{"location":"#framework-agnostic","title":"\ud83d\udccd Framework-Agnostic","text":"<p>Wireup provides its own Dependency Injection mechanism and is not tied to specific frameworks. Use it anywhere you like.</p>"},{"location":"#share-services-between-application-and-cli","title":"\ud83d\udd17 Share Services Between Application and CLI","text":"<p>Share the service layer between web applications and their accompanying CLIs using Wireup.</p>"},{"location":"#native-integration-with-popular-frameworks","title":"\ud83d\udd0c Native Integration with popular frameworks","text":"<p>Integrate with popular frameworks for a smoother developer experience. Integrations manage request scopes, injection in endpoints, and lifecycle of services.</p> FastAPI example<pre><code>app = FastAPI()\ncontainer = wireup.create_async_container(services=[UserService, Database])\n\n@app.get(\"/\")\ndef users_list(user_service: Injected[UserService]):\n    pass\n\nwireup.integration.fastapi.setup(container, app)\n</code></pre> <p>View all integrations \u2192</p>"},{"location":"#simplified-testing","title":"\ud83e\uddea Simplified Testing","text":"<p>Wireup does not patch services and lets them be tested in isolation.</p> <p>If the container is needed in tests, it can create parts of services or perform dependency substitution.</p> <pre><code>with container.override.service(target=Database, new=in_memory_database):\n    # The /users endpoint depends on Database.\n    # During the lifetime of this context manager, requests to inject `Database`\n    # will result in `in_memory_database` being injected instead.\n    response = client.get(\"/users\")\n</code></pre>"},{"location":"#next-steps","title":"Next Steps","text":"<ul> <li>Getting Started - Follow the Getting Started guide for a more in-depth tutorial.</li> <li>Services</li> <li>Parameters</li> </ul>"},{"location":"annotation_free/","title":"Clean Domain Code","text":"<p>If you prefer not to add Wireup annotations to your classes and keep domain logic free of infrastructure concerns, you can use factories to create all services including configuration.</p>"},{"location":"annotation_free/#using-factory-functions","title":"Using Factory Functions","text":"<p>Instead of decorating classes directly, create factories that create said classes.</p> services.py<pre><code># Clean domain objects - no annotations\nclass UserService:\n    def __init__(self, repository: UserRepository) -&gt; None:\n        self.repository = repository\n\nclass UserRepository:\n    def __init__(self, database: Database) -&gt; None:\n        self.database = database\n</code></pre> factories.py<pre><code>from wireup import service\n\n@service\ndef user_repository_factory(database: Database) -&gt; UserRepository:\n    return UserRepository(database)\n\n@service  \ndef user_service_factory(repository: UserRepository) -&gt; UserService:\n    return UserService(repository)\n</code></pre>"},{"location":"annotation_free/#configuration-classes","title":"Configuration Classes","text":"<p>For deeply nested configuration, use typed classes instead of parameter injection:</p> factories.py<pre><code>from wireup import service\n\n# Register configuration\n@service\ndef app_config_factory() -&gt; AppConfig:\n    return AppConfig(\n        database=DatabaseConfig(...),\n        redis=RedisConfig(...),\n        api_key=...,\n    )\n\n@service\ndef database_factory(config: AppConfig) -&gt; Database:\n    return Database(config.database)\n\n@service\ndef redis_factory(config: AppConfig) -&gt; Redis:\n    return Redis(config.redis.url, timeout=config.redis.timeout)\n</code></pre>"},{"location":"annotations/","title":"Dependency Annotations","text":"<p>Wireup uses type annotations to figure out which dependencies to inject. Most of the time, just the type is enough, but sometimes you need to add extra information using injection annotations.</p>"},{"location":"annotations/#when-do-you-need-annotations","title":"When Do You Need Annotations?","text":"<p>Whether you need annotations depends on where you're injecting into Wireup services or into external targets.</p>"},{"location":"annotations/#injecting-into-wireup-services","title":"Injecting into Wireup Services","text":"<p>For classes and functions marked with <code>@service</code>:</p> Dependency Type Annotations Needed? Required Information Services No - Interface with single implementation No - Default implementation of interface No - Interface with multiple implementations Yes Qualifier Parameters Yes Parameter name Parameter expressions Yes Expression template"},{"location":"annotations/#injecting-into-external-code","title":"Injecting into External Code","text":"<p>When you're injecting into code that Wireup doesn't manage (like framework route handlers), you always need annotations. Use either <code>Annotated[T, Inject(...)]</code> or the shorthand <code>Injected[T]</code>.</p> <p>Why external code needs annotations</p> <p>Inside Wireup services, Wireup assumes full ownership of all dependencies, so basic <code>Injected[T]</code> annotations are redundant. For external targets, annotations explicitly tell Wireup to handle those parameters.</p>"},{"location":"annotations/#usage-examples","title":"Usage Examples","text":"<p>Here's how to use annotations in Python 3.9+ (or Python 3.8+ with <code>typing_extensions</code>):</p> <pre><code>@wireup.inject_from_container(container)\ndef configure(\n    # Inject a configuration parameter by name\n    env: Annotated[str, Inject(param=\"app_env\")],\n\n    # Inject a computed value using parameter substitution\n    log_path: Annotated[str, Inject(expr=\"${data_dir}/logs\")],\n\n    # Inject a service (explicit annotation required for external targets)\n    service: Annotated[MyService, Inject()],\n\n    # Alternative shorthand syntax for service injection\n    service: Injected[MyService],\n\n    # Inject a specific implementation when multiple exist\n    db: Annotated[Database, Inject(qualifier=\"readonly\")]\n):\n    ...\n</code></pre>"},{"location":"apply_container_as_decorator/","title":"Function Injection","text":"<p>Note</p> <p>When using the provided integrations, this is automatically handled for you. Only use this if you're injecting Wireup dependencies in a framework without an integration.</p> <p>Instead of manually retrieving services via <code>container.get</code> or parameters via <code>container.params</code>, you can inject them directly into function parameters using the container as a decorator.</p> <p>This transforms verbose manual dependency retrieval:</p> <pre><code>def client_function() -&gt; None:\n    random = container.get(RandomService)\n    env_name = container.params.get(\"env\")\n\n    with container.enter_scope() as scoped_container:\n        scoped_service = scoped_container.get(ScopedService)\n</code></pre> <p>Into clean, declarative dependency injection.</p>"},{"location":"apply_container_as_decorator/#using-wireupinject_from_container","title":"Using <code>@wireup.inject_from_container</code>","text":"<p>Use the <code>wireup.inject_from_container</code> decorator to automatically inject dependencies into function parameters. The container enters a scope before function execution, injects all dependencies, and exits the scope when the function returns.</p> <p>Note</p> <p>The decorator only injects parameters annotated with <code>Injected[T]</code> or <code>Annotated[T, Inject()]</code>. These annotations are equivalent\u2014<code>Injected[T]</code> is simply an alias for convenience.</p> <pre><code>from wireup import Injected\n\n@wireup.inject_from_container(container)\ndef client_function(\n    service: Injected[RandomService], \n    scoped_service: Injected[ScopedService], \n    env_name: Annotated[str, Inject(param=\"env\")]\n) -&gt; None: ...\n</code></pre>"},{"location":"apply_container_as_decorator/#using-an-existing-scoped-container","title":"Using an existing scoped container","text":"<p>If you have already created a scoped container elsewhere, provide a callable that returns it as the second argument. Wireup will use that container instead of creating a new scope:</p> <pre><code>scoped_container: ContextVar[ScopedSyncContainer] = ContextVar(\"scoped_container\")\n\n@wireup.inject_from_container(container, scoped_container.get)\ndef client_function(\n    service: Injected[RandomService], \n    scoped_service: Injected[ScopedService], \n    env_name: Annotated[str, Inject(param=\"env\")]\n) -&gt; None: ...\n</code></pre>"},{"location":"apply_container_as_decorator/#creating-a-decorator-alias","title":"Creating a decorator alias","text":"<p>For cleaner code, you can alias the decorator:</p> <pre><code>scoped_container: ContextVar[ScopedSyncContainer] = ContextVar(\"scoped_container\")\ninjected = wireup.inject_from_container(container, scoped_container.get)\n\n@injected\ndef client_function(\n    service: Injected[RandomService], \n    scoped_service: Injected[ScopedService], \n    env_name: Annotated[str, Inject(param=\"env\")]\n) -&gt; None: ...\n</code></pre>"},{"location":"apply_container_as_decorator/#additional-notes","title":"Additional notes","text":"<ul> <li>Works with both sync and async containers</li> <li>For <code>async def</code> functions, use an async container created via <code>wireup.create_async_container</code></li> </ul>"},{"location":"apply_container_as_decorator/#api-reference","title":"API Reference","text":""},{"location":"apply_container_as_decorator/#wireupinject_from_container","title":"<code>wireup.inject_from_container</code>","text":"<p>Inject dependencies into the decorated function based on annotations.</p> <p>Parameters:</p> Name Type Description Default <code>container</code> <code>SyncContainer | AsyncContainer</code> <p>The main container instance created via <code>wireup.create_sync_container</code> or <code>wireup.create_async_container</code>.</p> required <code>scoped_container_supplier</code> <code>Callable[[], ScopedSyncContainer | ScopedAsyncContainer] | None</code> <p>An optional callable that returns the current scoped container instance. If provided, it will be used to create scoped dependencies. If not provided, the container will automatically enter a scope. Provide a scoped_container_supplier if you need to manage the container's scope manually. For example, in web frameworks, you might enter the scope at the start of a request in middleware so that other middlewares can access the scoped container if needed.</p> <code>None</code> <code>middleware</code> <code>Callable[[ScopedSyncContainer | ScopedAsyncContainer, tuple[Any, ...], dict[str, Any]], AbstractContextManager[None]] | None</code> <p>A context manager that wraps the execution of the target function.</p> <code>None</code>"},{"location":"container/","title":"Container","text":"<p>The container manages application services and automatically resolves their dependencies. Create one at startup, register services, and let it handle the wiring.</p>"},{"location":"container/#creating-containers","title":"Creating Containers","text":"<p>Choose the container type based on the application's needs:</p>"},{"location":"container/#synchronous","title":"Synchronous","text":"<p>For traditional synchronous Python applications:</p> <pre><code>import wireup\n\ncontainer = wireup.create_sync_container(services=[UserService, Database])\n\nuser_service = container.get(UserService)\n</code></pre>"},{"location":"container/#async","title":"Async","text":"<p>For applications using async/await:</p> <pre><code>import wireup\n\ncontainer = wireup.create_async_container(services=[UserService, Database])\n\nuser_service = await container.get(UserService)\n</code></pre> <p>The async container can handle both sync and async services, but requires <code>await</code> for service retrieval.</p>"},{"location":"container/#registering-services","title":"Registering Services","text":""},{"location":"container/#1-service-discovery","title":"1. Service Discovery","text":"<p>Let Wireup automatically find services in modules:</p> <pre><code>import wireup\nfrom myapp import services, repositories\n\ncontainer = wireup.create_sync_container(\n    service_modules=[services, repositories],\n    parameters={\"api_key\": \"secret\"}\n)\n</code></pre> <p>Example project structure:</p> <pre><code>myapp/\n\u251c\u2500\u2500 services/\n\u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u2514\u2500\u2500 user_service.py      # Contains @service decorations\n\u251c\u2500\u2500 repositories/\n\u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u2514\u2500\u2500 user_repository.py   # Contains @service decorations\n\u2514\u2500\u2500 main.py\n</code></pre> <p>How it works:</p> <ul> <li>Wireup scans the provided modules recursively</li> <li>Finds classes and functions decorated with <code>@service</code> or <code>@abstract</code></li> <li>Automatically registers them and resolves their dependencies</li> </ul>"},{"location":"container/#2-manual-registration","title":"2. Manual Registration","text":"<p>Register specific services individually:</p> <pre><code>import wireup\nfrom myapp.services import UserService, EmailService\n\ncontainer = wireup.create_sync_container(\n    services=[UserService, EmailService],\n    parameters={\"db_url\": \"postgresql://localhost/myapp\"}\n)\n</code></pre> <p>You can also mix both approaches as needed:</p> <pre><code>container = wireup.create_sync_container(\n    service_modules=[services],      # Auto-discover\n    services=[SpecialService],       # Manual addition\n    parameters={\"api_key\": \"secret\"}\n)\n</code></pre>"},{"location":"container/#container-cleanup","title":"Container Cleanup","text":"<p>Clean up the container when shutting down. This is required to properly close factories that manage resources.</p> <pre><code># For sync containers\ncontainer.close()\n\n# For async containers\nawait container.close()\n</code></pre>"},{"location":"factories/","title":"Factories and Resource Management","text":"<p>Use factories to handle complex service creation logic or resource management that can't be done with simple class constructors.</p>"},{"location":"factories/#use-cases","title":"Use cases","text":"<ul> <li>Object construction needs additional logic or configuration.</li> <li>Create optional dependencies.</li> <li>Depending on the runtime environment or configuration, you may need to create different objects  inheriting from the same base class/protocol.</li> <li>Inject a model/dto which represents the result of an action, such as the current authenticated user.</li> <li>Inject a class from another library where it's not possible to add annotations.</li> <li>Inject strings, ints and other built-in types.</li> </ul> <p>In order for the container to inject these dependencies, you must decorate the factory with <code>@service</code> and register it with the container. Return type annotation of the factory is required as it denotes what will be built.</p>"},{"location":"factories/#generator-factories","title":"Generator Factories","text":"<p>Use generator factories when a service requires cleanup (like database connections or network resources).</p> GeneratorsContext ManagerAsync Context Manager <pre><code>@service\ndef db_session_factory() -&gt; Iterator[Session]:\n    db = Session()\n    try:\n        yield db\n    finally:\n        db.close()\n</code></pre> <pre><code>@service\ndef db_session_factory() -&gt; Iterator[Session]:\n    with contextlib.closing(Session()) as db:\n        yield db\n</code></pre> <pre><code>@service\nasync def client_session_factory() -&gt; ClientSession:\n    async with ClientSession() as sess:\n        yield sess\n</code></pre> <p>Generator Factories</p> <p>Generator factories must yield exactly once. Yielding multiple times will result in cleanup not being performed.</p>"},{"location":"factories/#implement-strategy-pattern","title":"Implement strategy pattern","text":"<p>Assume a base class <code>Notifier</code> with implementations that define how the notification is sent (IMAP, POP, WebHooks, etc.) Given a user it is possible to instantiate the correct type of notifier based on user preferences.</p> <pre><code>from wireup import service\n\n@service(lifetime=\"scoped\")\ndef get_user_notifier(\n    user: AuthenticatedUser, \n    slack_notifier: SlackNotifier, \n    email_mailer: EmailNotifier\n) -&gt; Notifier:\n    notifier = ...  # get notifier type from preferences.\n\n    return notifier\n</code></pre> <p>When injecting <code>Notifier</code> the correct type will be injected based on the authenticated user's preferences.</p>"},{"location":"factories/#inject-a-third-party-class","title":"Inject a third-party class","text":"<p>You can use factories to inject a class which you have not declared yourself and as such, cannot annotate.  Let's take redis client as an example. </p> <pre><code>from wireup import service\n\n@service\ndef redis_factory(redis_url: Annotated[str, Inject(param=\"redis_url\")]) -&gt; Redis:\n    return redis.from_url(redis_url)\n</code></pre>"},{"location":"factories/#inject-models","title":"Inject Models","text":"<p>Assume the authenticated user is provided by <code>AuthService</code>. You may choose to allow the user to be injected directly instead of having to call <code>auth_service.get_current_user()</code> everywhere.</p> <pre><code>from wireup import service\n\n@service(lifetime=\"scoped\")\ndef get_current_user(auth_service: AuthService) -&gt; AuthenticatedUser:\n    return auth_service.get_current_user()\n</code></pre>"},{"location":"factories/#inject-built-in-types","title":"Inject built-in types","text":"<p>If you want to inject resources which are just strings, ints, or other built-in types then you can use a factory in combination with <code>NewType</code>. Note that since Wireup uses types to identify dependencies, new types are strongly recommended for this use case.</p> factories.py<pre><code>AuthenticatedUsername = NewType(\"AuthenticatedUsername\", str)\n\n@service\ndef authenticated_username_factory(auth: SomeAuthService) -&gt; AuthenticatedUsername:\n    return AuthenticatedUsername(...)\n</code></pre> <p>This can now be injected as usual by annotating the dependency with the new type.</p>"},{"location":"factories/#error-handling","title":"Error Handling","text":"<p>When using generator factories with scoped or transient lifetimes, unhandled errors that occur within the  scope are  automatically propagated to the factories. This enables proper error handling, such as rolling back  database transactions or cleaning up resources when operations fail.</p> <pre><code>@service(lifetime=\"scoped\")\ndef db_session_factory(engine: Engine) -&gt; Iterator[Session]:\n    session = Session(engine)\n    try:\n        yield session\n    except Exception as e:\n        # Error occurred somewhere in the scope - rollback the transaction\n        session.rollback()\n        raise\n    else:\n        # No errors - commit the transaction\n        session.commit()\n    finally:\n        # Always close the session\n        session.close()\n</code></pre> <p>Suppressing Errors</p> <p>Factories may perform cleanup (for example, rolling back a transaction), but they cannot suppress the original error, that exception will still be propagated. Wireup enforces this so cleanup code cannot change the program's control flow by swallowing errors.</p> <p>If a factory raises additional exceptions during teardown, Wireup will temporarily catch those exceptions so it can finish cleaning up all generator factories. After cleanup completes, the teardown exceptions are re-raised alongside the primary exception.</p>"},{"location":"factories/#database-transaction-example","title":"Database Transaction Example","text":"<pre><code>from typing import Iterator\nfrom sqlalchemy.orm import Session\nfrom wireup import service, Injected\n\n@service(lifetime=\"scoped\")\nclass UserService:\n    # Uses Session as defined above.\n    def __init__(self, db: Session) -&gt; None:\n        self.db = db\n\n    def create_user(self, user_data: UserCreate) -&gt; User:\n        # Database operations here\n        ...\n\n# Usage in a web framework (FastAPI example)\n@app.post(\"/users\")\ndef create_user(\n    user_data: UserCreate, \n    user_service: Injected[UserService]\n) -&gt; User:\n    # If this raises an exception, the database transaction\n    # will automatically be rolled back\n    return user_service.create_user(user_data)\n</code></pre> <p>Framework Integration</p> <p>When using Wireup with web frameworks, each request automatically gets its own scope.  When using this feature, database transactions and other resources are automatically managed per request, with automatic rollback on any unhandled exception.</p>"},{"location":"factories/#optional-dependencies-and-factories","title":"Optional Dependencies and Factories","text":"<p>You can both request Optional dependencies and create factories that return optional values. This is useful when a service might not be available or when you want to make a dependency optional.</p> <p>Service Registration Required</p> <p>When using optional dependencies, the service providing the optional dependency must still be registered in the container. The service cannot be absent - it can only return <code>None</code>. This means you must register a factory that can potentially return <code>None</code>, rather than simply not registering the service at all.</p>"},{"location":"factories/#factories-returning-optional-values","title":"Factories Returning Optional Values","text":"<p>Sometimes you want a factory to return <code>None</code> when certain conditions aren't met. A common example is a service that requires configuration to be available:</p> <pre><code>@service\ndef cache_factory(\n    redis_url: Annotated[str | None, Inject(param=\"redis_url\")],\n) -&gt; Redis | None:\n    return Redis.from_url(redis_url) if redis_url else None\n</code></pre>"},{"location":"factories/#requesting-optional-dependencies","title":"Requesting Optional Dependencies","text":"<p>When a service has an optional dependency, simply use <code>T | None</code> or <code>Optional[T]</code>.</p> Python 3.10+Python &lt;3.10 <pre><code>@service\nclass UserService:\n    def __init__(self, cache: Cache | None) -&gt; None:\n        self.cache = cache\n\n    def get_user(self, id: str) -&gt; User:\n        if self.cache:\n            cached = self.cache.get(id)\n            if cached:\n                return cached\n        # Fallback to database\n        ...\n</code></pre> <pre><code>@service\nclass UserService:\n    def __init__(self, cache: Optional[Cache]) -&gt; None:\n        self.cache = cache\n\n    def get_user(self, id: str) -&gt; User:\n        if self.cache:\n            cached = self.cache.get(id)\n            if cached:\n                return cached\n        # Fallback to database\n        ...\n</code></pre> <p>Null Object Pattern</p> <p>For cleaner code when dealing with optional dependencies, consider using the Null Object Pattern instead of conditional checks throughout your code.</p> <p>Direct Access</p> <p>When accessing optional dependencies directly from the container, you can retrieve them using <code>container.get()</code> just like any other service. If the factory was registered with an optional return type you'll need to provide the union type when retrieving it.</p> <pre><code># \u2705 This works - getting the service directly\ncache = container.get(Optional[Cache]) \ncache = container.get(Cache | None) \n</code></pre>"},{"location":"future_annotations/","title":"Type Annotations Support","text":"<p>Wireup supports string type annotations and <code>from __future__ import annotations</code> when the <code>eval_type_backport</code> package is installed.</p>"},{"location":"future_annotations/#important-requirements","title":"Important Requirements","text":"<ol> <li>Define services and factories at the module level only. Inner function definitions are not supported.</li> <li>Keep type imports accessible at runtime - don't move them to <code>TYPE_CHECKING</code> blocks.</li> </ol>"},{"location":"future_annotations/#example","title":"Example","text":"<pre><code>from typing import TYPE_CHECKING\n\nif TYPE_CHECKING:\n    from collections.abc import Iterator  # Don't do this!\n\n\n@service\ndef thing_factory() -&gt; Iterator[Thing]:  # This needs the import at runtime\n    yield Thing()\n\n@service\nclass Service:\n    def __init__(self, thing: Thing): # This too needs the import at runtime\n        pass\n</code></pre> <p>Warning</p> <p>If you use Ruff/flake8 with rules like <code>TCH</code>, be careful not to move required imports into <code>TYPE_CHECKING</code> blocks.</p>"},{"location":"getting_started/","title":"Getting Started","text":"<p>To showcase the basics of Wireup, we will create a container able to inject the following:</p> <ul> <li>A <code>WeatherService</code> that queries a fictional weather api. It needs an api key, a <code>KeyValueStore</code> to cache data and an async http client to make requests.</li> <li><code>KeyValueStore</code> itself needs a <code>redis_url</code> denoting the server it will connect to to query/store data.</li> </ul> <p>These services will then be retrieved in a <code>/weather/forecast</code> endpoint that requires <code>WeatherService</code> to provide weather information.</p> <pre><code>graph LR\n    redis_url[\u2699\ufe0f redis_url] --&gt; KeyValueStore[\ud83d\udc0d KeyValueStore]\n    weather_api_key[\u2699\ufe0f weather_api_key] --&gt; WeatherService\n    KeyValueStore --&gt; WeatherService[\ud83d\udc0d WeatherService]\n    WeatherService --&gt; Route[\ud83c\udf0e /weather/forecast]\n    F[\ud83c\udfed HttpClient] --&gt; WeatherService</code></pre> <p>Tip</p> <p>There will be little <code>+</code> icons in code fragments. You can click on those for more detailed information as to what is happening in that particular line.</p>"},{"location":"getting_started/#1-setup","title":"1. Setup","text":"<p>Install wireup using pip or your favorite package manager.</p> <pre><code>$ pip install wireup\n</code></pre> <p>The first step is to create a container.</p> container.py<pre><code>import wireup\n\ncontainer = wireup.create_async_container(\n    # Parameters are an optional key-value configuration store.\n    # You can inject parameters as necessary by their name where required.\n    parameters={ # (1)!\n        \"redis_url\": os.environ[\"APP_REDIS_URL\"],\n        \"weather_api_key\": os.environ[\"APP_WEATHER_API_KEY\"],\n    },\n    # Let the container know where service registrations are located.\n    # This is a list of top-level modules Wireup should scan for service declarations.\n    service_modules=[services]  # (2)!\n)\n</code></pre> <ol> <li> <p>Parameters are configuration your application needs.     Such as an api key, database url, or other settings.</p> <p>You can inject them as necessary by their name (dict key) where required. Wireup won't pull things from the environment or other places for you. You need to expose to it the different settings you'll need.</p> <p>You don't have to use this if you prefer using things like pydantic-settings, but it will enable you to have self-contained service definitions without writing additional set-up code to create these objects.</p> <p>Note that the values can be literally anything you need to inject and not just int/strings or other scalars. You can put dataclasses for example in the parameters to inject structured configuration.</p> </li> <li> <p>Service modules is a list of top-level python modules containing service definitions this container     needs to know about (Classes or functions decorated with <code>@service</code> or <code>@abstract</code>.).     The container will only create types that are explicitly registered with it.</p> </li> </ol> <p>Container variants: Sync and Async</p> <p>Wireup includes two types of containers: async and sync. The difference is that the async one exposes <code>async def</code> methods for the common operations and is capable of creating resources from <code>async def</code> factories.</p> <p>The async container can create both regular and resources from async factories.</p> <p>If you don't use async in your code you should create a container via <code>wireup.create_sync_container</code>. Some integrations that Wireup provides also require you to create containers of a given type. E.g: FastAPI integration only supports async containers.</p> Read: Global variables <p>Using this approach means relying on global state, which ties your application to a single container instance.  This might be sufficient for you and that's okay but, if you want to avoid global state, it's better to create  the container within your application factory and store it in your application's state instead.</p>"},{"location":"getting_started/#2-define-services","title":"2. Define services","text":"<p>The container uses types and annotations to define services and the discover dependencies between them. This results in self-contained service declarations without having to create factories for every service.</p>"},{"location":"getting_started/#keyvaluestore","title":"\ud83d\udc0d <code>KeyValueStore</code>","text":"<p>To create <code>KeyValueStore</code>, all we need is the <code>redis_url</code> parameter. The <code>@service</code> decorator tells Wireup this is a service, and we need to tell the container via annotated types to fetch the value of the <code>redis_url</code> parameter for <code>dsn</code>. </p> services/key_value_store.py<pre><code>from wireup import service, Inject\nfrom typing_extensions import Annotated\n\n@service  #(1)!\nclass KeyValueStore:\n    def __init__(self, dsn: Annotated[str, Inject(param=\"redis_url\")]) -&gt; None:  #(2)!\n        self.client = redis.from_url(dsn)\n</code></pre> <ol> <li>Decorators are only used to collect metadata.      This makes testing simpler, as you can still instantiate this like a regular class in your tests.</li> <li>Since type-based injection is not possible here (there can be many string/int parameters after all),      parameters must be annotated with the <code>Inject(param=name)</code> syntax. This tells the container which parameter to inject.</li> </ol>"},{"location":"getting_started/#aiohttpclientsession","title":"\ud83c\udfed <code>aiohttp.ClientSession</code>","text":"<p>The http client making requests cannot be instantiated directly as we need to enter an async context manager. To accommodate such cases, Wireup allows you to use functions to create dependencies.  These can be sync/async as well as regular or generator functions if cleanup needs to take place.</p> <p>Factories can define their dependencies in the function's signature.</p> <p>When using generator factories make sure to call <code>container.close</code> when the application is terminating for the necessary cleanup to take place.</p> services/factories.py<pre><code>@service\nasync def http_client_factory() -&gt; AsyncIterator[aiohttp.ClientSession]:\n    async with aiohttp.ClientSession() as client:\n        yield client\n</code></pre>"},{"location":"getting_started/#weatherservice","title":"\ud83d\udc0d <code>WeatherService</code>","text":"<p>Creating <code>WeatherService</code> is also straightforward. The <code>@service</code> decorator is used to let Wireup know this is a service and we use the same syntax as above for the <code>api_key</code>. </p> <p>Class dependencies do not need additional annotations, even though the http client is created via an async generator. This is transparently handled by the container.</p> services/weather_service.py<pre><code>@service\nclass WeatherService:\n    def __init__(\n        self,\n        api_key: Annotated[str, Inject(param=\"weather_api_key\")], #(1)!\n        kv_store: KeyValueStore, #(2)!\n        client: aiohttp.ClientSession, #(3)!\n    ) -&gt; None: ...\n</code></pre> <ol> <li>Same as above, weather api key needs the parameter name for the container to inject it.</li> <li><code>KeyValueStore</code> can be injected only by type and does not require annotations.</li> <li><code>aiohttp.ClientSession</code> can be injected only by type and requires no additional configuration.</li> </ol>"},{"location":"getting_started/#3-use","title":"3. Use","text":"<p>All that's left now is to retrieve services from the container.</p> Service LocatorInjection via decoratorFastAPIFlaskDjango <p>To fetch services from the container, call <code>.get</code> on the container instance with the type you wish to retrieve.</p> views/posts.py<pre><code>@app.get(\"/weather/forecast\")\nasync def get_forecast():\n    weather_service = await container.get(WeatherService)\n    return await weather_service.get_forecast(...)\n</code></pre> <p>You can also apply Wireup containers as decorators. See Apply the container as a decorator docs for more info, but the end result is that you can decorate any function and specify dependencies to inject in it's signature.</p> views/posts.py<pre><code>from wireup import Injected, inject_from_container\n\n@app.get(\"/weather/forecast\")\n@inject_from_container(container)\nasync def get_forecast(weather_service: Injected[WeatherService]):\n    return await weather_service.get_forecast(...)\n</code></pre> <p>With the FastAPI integration you can just declare dependencies in http or websocket routes.</p> views/posts.py<pre><code>from wireup import Injected\n\n@app.get(\"/weather/forecast\")\nasync def get_forecast(weather_service: Injected[WeatherService]):\n    return await weather_service.get_forecast(...)\n</code></pre> <p>Learn More: FastAPI Integration.</p> <p>With the Flask integration you can just declare dependencies in views.</p> views/posts.py<pre><code>from wireup import Injected\n\n@app.get(\"/weather/forecast\")\nasync def get_forecast(weather_service: Injected[WeatherService]):\n    return await weather_service.get_forecast(...)\n</code></pre> <p>Learn More: Flask Integration.</p> <p>With the Django integration you can just declare dependencies in views. The integration provides support for async views, regular views as well as class-based views.</p> views/posts.py<pre><code>from wireup import Injected\n\nasync def get_forecast(weather_service: Injected[WeatherService]):\n    return await weather_service.get_forecast(...)\n</code></pre> <p>Learn More: Django Integration.</p>"},{"location":"getting_started/#35-integrate","title":"3.5 Integrate","text":"<p>While Wireup is framework-agnostic, usage can be simplified when using it alongside one of the integrations. Key benefits of the integrations are:</p> <ul> <li>Automatic injection in routes without having to do <code>container.get</code> or use decorators.</li> <li>Lifecycle management and access to request-scoped dependencies.</li> <li>Eliminates the need for a global container variable as containers are bound to the application instance.</li> <li>Other goodies specific for that particular framework.</li> </ul>"},{"location":"getting_started/#integrations","title":"Integrations","text":"<ul> <li> AIOHTTP</li> <li> Click</li> <li> Django</li> <li> FastAPI</li> <li> Flask</li> <li> Starlette</li> </ul>"},{"location":"getting_started/#4-test","title":"4. Test","text":"<p>Wireup does not patch your services, which means they can be instantiated and tested independently of the container.</p> <p>To substitute dependencies on targets such as views in a web application you can override dependencies with new ones on the fly.</p> <pre><code>with container.override.service(WeatherService, new=test_weather_service):\n    response = client.get(\"/weather/forecast\")\n</code></pre> <p>Requests to inject <code>WeatherService</code> during the lifetime of the context manager  will result in <code>test_weather_service</code> being injected instead.</p>"},{"location":"getting_started/#conclusion","title":"Conclusion","text":"<p>This concludes the \"Getting Started\" walkthrough, covering the most common dependency injection use cases.</p> <p>Info</p> <ul> <li>Wireup can perform injection on both sync and async targets.</li> <li>If you need to create multiple containers, every container you create is separate from the rest and has its own state.</li> </ul>"},{"location":"getting_started/#next-steps","title":"Next Steps","text":"<ul> <li>Services</li> <li>Parameters</li> <li>Factories</li> </ul>"},{"location":"interfaces/","title":"Interface Injection","text":"<p>You can use abstract classes as interfaces when you need to inject dependencies. This pattern is particularly useful for testing, as it allows you to create mock implementations.</p>"},{"location":"interfaces/#basic-usage","title":"Basic Usage","text":"<p>Register a class as an interface using the <code>@abstract</code> decorator. Then implement and register concrete classes that inherit from it. Note that the class marked with <code>@abstract</code> doesn't actually have to inherit <code>abc.ABC</code>.</p> <pre><code>from wireup import abstract, container, service\n\n\n@abstract\nclass Engine(abc.ABC):\n    @abc.abstractmethod\n    def get_type(self) -&gt; EngineType:\n        raise NotImplementedError\n\n\n@service\nclass CombustionEngine(Engine):\n    @override\n    def get_type(self) -&gt; EngineType:\n        return EngineType.COMBUSTION\n\n\n@wireup.inject_from_container(container)\ndef target(engine: Engine):\n    engine_type = engine.get_type()  # Returns EngineType.COMBUSTION\n</code></pre>"},{"location":"interfaces/#multiple-implementations","title":"Multiple Implementations","text":"<p>Use qualifiers to distinguish between different implementations of the same interface:</p> <pre><code>@service(qualifier=\"electric\")\nclass ElectricEngine(Engine):\n    def get_type(self):\n        return EngineType.ELECTRIC\n\n\n@service(qualifier=\"combustion\")\nclass CombustionEngine(Engine):\n    def get_type() -&gt; EngineType:\n        return EngineType.COMBUSTION\n\n\n@wireup.inject_from_container(container)\ndef target(\n    electric: Annotated[Engine, Inject(qualifier=\"electric\")],\n    combustion: Annotated[Engine, Inject(qualifier=\"combustion\")],\n):\n    ...\n</code></pre> <p>Tip</p> <p>Qualifiers can be any hashable value, including enum members.</p>"},{"location":"interfaces/#default-implementation","title":"Default Implementation","text":"<p>To set a default implementation, register one class without a qualifier:</p> <pre><code>@service  # Default implementation\nclass ElectricEngine(Engine):\n    pass\n\n@service(qualifier=\"combustion\")\nclass CombustionEngine(Engine):\n    pass\n</code></pre> <p>When injecting <code>Engine</code> without a qualifier, the container will use the default implementation (<code>ElectricEngine</code> in this example). Use qualifiers to access other implementations.</p>"},{"location":"lifetimes_and_scopes/","title":"Lifetimes &amp; Scopes","text":"<p>Wireup controls how long service instances live and when they're shared through lifetimes and scopes.</p>"},{"location":"lifetimes_and_scopes/#service-lifetimes","title":"Service Lifetimes","text":"<p>Configure how long service instances live using the <code>lifetime</code> parameter in the <code>@service</code> decorator.</p>"},{"location":"lifetimes_and_scopes/#singleton-default","title":"Singleton (Default)","text":"<p>One instance is created and shared across the entire application:</p> <pre><code>@service  # lifetime=\"singleton\" is the default\nclass Database:\n    def __init__(self): ...\n\n# Same instance everywhere\ndb1 = container.get(Database)  # Instance created\ndb2 = container.get(Database)  # Reuses instance\nassert db1 is db2  # True\n</code></pre>"},{"location":"lifetimes_and_scopes/#scoped","title":"Scoped","text":"<p>One instance per scope, shared within that scope:</p> <pre><code>@service(lifetime=\"scoped\")\nclass RequestContext:\n    def __init__(self):\n        self.request_id = uuid.uuid4()\n\nwith container.enter_scope() as scope1:\n    ctx1 = scope1.get(RequestContext)\n    ctx2 = scope1.get(RequestContext)\n    assert ctx1 is ctx2  # Same instance within scope\n\nwith container.enter_scope() as scope2:\n    ctx3 = scope2.get(RequestContext)\n    assert ctx1 is not ctx3  # Different instance in different scope\n</code></pre>"},{"location":"lifetimes_and_scopes/#transient","title":"Transient","text":"<p>Creates a new instance on every resolution:</p> <pre><code>@service(lifetime=\"transient\")\nclass MessageBuilder:\n    def __init__(self):\n        self.timestamp = time.time()\n\nwith container.enter_scope() as scope:\n    builder1 = scope.get(MessageBuilder)\n    builder2 = scope.get(MessageBuilder)\n    assert builder1 is not builder2  # Always different instances\n</code></pre> <p>Scope Required</p> <p>Only singletons may be resolved using the base container instance. Scoped and Transient dependencies must be resolved within a scope to ensure proper cleanup of resources.</p> <p>Singleton dependencies will be cleaned up when the container's <code>.close()</code> method is called.</p>"},{"location":"lifetimes_and_scopes/#lifetime-summary","title":"Lifetime Summary","text":"Lifetime Instance Creation Shared Within Best For Singleton Once per container Entire application Configuration, database connections, caching Scoped Once per scope Current scope only Request state, transactions, user sessions Transient Every resolution Never shared Stateless services, temporary objects"},{"location":"lifetimes_and_scopes/#working-with-scopes","title":"Working with Scopes","text":"<p>Scopes provide isolated dependency contexts, particularly useful for web applications where you want fresh instances per request.</p>"},{"location":"lifetimes_and_scopes/#creating-scopes","title":"Creating Scopes","text":"SynchronousAsynchronous <pre><code>container = wireup.create_sync_container(services=[RequestService])\n\nwith container.enter_scope() as scoped_container:\n    service1 = scoped_container.get(RequestService)\n    service2 = scoped_container.get(RequestService)\n    # service1 and service2 are the same instance (if scoped lifetime)\n\nwith container.enter_scope() as another_scope:\n    service3 = another_scope.get(RequestService)\n    # service3 is a different instance from service1/service2\n</code></pre> <pre><code>container = wireup.create_async_container(services=[RequestService])\n\nasync with container.enter_scope() as scoped_container:\n    service1 = await scoped_container.get(RequestService)\n    service2 = await scoped_container.get(RequestService)\n</code></pre>"},{"location":"lifetimes_and_scopes/#automatic-scope-management","title":"Automatic Scope Management","text":"<p>Web Framework Integrations:</p> <p>The provided integrations automatically create a scope for every request.</p> <pre><code>@app.get(\"/users/me\")\ndef get_current_user(auth: Injected[AuthService]):\n    return auth.current_user()  # Fresh scoped services per request\n</code></pre> <p>Function Decorator:</p> <p>The <code>@wireup.inject_from_container</code> decorator will also enter a new scope if none is provided in the parameters.</p> <pre><code>@wireup.inject_from_container(container)\ndef process_order(order_service: OrderService):\n    # Scope automatically created and cleaned up\n    return order_service.process()\n</code></pre>"},{"location":"lifetimes_and_scopes/#resource-cleanup","title":"Resource Cleanup","text":"<p>Scoped containers automatically clean up resources when the scope exits:</p> <pre><code>@service(lifetime=\"scoped\")\ndef database_session() -&gt; Iterator[Session]:\n    session = Session()\n    try:\n        yield session\n        session.commit()\n    except Exception:\n        session.rollback()\n        raise\n    finally:\n        session.close()\n\nwith container.enter_scope() as scope:\n    session = scope.get(Session)\n    # session.close() is automatically called when exiting this \"with\" block\n</code></pre> <p>When using generator factories with scoped lifetime, errors that occur anywhere within the scope are automatically propagated to the factories for proper error handling like rolling back database transactions.</p>"},{"location":"lifetimes_and_scopes/#dependency-rules-choosing-lifetimes","title":"Dependency Rules &amp; Choosing Lifetimes","text":"<p>Services have restrictions on what they can depend on based on their lifetime:</p> <ul> <li>Singletons can only depend on other singletons and parameters</li> <li>Scoped services can depend on singletons, other scoped services, and parameters  </li> <li>Transient services can depend on any lifetime and parameters</li> </ul>"},{"location":"multiple_registrations/","title":"Multiple Service Registrations","text":"<p>Use factories to register multiple instances of the same class with different qualifiers. This is useful for scenarios where you need multiple configurations of the same service type.</p>"},{"location":"multiple_registrations/#example-multi-database-setup","title":"Example: Multi-Database Setup","text":"<p>Here's how to set up multiple database connections - a common scenario where you have a primary database for writes and a replica for reads.</p>"},{"location":"multiple_registrations/#registration","title":"Registration","text":"db_service.py<pre><code>from typing import Annotated\nfrom wireup import service, Inject\n\nclass DatabaseService:\n    def __init__(self, dsn: str) -&gt; None:\n        self.__connection = ...  # Connection initialization\n\n    def query(self) -&gt; ...:\n        return self.__connection.query(...)\n\n@service  # Default connection for writes\ndef primary_db(\n    dsn: Annotated[str, Inject(param=\"PRIMARY_DB_DSN\")]\n) -&gt; DatabaseService:\n    return DatabaseService(dsn)\n\n@service(qualifier=\"replica\")  # Read-only connection\ndef replica_db(\n    dsn: Annotated[str, Inject(param=\"REPLICA_DB_DSN\")]\n) -&gt; DatabaseService:\n    return DatabaseService(dsn)\n</code></pre>"},{"location":"multiple_registrations/#usage","title":"Usage","text":"repository.py<pre><code>@service\nclass Repository:\n    def __init__(\n        self,\n        primary: DatabaseService,  # Default connection\n        replica: Annotated[DatabaseService, Inject(qualifier=\"replica\")],\n    ): ...\n\n    def save(self, data: dict) -&gt; None:\n        return self.primary.query(...)  # Write operations\n\n    def get(self, id: int) -&gt; dict:\n        return self.replica.query(...)  # Read operations\n</code></pre> <p>The container will inject the appropriate database connection based on whether a qualifier is specified.</p>"},{"location":"parameters/","title":"Configuration Parameters","text":"<p>Wireup containers can store configuration parameters that services can inject. This enables self-contained service definition without having to create factories for every service.</p>"},{"location":"parameters/#setting-up-parameters","title":"Setting up parameters","text":"<p>When creating a container, provide a dictionary of configuration parameters.</p> <pre><code>import wireup\n\ncontainer = wireup.create_sync_container(\n    parameters={\n        \"database_url\": \"postgresql://localhost:5432/app\",\n        \"env\": \"production\",\n        \"debug_mode\": True,\n        \"max_connections\": 100,\n        \"allowed_hosts\": [\"localhost\", \"example.com\"]\n    }\n)\n</code></pre>"},{"location":"parameters/#injecting-parameters","title":"Injecting parameters","text":""},{"location":"parameters/#by-name","title":"By name","text":"<p>Inject a specific parameter by name using <code>Inject(param=\"parameter_name\")</code>:</p> <pre><code>from typing import Annotated\nfrom wireup import service, Inject\n\n@service\nclass DatabaseService:\n    def __init__(\n        self,\n        url: Annotated[str, Inject(param=\"database_url\")],\n        max_connections: Annotated[int, Inject(param=\"max_connections\")]\n    ) -&gt; None:\n        self.url = url\n        self.max_connections = max_connections\n</code></pre>"},{"location":"parameters/#using-expressions","title":"Using expressions","text":"<p>Create dynamic configuration values by interpolating parameters using <code>${parameter_name}</code> syntax:</p> <pre><code>@service\nclass FileStorageService:\n    def __init__(\n        self, \n        upload_path: Annotated[str, Inject(expr=\"/tmp/uploads/${env}\")]\n    ) -&gt; None:\n        # upload_path = \"/tmp/uploads/production\"\n        self.upload_path = upload_path\n</code></pre> <p>Expression results are strings</p> <p>Parameter expressions always return strings. Non-string parameters are converted using <code>str()</code> before interpolation.</p> <p>For more complex configuration scenarios or to keep domain objects free of annotations, see the Annotation-Free Architecture guide.</p>"},{"location":"services/","title":"Services","text":"<p>A service in Wireup is any class or function decorated with <code>@service</code>.  Services can live anywhere but must be registered with the container.</p> <p>For information about registering services, see the Container documentation.</p>"},{"location":"services/#class-services","title":"Class Services","text":"<p>The simplest way to define a service is with a class:</p> <pre><code>from wireup import service\n\n@service\nclass VehicleRepository: ...\n\n@service\nclass RentalService:\n    # VehicleRepository is automatically injected\n    def __init__(self, repository: VehicleRepository) -&gt; None: ...\n</code></pre>"},{"location":"services/#factory-services","title":"Factory Services","text":"<p>For complex initialization logic or resource management, wireup supports factories that can handle setup and cleanup operations. See the Factory Functions documentation for detailed information on creating and using factory services.</p>"},{"location":"services/#dependency-resolution","title":"Dependency Resolution","text":"<p>Wireup uses type annotations to resolve dependencies. Factory name and parameter names are for readability only.</p> <pre><code># These are equivalent:\n@service\ndef rental_service_factory(repo: VehicleRepository) -&gt; RentalService:\n    return RentalService(repo)\n\n@service\ndef make_rental_service(vehicle_store: VehicleRepository) -&gt; RentalService:\n    return RentalService(vehicle_store)\n</code></pre>"},{"location":"testing/","title":"Testing","text":"<p>Unit testing service objects is meant to be easy as the container does not interfere in any way with the underlying classes.</p> <p>Classes can be instantiated as usual in tests, and you need to pass dependencies  such as services or parameters to them yourself.</p> <p>To specify custom behavior for tests, provide a custom implementation  or a subclass that returns test data.</p>"},{"location":"testing/#overriding","title":"Overriding","text":"<p>Sometimes you need to be able to swap a service object on the fly for a different one such as a mock.</p> <p>The <code>container.override</code> property provides access to a number of useful methods and context managers which help with overriding dependencies  (See override manager).</p> <p>Good to know</p> <ul> <li>Overriding only applies to future injections.</li> <li>Once a singleton service has been instantiated, it is not possible to directly replace any of its direct or transitive dependencies via overriding as the object is already in memory.</li> <li>When injecting interfaces and/or qualifiers, override the interface and/or qualifier  rather than the implementation that will be injected.</li> </ul> <p>Tip</p> <p>If you're using an integration to get the container instance you can use the <code>wireup.integration.xxx.get_app_container</code>  method. This returns the container associated with your application.</p>"},{"location":"testing/#context-manager","title":"Context Manager","text":"<pre><code>random_mock = MagicMock()\n# Chosen by fair dice roll. Guaranteed to be random.\nrandom_mock.get_random.return_value = 4\n\nwith container.override.service(target=RandomService, new=random_mock):\n    # Assuming in the context of a web app:\n    # /random endpoint has a dependency on RandomService\n    # requests to inject RandomService during the lifetime\n    # of this context manager will result in random_mock being injected instead.\n    response = client.get(\"/random\")\n</code></pre>"},{"location":"testing/#pytest","title":"Pytest","text":"app.py<pre><code>def create_app():\n    app = ...\n\n    container = wireup.create_container(...)\n    # Example shows FastAPI but any integration will work the same.\n    wireup.integration.fastapi.setup(container, app)\n\n    return app\n</code></pre> conftest.py<pre><code># This is a function scoped fixture which means \n# you'll get a fresh copy of the application and container every time.\n@pytest.fixture\ndef app():\n    return create_app()\n</code></pre> some_test_file.py<pre><code>from wireup.integration.fastapi import get_app_container\n\ndef test_something_with_mocked_db_service(client: TestClient, app):\n    with get_app_container(app).override.service(DBService, new=...):\n        response = client.get(\"/some/path\")\n\n    # Assert response and mock calls.\n</code></pre>"},{"location":"tips_tricks/","title":"Tips & Tricks","text":"<p>Reduce init boilerplate</p> <p>When building services with multiple dependencies, <code>__init__</code> methods may become repetitive. Combine the <code>@service</code> decorator with Python's <code>@dataclass</code> to eliminate initialization boilerplate.</p> <p>Depending on class definitions some classes may benefit in readability from this more than others. Apply best judgement here.</p> BeforeAfterCounter-example services/order_processor.py<pre><code>@service\nclass OrderProcessor:\n    def __init__(\n        self,\n        payment_gateway: PaymentGateway,\n        inventory_service: InventoryService,\n        order_repository: OrderRepository,\n    ):\n        self.payment_gateway = payment_gateway\n        self.inventory_service = inventory_service\n        self.order_repository = order_repository\n</code></pre> services/order_processor.py<pre><code>from dataclasses import dataclass\n\n@service\n@dataclass\nclass OrderProcessor:\n    payment_gateway: PaymentGateway\n    inventory_service: InventoryService\n    order_repository: OrderRepository\n</code></pre> <pre><code>@service\n@dataclass\nclass Foo:\n    FOO_CONST = 1  # Not added to __init__ by @dataclass.\n    logger = logging.getLogger(__name__)  # Not added to __init__ by @dataclass.\n\n    # These will be added to __init__ by @dataclass\n    # and marked as dependencies by Wireup.\n    payment_gateway: PaymentGateway\n    inventory_service: InventoryService\n    order_repository: OrderRepository\n</code></pre> <p>In this example, due to how the <code>@dataclass</code> decorator works, combining the two leads to code that's more difficult to read, since it's not immediately what are dependencies and what are class fields.</p> <p>Aliased parameters</p> <p>If you don't like having string parameters in your service objects you can alias them instead.</p> BeforeAfter <pre><code>def list_users(env: Annotated[str, Inject(param=\"env\")]) -&gt; None: ...\ndef get_users(env: Annotated[str, Inject(param=\"env\")]) -&gt; None: ...\n</code></pre> <pre><code>EnvParameter = Annotated[str, Inject(param=\"env\")]\n\ndef list_users(env: EnvParameter) -&gt; None: ...\ndef get_users(env: EnvParameter) -&gt; None: ...\n</code></pre> <p>Eager loading</p> <p>By default, Wireup creates services lazily when they're first requested, but for singleton services that are expensive to create, you can pre-initialize them during application startup to avoid delays and ensure consistent response times when handling requests.</p> Application SetupML Model Service main.py<pre><code>from wireup import Injected\nimport contextlib\nimport wireup.integration.fastapi\nimport wireup.integration.fastapi import get_app_container\nimport wireup\n\n@contextlib.asynccontextmanager\nasync def lifespan(app: FastAPI):\n    container = get_app_container(app)\n\n    # Pre-initialize expensive singletons during startup\n    await container.get(MLModelService)\n\n    yield\n\ncontainer = wireup.create_async_container(...)\napp = FastAPI(lifespan=lifespan)\nwireup.integration.fastapi.setup(container, app)\n\n\n@app.post(\"/users/{user_id}/recommendations\")\nasync def get_recommendations(\n    ml_service: Injected[MLModelService], \n    user_id: str\n):\n    # ML model is already loaded - no delays!\n    return ml_service.predict(user_id)\n</code></pre> <pre><code>import pickle\nfrom wireup import service\n\n@service\nclass MLModelService:\n    \"\"\"Machine learning model that takes time to load\"\"\"\n    def __init__(self):\n        # Load large model file from disk (expensive operation)\n        self.model = self._load_model()\n\n    def _load_model(self):\n        # Simulate loading a large ML model\n        import pickle\n        with open(\"models/large_recommendation_model.pkl\", \"rb\") as f:\n            return pickle.load(f)\n</code></pre> <p>Null Object Pattern for Optional Dependencies</p> <p>Instead of adding conditional checks throughout your code, use the pattern to handle optional dependencies cleanly. It involves creating a noop implementation that can be used when the real implementation is not available.</p> services/cache.py<pre><code>from wireup import abstract, service\nfrom typing import Any\n\nclass Cache(Protocol):\n    def get(self, key: str) -&gt; Any | None: ...\n    def set(self, key: str, value: str) -&gt; None: ...\n\nclass RedisCache: ...  # Real Redis implementation\n\nclass NullCache:\n    def get(self, key: str) -&gt; Any | None:\n        return None  # Always cache miss\n    def set(self, key: str, value: str) -&gt; None:\n        return None  # Do nothing\n\n@service\ndef cache_factory(\n    redis_url: Annotated[str | None, Inject(param=\"redis_url\")],\n) -&gt; Cache:\n    return RedisCache(redis_url) if redis_url else NullCache()\n</code></pre> <p>Usage</p> Before: Optional DependenciesAfter: Null Pattern <pre><code>@service\nclass UserService:\n    def __init__(self, cache: Cache | None):\n        self.cache = cache\n\n    def get_user(self, user_id: str) -&gt; User:\n        # Guard required\n        if self.cache and (cached := self.cache.get(f\"user:{user_id}\")):\n            return User.from_json(cached)\n\n        user = self.db.get_user(user_id)\n\n        # Guard required\n        if self.cache:\n            self.cache.set(f\"user:{user_id}\", user.to_json())\n\n        return user\n</code></pre> <pre><code>@service\nclass UserService:\n    def __init__(self, cache: Cache):\n        self.cache = cache  # Always a Cache instance\n\n    def get_user(self, user_id: str) -&gt; User:\n        if cached := self.cache.get(f\"user:{user_id}\"):\n            return User.from_json(cached)\n\n        user = self.db.get_user(user_id) \n        self.cache.set(f\"user:{user_id}\", user.to_json())\n        return user\n</code></pre>"},{"location":"upgrading/","title":"Upgrading","text":""},{"location":"upgrading/#upgrade-1x-to-200","title":"Upgrade 1.x to 2.0.0","text":"<ul> <li>Wireup container itself has no breaking changes. The major version bump is due to a breaking change in the FastAPI integration.</li> <li>Added new <code>middleware_mode</code> parameter to the <code>wireup.integration.fastapi.setup</code> call. Default value is <code>False</code>, Wireup 1.x behavior is the equivalent of <code>middleware_mode=True</code>. See FastAPI integration docs for when to enable this setting.</li> </ul>"},{"location":"upgrading/#upgrade-0160-to-10","title":"Upgrade 0.16.0 to 1.0","text":"<p>With the API now stable, deprecated features have been removed. Refer to the deprecation notices for upgrade guidance.</p>"},{"location":"upgrading/#removed-wireupdependencycontainer","title":"Removed <code>wireup.DependencyContainer</code>","text":"<p>The previous container was overly complex. It has been split into <code>wireup.SyncContainer</code> and <code>wireup.AsyncContainer</code>.</p> <p>Use <code>wireup.AsyncContainer</code> if you need to create async dependencies, as it supports both sync and async resources.</p> <p>Changes include:</p> <ul> <li>Removed <code>@container.register</code><ul> <li>Use <code>@service</code> on services or factories and specify the container during creation with <code>wireup.create_sync_container</code> or <code>wireup.create_async_container</code>.</li> </ul> </li> <li>Removed <code>@container.abstract</code><ul> <li>Similar to above, use the <code>@abstract</code> decorator.</li> </ul> </li> <li>Removed <code>@container.autowire</code><ul> <li>This is removed. See the Apply the container as a decorator docs for details.</li> </ul> </li> <li>Removed <code>container.has_type</code>.</li> <li><code>wireup.create_container</code> is now <code>wireup.create_sync_container</code> and <code>wireup.create_async_container</code>.</li> </ul>"},{"location":"upgrading/#removed-get_all-put-methods-of-parameterbag","title":"Removed get_all, put methods of <code>ParameterBag</code>.","text":"<p><code>ParameterBag</code> does not support mutations. Pass all parameters when creating the container.</p>"},{"location":"upgrading/#removed-support-for-default-values","title":"Removed support for default values","text":"<p>Using <code>foo: str = Inject(...)</code> is no longer supported. Use annotated types instead: <code>foo: Annotated[str, Inject(...)]</code>.</p>"},{"location":"upgrading/#removed-parameterenum","title":"Removed ParameterEnum","text":"<p><code>ParameterEnum</code> is removed. Use type definitions for parameters: <code>AppNameParameter = Annotated[str, Inject(name=\"app_name\")]</code>.</p>"},{"location":"upgrading/#removed-wire-wire","title":"Removed <code>Wire</code>, <code>wire</code>","text":"<p>Replace <code>Wire</code> or <code>wire</code> with <code>Inject</code>.</p>"},{"location":"upgrading/#removed-wireupcontainer-global","title":"Removed <code>wireup.container</code> global","text":"<p>The global <code>wireup.container</code> is removed. Create a container instance with <code>wireup.create_sync_container</code> or <code>wireup.create_async_container</code>.</p>"},{"location":"upgrading/#removed-warmup_container","title":"Removed <code>warmup_container</code>","text":"<p>This utility function is removed. Create a container instance with <code>wireup.create_sync_container</code> or <code>wireup.create_async_container</code>.</p>"},{"location":"upgrading/#removed-old-integrations","title":"Removed old integrations","text":"<p><code>wireup.integrations.flask_integration</code> is replaced by <code>wireup.integrations.flask</code>. <code>wireup.integrations.fastapi_integration</code> is replaced by <code>wireup.integrations.fastapi</code>.</p>"},{"location":"upgrading/#removed-initialize_container","title":"Removed <code>initialize_container</code>","text":"<p>This utility function is removed. Create a container instance with <code>wireup.create_sync_container</code> or <code>wireup.create_async_container</code>.</p>"},{"location":"upgrading/#removed-register_all_in_module","title":"Removed <code>register_all_in_module</code>","text":"<p>This utility function is removed. Register services by passing <code>service_modules</code> to <code>wireup.create_*_container</code>.</p>"},{"location":"upgrading/#removed-load_module","title":"Removed <code>load_module</code>","text":"<p>No direct replacement. Create a container instance with <code>wireup.create_sync_container</code> or <code>wireup.create_async_container</code>.</p>"},{"location":"upgrading/#removed-factoryduplicateserviceregistrationerror","title":"Removed <code>FactoryDuplicateServiceRegistrationError</code>","text":"<p>Use <code>DuplicateServiceRegistrationError</code>.</p>"},{"location":"upgrading/#removed-servicelifetime-enum-in-favor-of-literals","title":"Removed <code>ServiceLifetime</code> enum in favor of literals","text":"<p>Replace <code>ServiceLifetime.SINGLETON</code> with <code>\"singleton\"</code> and <code>ServiceLifetime.TRANSIENT</code> with <code>\"transient\"</code>.</p>"},{"location":"upgrading/#django-integration","title":"Django Integration","text":"<p>The <code>perform_wramup</code> setting is removed.</p>"},{"location":"upgrading/#flask-integration","title":"Flask Integration","text":"<p>The <code>import_flask_config</code> setting is removed. Expose Flask config directly to <code>create_sync_container</code>. See Flask integration docs for details.</p>"},{"location":"upgrading/#fastapi-integration","title":"FastAPI Integration","text":"<p>The integration no longer automatically exposes <code>fastapi.Request</code> as a Wireup dependency. Pass <code>wireup.integration.fastapi</code> in your service modules when creating a container if needed.</p>"},{"location":"versioning/","title":"Versioning Policy","text":"<p>Wireup follows Semantic Versioning (SemVer) to provide clear expectations about version compatibility.</p>"},{"location":"versioning/#version-numbers","title":"Version Numbers","text":"<p>Each version number follows the format <code>MAJOR.MINOR.PATCH</code>:</p> <ul> <li>MAJOR: Increments for backward-incompatible changes</li> <li>MINOR: Increments for new features (backward-compatible)</li> <li>PATCH: Increments for bug fixes (backward-compatible)</li> </ul>"},{"location":"versioning/#pre-release-versions-0xx","title":"Pre-release Versions (0.x.x)","text":"<p>Versions starting with <code>0</code> (e.g., <code>0.1.0</code>) are considered pre-release. During this phase:</p> <ul> <li>The API is considered unstable</li> <li>Minor version updates may include breaking changes</li> <li>Use version constraint <code>0.x.*</code> to receive bug fixes while avoiding breaking changes</li> </ul>"},{"location":"versioning/#public-api-definition","title":"Public API Definition","text":"<p>The following components constitute Wireup's public API:</p> <ol> <li>All direct exports from the <code>wireup</code> package</li> <li>All public members and interfaces of the exported objects</li> </ol> <p>Changes to these components are subject to semantic versioning rules.</p>"},{"location":"class/aiohttp_integration/","title":"AIOHTTP","text":""},{"location":"class/aiohttp_integration/#wireup.integration.aiohttp-classes","title":"Classes","text":""},{"location":"class/aiohttp_integration/#wireup.integration.aiohttp-functions","title":"Functions","text":""},{"location":"class/aiohttp_integration/#wireup.integration.aiohttp.aiohttp_request_factory","title":"<code>aiohttp_request_factory()</code>","text":"<p>Provide the current aiohttp request as a dependency.</p> <p>Note that this requires the Wireup-aiohttp integration to be set up.</p>"},{"location":"class/aiohttp_integration/#wireup.integration.aiohttp.get_app_container","title":"<code>get_app_container(app)</code>","text":"<p>Return the container associated with the given AIOHTTP application.</p>"},{"location":"class/aiohttp_integration/#wireup.integration.aiohttp.get_request_container","title":"<code>get_request_container()</code>","text":"<p>When inside a request, returns the scoped container instance handling the current request.</p>"},{"location":"class/aiohttp_integration/#wireup.integration.aiohttp.setup","title":"<code>setup(container, app, handlers=None)</code>","text":"<p>Integrate Wireup with AIOHTTP.</p> <p>If you need access to <code>aiohttp.web.Request</code> in your services, add this module to the <code>service_modules</code> in your container's service modules.</p> <p>Parameters:</p> Name Type Description Default <code>container</code> <code>AsyncContainer</code> <p>A Wireup async container.</p> required <code>app</code> <code>Application</code> <p>An AIOHTTP server application.</p> required <code>handlers</code> <code>Optional[Iterable[Type[_WireupHandler]]]</code> <p>A list of Wireup class-based handlers. See: https://maldoinc.github.io/wireup/latest/integrations/aiohttp/class_based_handlers/</p> <code>None</code>"},{"location":"class/click_integration/","title":"Click","text":""},{"location":"class/click_integration/#wireupintegrationclick","title":"wireup.integration.click","text":""},{"location":"class/click_integration/#wireup.integration.click-functions","title":"Functions","text":""},{"location":"class/click_integration/#wireup.integration.click.get_app_container","title":"<code>get_app_container(app)</code>","text":"<p>Retrieve the Wireup container associated with a Click command group.</p>"},{"location":"class/click_integration/#wireup.integration.click.setup","title":"<code>setup(container, command)</code>","text":"<p>Integrate Wireup with Click by injecting dependencies into Click commands.</p> <p>:command: The Click command group to inject dependencies into</p>"},{"location":"class/django_integration/","title":"Django","text":""},{"location":"class/django_integration/#wireup.integration.django-classes","title":"Classes","text":""},{"location":"class/django_integration/#wireup.integration.django.WireupSettings","title":"<code>WireupSettings</code>  <code>dataclass</code>","text":"<p>Class containing Wireup settings specific to Django.</p>"},{"location":"class/django_integration/#wireup.integration.django.WireupSettings-attributes","title":"Attributes","text":""},{"location":"class/django_integration/#wireup.integration.django.WireupSettings.auto_inject_views","title":"<code>auto_inject_views: bool = True</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Whether to automatically inject dependencies into Django views.</p> <p>When True (default), Wireup will automatically inject dependencies into all Django views. When False, you must use the @inject decorator explicitly on views that need injection.</p> <p>Set this to False if you want to use @inject explicitly across all views (useful when mixing core Django views with third-party views like Django REST framework).</p>"},{"location":"class/django_integration/#wireup.integration.django.WireupSettings.service_modules","title":"<code>service_modules: List[Union[str, ModuleType]]</code>  <code>instance-attribute</code>","text":"<p>List of modules containing wireup service registrations.</p>"},{"location":"class/django_integration/#wireup.integration.django-functions","title":"Functions","text":""},{"location":"class/django_integration/#wireup.integration.django.get_app_container","title":"<code>get_app_container()</code>","text":"<p>Return the container instance associated with the current django application.</p>"},{"location":"class/django_integration/#wireup.integration.django.get_request_container","title":"<code>get_request_container()</code>","text":"<p>When inside a request, returns the scoped container instance handling the current request.</p>"},{"location":"class/fastapi_integration/","title":"FastAPI","text":""},{"location":"class/fastapi_integration/#wireupintegrationfastapi","title":"wireup.integration.fastapi","text":""},{"location":"class/fastapi_integration/#wireup.integration.fastapi-classes","title":"Classes","text":""},{"location":"class/fastapi_integration/#wireup.integration.fastapi-functions","title":"Functions","text":""},{"location":"class/fastapi_integration/#wireup.integration.fastapi.get_app_container","title":"<code>get_app_container(app)</code>","text":"<p>Return the container associated with the given application.</p> <p>This is the instance created via <code>wireup.create_async_container</code>. Use this when you need the container outside of the request context lifecycle.</p>"},{"location":"class/fastapi_integration/#wireup.integration.fastapi.get_request_container","title":"<code>get_request_container()</code>","text":"<p>When inside a request, returns the scoped container instance handling the current request.</p> <p>This is what you almost always want.It has all the information the app container has in addition to data specific to the current request.</p>"},{"location":"class/fastapi_integration/#wireup.integration.fastapi.request_factory","title":"<code>request_factory()</code>","text":"<p>Provide the current request as a dependency.</p>"},{"location":"class/fastapi_integration/#wireup.integration.fastapi.setup","title":"<code>setup(container, app, *, class_based_handlers=None, middleware_mode=False)</code>","text":"<p>Integrate Wireup with FastAPI.</p> <p>Setup performs the following: * Injects dependencies into HTTP and WebSocket routes. * Closes the Wireup container upon app shutdown using the lifespan context.</p> <p>Parameters:</p> Name Type Description Default <code>container</code> <code>AsyncContainer</code> <p>An async container created via <code>wireup.create_async_container</code>.</p> required <code>app</code> <code>FastAPI</code> <p>The FastAPI application to integrate with. All routes must have been added to the app before this call.</p> required <code>class_based_handlers</code> <code>Optional[Iterable[Type[_ClassBasedHandlersProtocol]]]</code> <p>A list of class-based handlers to register. These classes must have a <code>router</code> attribute of type <code>fastapi.APIRouter</code>. Warning: Do not include these with fastapi directly.</p> <code>None</code> <code>middleware_mode</code> <code>bool</code> <p>If True, the container is exposed in fastapi middleware. Note, for this to work correctly, there should be no more middleware added after the call to this function.  For more details, visit: https://maldoinc.github.io/wireup/latest/integrations/fastapi/</p> <code>False</code>"},{"location":"class/fastapi_integration/#wireup.integration.fastapi.websocket_factory","title":"<code>websocket_factory()</code>","text":"<p>Provide the current WebSocket as a dependency.</p>"},{"location":"class/flask_integration/","title":"Flask","text":""},{"location":"class/flask_integration/#wireupintegrationflask","title":"wireup.integration.flask","text":""},{"location":"class/flask_integration/#wireup.integration.flask-functions","title":"Functions","text":""},{"location":"class/flask_integration/#wireup.integration.flask.get_app_container","title":"<code>get_app_container(app)</code>","text":"<p>Return the container associated with the given application.</p>"},{"location":"class/flask_integration/#wireup.integration.flask.get_request_container","title":"<code>get_request_container()</code>","text":"<p>Return the container handling the current request.</p>"},{"location":"class/flask_integration/#wireup.integration.flask.setup","title":"<code>setup(container, app)</code>","text":"<p>Integrate Wireup with Flask.</p> <p>Setup performs the following: * Injects dependencies into Flask views. * Creates a new container scope for each request, with a scoped lifetime matching the request duration.</p>"},{"location":"class/override_manager/","title":"OverrideManager","text":"<p>Enables overriding of services registered with the container.</p>"},{"location":"class/override_manager/#wireup.ioc.override_manager.OverrideManager-functions","title":"Functions","text":""},{"location":"class/override_manager/#wireup.ioc.override_manager.OverrideManager.clear","title":"<code>clear()</code>","text":"<p>Clear active service overrides.</p>"},{"location":"class/override_manager/#wireup.ioc.override_manager.OverrideManager.delete","title":"<code>delete(target, qualifier=None)</code>","text":"<p>Clear active override for the <code>target</code> service.</p>"},{"location":"class/override_manager/#wireup.ioc.override_manager.OverrideManager.service","title":"<code>service(target, new, qualifier=None)</code>","text":"<p>Override the <code>target</code> service with <code>new</code> for the duration of the context manager.</p> <p>Future requests to inject <code>target</code> will result in <code>new</code> being injected.</p> <p>Parameters:</p> Name Type Description Default <code>target</code> <code>type</code> <p>The target service to override.</p> required <code>qualifier</code> <code>Qualifier | None</code> <p>The qualifier of the service to override. Set this if service is registered with the qualifier parameter set to a value.</p> <code>None</code> <code>new</code> <code>Any</code> <p>The new object to be injected instead of <code>target</code>.</p> required"},{"location":"class/override_manager/#wireup.ioc.override_manager.OverrideManager.services","title":"<code>services(overrides)</code>","text":"<p>Override a number of services with new for the duration of the context manager.</p>"},{"location":"class/override_manager/#wireup.ioc.override_manager.OverrideManager.set","title":"<code>set(target, new, qualifier=None)</code>","text":"<p>Override the <code>target</code> service with <code>new</code>.</p> <p>Future requests to inject <code>target</code> will result in <code>new</code> being injected.</p> <p>Parameters:</p> Name Type Description Default <code>target</code> <code>type</code> <p>The target service to override.</p> required <code>qualifier</code> <code>Qualifier | None</code> <p>The qualifier of the service to override. Set this if service is registered with the qualifier parameter set to a value.</p> <code>None</code> <code>new</code> <code>Any</code> <p>The new object to be injected instead of <code>target</code>.</p> required"},{"location":"class/parameter_bag/","title":"ParameterBag","text":"<p>Parameter flat key-value store for use with a container.</p> <p>Allows storing and retrieving of parameters in the bag. Templated strings can be used to interpolate a string referencing parameters.</p>"},{"location":"class/parameter_bag/#wireup.ioc.parameter.ParameterBag-functions","title":"Functions","text":""},{"location":"class/parameter_bag/#wireup.ioc.parameter.ParameterBag.__init__","title":"<code>__init__(values=None)</code>","text":"<p>Initialize an empty ParameterBag.</p> <p>ParameterBag holds a flat key-value store of parameter values. __bag: A dictionary to store parameter values. __cache: A cache for interpolated values.</p>"},{"location":"class/parameter_bag/#wireup.ioc.parameter.ParameterBag.get","title":"<code>get(param)</code>","text":"<p>Get the value of a parameter.</p> <p>If the parameter is templated, interpolate it first by replacing placeholders with parameter values.</p> <p>Parameters:</p> Name Type Description Default <code>param</code> <code>ParameterReference</code> <p>The parameter to retrieve.</p> required <p>Returns:</p> Type Description <code>Any</code> <p>The parameter's value.</p>"},{"location":"class/starlette_integration/","title":"Starlette","text":""},{"location":"class/starlette_integration/#wireupintegrationflask","title":"wireup.integration.flask","text":""},{"location":"class/starlette_integration/#wireup.integration.starlette-attributes","title":"Attributes","text":""},{"location":"class/starlette_integration/#wireup.integration.starlette.inject","title":"<code>inject = inject_from_container_unchecked(get_request_container)</code>  <code>module-attribute</code>","text":"<p>Inject dependencies into Starlette endpoints. Decorate your endpoint functions with this to use Wireup's dependency injection and use <code>Injected[T]</code> or <code>Annotated[T, Inject()]</code> to specify dependencies.</p>"},{"location":"class/starlette_integration/#wireup.integration.starlette-classes","title":"Classes","text":""},{"location":"class/starlette_integration/#wireup.integration.starlette-functions","title":"Functions","text":""},{"location":"class/starlette_integration/#wireup.integration.starlette.get_app_container","title":"<code>get_app_container(app)</code>","text":"<p>Return the container associated with the given application.</p> <p>This is the instance created via <code>wireup.create_async_container</code>. Use this when you need the container outside of the request context lifecycle.</p>"},{"location":"class/starlette_integration/#wireup.integration.starlette.get_request_container","title":"<code>get_request_container()</code>","text":"<p>When inside a request, returns the scoped container instance handling the current request.</p> <p>This is what you almost always want.It has all the information the app container has in addition to data specific to the current request.</p>"},{"location":"class/starlette_integration/#wireup.integration.starlette.request_factory","title":"<code>request_factory()</code>","text":"<p>Provide the current request as a dependency.</p>"},{"location":"class/starlette_integration/#wireup.integration.starlette.setup","title":"<code>setup(container, app)</code>","text":"<p>Integrate Wireup with a Starlette application.</p> <p>This sets up the application to use Wireup's dependency injection system and closes the container on application shutdown. Note, for this to work correctly, there should be no more middleware added after the call to this function.</p>"},{"location":"class/starlette_integration/#wireup.integration.starlette.websocket_factory","title":"<code>websocket_factory()</code>","text":"<p>Provide the current WebSocket as a dependency.</p>"},{"location":"class/wireup/","title":"wireup","text":""},{"location":"class/wireup/#wireup","title":"<code>wireup</code>","text":""},{"location":"class/wireup/#wireup-attributes","title":"Attributes","text":""},{"location":"class/wireup/#wireup.Injected","title":"<code>Injected = Annotated[T, Inject()]</code>  <code>module-attribute</code>","text":"<p>Let the Wireup container know it must inject this parameter.</p> <p>Alias of <code>Annotated[T, Inject()]</code>.</p>"},{"location":"class/wireup/#wireup-classes","title":"Classes","text":""},{"location":"class/wireup/#wireup.ParameterBag","title":"<code>ParameterBag</code>","text":"<p>Parameter flat key-value store for use with a container.</p> <p>Allows storing and retrieving of parameters in the bag. Templated strings can be used to interpolate a string referencing parameters.</p>"},{"location":"class/wireup/#wireup.ParameterBag-functions","title":"Functions","text":""},{"location":"class/wireup/#wireup.ParameterBag.__init__","title":"<code>__init__(values=None)</code>","text":"<p>Initialize an empty ParameterBag.</p> <p>ParameterBag holds a flat key-value store of parameter values. __bag: A dictionary to store parameter values. __cache: A cache for interpolated values.</p>"},{"location":"class/wireup/#wireup.ParameterBag.get","title":"<code>get(param)</code>","text":"<p>Get the value of a parameter.</p> <p>If the parameter is templated, interpolate it first by replacing placeholders with parameter values.</p> <p>Parameters:</p> Name Type Description Default <code>param</code> <code>ParameterReference</code> <p>The parameter to retrieve.</p> required <p>Returns:</p> Type Description <code>Any</code> <p>The parameter's value.</p>"},{"location":"class/wireup/#wireup.ServiceOverride","title":"<code>ServiceOverride</code>  <code>dataclass</code>","text":"<p>Data class to represent a service override. Target type will be replaced with the new type by the container.</p>"},{"location":"class/wireup/#wireup-functions","title":"Functions","text":""},{"location":"class/wireup/#wireup.Inject","title":"<code>Inject(*, param=None, expr=None, qualifier=None)</code>","text":"<p>Let the Wireup container know it must inject this parameter.</p> <p>When used without parameters as <code>Annotated[T, Inject()]</code>, you can also use the alias <code>Injected[T]</code>.</p> <p>Parameters:</p> Name Type Description Default <code>param</code> <code>str | None</code> <p>Inject a specific parameter by name.</p> <code>None</code> <code>expr</code> <code>str | None</code> <p>Inject a string value using a templated string. Parameters within <code>${}</code> will be replaced with their corresponding values.</p> <code>None</code> <code>qualifier</code> <code>Qualifier | None</code> <p>Specify which implementation to bind when multiple components implement an interface registered in the container via <code>@abstract</code>.</p> <code>None</code>"},{"location":"class/wireup/#wireup.abstract","title":"<code>abstract(cls)</code>","text":"<p>Mark the decorated class as an abstract service.</p>"},{"location":"class/wireup/#wireup.create_async_container","title":"<code>create_async_container(service_modules=None, services=None, parameters=None)</code>","text":"<p>Create a Wireup container.</p> <p>Parameters:</p> Name Type Description Default <code>service_modules</code> <code>list[ModuleType] | None</code> <p>This is a list of top-level modules containing services registered with <code>@service</code> or <code>@abstract</code>. Wireup will recursively scan the modules and register services found in them.</p> <code>None</code> <code>services</code> <code>list[Any] | None</code> <p>A list of classes or functions decorated with <code>@service</code> or <code>@abstract</code> to register with the container instance. Use this when you want to explicitly list services.</p> <code>None</code> <code>parameters</code> <code>dict[str, Any] | None</code> <p>Dict containing parameters you want to expose to the container. Services or factories can request parameters via the <code>Inject(param=\"name\")</code> syntax.</p> <code>None</code> <p>Raises:</p> Type Description <code>WireupError</code> <p>Raised if the dependencies cannot be fully resolved.</p>"},{"location":"class/wireup/#wireup.create_sync_container","title":"<code>create_sync_container(service_modules=None, services=None, parameters=None)</code>","text":"<p>Create a Wireup container.</p> <p>Parameters:</p> Name Type Description Default <code>service_modules</code> <code>list[ModuleType] | None</code> <p>This is a list of top-level modules containing services registered with <code>@service</code> or <code>@abstract</code>. Wireup will recursively scan the modules and register services found in them.</p> <code>None</code> <code>services</code> <code>list[Any] | None</code> <p>A list of classes or functions decorated with <code>@service</code> or <code>@abstract</code> to register with the container instance. Use this when you want to explicitly list services.</p> <code>None</code> <code>parameters</code> <code>dict[str, Any] | None</code> <p>Dict containing parameters you want to expose to the container. Services or factories can request parameters via the <code>Inject(param=\"name\")</code> syntax.</p> <code>None</code> <p>Raises:</p> Type Description <code>WireupError</code> <p>Raised if the dependencies cannot be fully resolved.</p>"},{"location":"class/wireup/#wireup.inject_from_container","title":"<code>inject_from_container(container, scoped_container_supplier=None, middleware=None)</code>","text":"<p>Inject dependencies into the decorated function based on annotations.</p> <p>Parameters:</p> Name Type Description Default <code>container</code> <code>SyncContainer | AsyncContainer</code> <p>The main container instance created via <code>wireup.create_sync_container</code> or <code>wireup.create_async_container</code>.</p> required <code>scoped_container_supplier</code> <code>Callable[[], ScopedSyncContainer | ScopedAsyncContainer] | None</code> <p>An optional callable that returns the current scoped container instance. If provided, it will be used to create scoped dependencies. If not provided, the container will automatically enter a scope. Provide a scoped_container_supplier if you need to manage the container's scope manually. For example, in web frameworks, you might enter the scope at the start of a request in middleware so that other middlewares can access the scoped container if needed.</p> <code>None</code> <code>middleware</code> <code>Callable[[ScopedSyncContainer | ScopedAsyncContainer, tuple[Any, ...], dict[str, Any]], AbstractContextManager[None]] | None</code> <p>A context manager that wraps the execution of the target function.</p> <code>None</code>"},{"location":"class/wireup/#wireup.service","title":"<code>service(obj=None, *, qualifier=None, lifetime='singleton')</code>","text":"<p>Mark the decorated class or function as a Wireup service.</p>"},{"location":"integrations/","title":"Integrations","text":"<p>Wireup is framework-agnostic and can be used in any project, but it also provides integrations for the following frameworks:</p> <ul> <li> AIOHTTP</li> <li> Click</li> <li> Django</li> <li> FastAPI</li> <li> Flask</li> <li> Starlette</li> </ul>"},{"location":"integrations/aiohttp/","title":"AIOHTTP Integration","text":"<p>Dependency injection for AIOHTTP is available in the <code>wireup.integration.aiohttp</code> module.</p> <ul> <li> <p> Automatic Dependency Management</p> <p>Inject dependencies in routes and automatically manage container lifecycle.</p> </li> <li> <p> Request Objects</p> <p>Use request and websocket objects in Wireup dependencies.</p> </li> <li> <p> Zero Runtime Overhead</p> <p>Inject dependencies with zero runtime overhead in Class-Based Handlers.</p> <p> Learn more</p> </li> <li> <p> Shared business logic</p> <p>Wireup is framework-agnostic. Share the service layer between web applications and other interfaces, such as a CLI.</p> </li> </ul>"},{"location":"integrations/aiohttp/#initialize-the-integration","title":"Initialize the integration","text":"<p>First, create an async container.</p> <pre><code>container = wireup.create_async_container(\n    service_modules=[services],\n    parameters={\"db_dsn\": os.environ.get(\"APP_DB_DSN\")}\n)\n</code></pre> <p>Then initialize the integration:</p> <pre><code>wireup.integration.aiohttp.setup(container, app)\n</code></pre>"},{"location":"integrations/aiohttp/#inject-in-aiohttp-handlers","title":"Inject in AIOHTTP handlers","text":"<p>To inject dependencies, add the type to the handler's signature and annotate them as necessary. See Annotations for more details.</p> Function HandlersClass-Based Views Function Handler<pre><code>async def get_users(\n    request: web.Request,\n    user_repository: Injected[UserRepository],\n) -&gt; web.Response:\n    ...\n</code></pre> <p>In Class-based views dependencies must be declared in the init method. </p> Class Based View<pre><code>class UsersView(web.View):\n    def __init__(\n        self, \n        request: web.Request, \n        user_repository: Injected[UserRepository],\n    ) -&gt; None:\n        super().__init__(request)\n        self.user_repository = user_repository\n\n    async def get() -&gt; web.Response: ...\n</code></pre>"},{"location":"integrations/aiohttp/#inject-aiohttp-request","title":"Inject AIOHTTP request","text":"<p>To inject <code>web.Request</code> in services, include <code>wireup.integration.aiohttp</code> module in the service modules when creating the container.</p> <pre><code>container = wireup.create_async_container(\n    service_modules=[\n        services,\n        wireup.integration.aiohttp\n    ],\n    parameters={\"db_dsn\": os.environ.get(\"APP_DB_DSN\")}\n)\n</code></pre>"},{"location":"integrations/aiohttp/#accessing-the-container","title":"Accessing the Container","text":"<p>If you need to access the Wireup container directly, use the following functions:</p> <pre><code>from wireup.integration.aiohttp import get_app_container, get_request_container\n\n# Get application-wide container.\napp_container: AsyncContainer = get_app_container(app)\n\n# Get request-scoped container.\n# This is what is currently injecting services on the active request.\nrequest_container: ScopedAsyncContainer = get_request_container()\n</code></pre>"},{"location":"integrations/aiohttp/#testing","title":"Testing","text":"<p>For general testing tips with Wireup refer to the test docs.  With the AIOHTTP integration, you can override dependencies in the container as follows.</p> test_thing.py<pre><code>from wireup.integration.aiohttp import get_app_container\n\ndef test_override(aiohttp_client):\n    class DummyGreeter(GreeterService):\n        def greet(self, name: str) -&gt; str:\n            return f\"Hi, {name}\"\n\n    with get_app_container(app).override.service(GreeterService, new=DummyGreeter()):\n        res = aiohttp_client.get(\"/greet?name=Test\")\n</code></pre> <p>See AIOHTTP integration tests for more examples.</p>"},{"location":"integrations/aiohttp/#routes-and-type-checker","title":"Routes and type checker","text":"<p>If you're using a type checker, then you may notice it showing type errors when adding dependencies to aio handlers. This is because the signature as defined in aiohttp only allows for <code>web.Request</code> in the parameters. To make the type checker happy you can annotate them with <code>wireup.integration.aiohttp.route</code>.</p> <pre><code>from wireup.integration.aiohttp import route\n\n@router.get(\"/users\")\n@route\nasync def users_list(\n    request: web.Request, \n    user_repository: Injected[UserRepository],\n) -&gt; web.Response:\n    pass\n</code></pre>"},{"location":"integrations/aiohttp/#api-reference","title":"API Reference","text":"<ul> <li>aiohttp_integration</li> </ul>"},{"location":"integrations/aiohttp/class_based_handlers/","title":"Class-Based Handlers for AIOHTTP","text":"<p>Class-based handlers in Wireup provide a new mechanism for efficient dependency injection for AIOHTTP applications.  They optimize performance by managing dependencies at startup rather than per request. Dependencies injected in the init method are zero-cost.</p>"},{"location":"integrations/aiohttp/class_based_handlers/#key-benefits","title":"Key Benefits","text":"<ul> <li>Request Performance: Zero overhead from dependency resolution during request handling.</li> <li>Stateful Handlers: Maintain state across requests.</li> <li>Route set: Group relevant resource endpoints together</li> </ul>"},{"location":"integrations/aiohttp/class_based_handlers/#example","title":"Example","text":"greeter.py<pre><code>class GreeterHandler:\n    router = web.RouteTableDef() #(1)!\n\n    def __init__(self, greeter: GreeterService) -&gt; None: #(2)!\n        self.greeter = greeter\n        self.counter = 0\n\n    @router.get(\"/greet\")\n    async def get_thing(\n        self,\n        request: web.Request, #(3)!\n        auth_service: Injected[AuthenticationService] #(4)!\n    ) -&gt; web.Response:\n        self.counter += 1\n\n        return web.json_response({\n            \"greeting\": self.greeter.greet(request.query.get(\"name\", \"world\")),\n            \"counter\": self.counter,\n        })\n</code></pre> <ol> <li>The class must contain a <code>web.RouteTableDef</code> instance named <code>router</code>. Use it to decorate routes inside this class.</li> <li>When injecting in the constructor the <code>Injected</code> syntax is not required.</li> <li>Like every AIOHTTP request handler, the first argument must be <code>web.Request</code>.</li> <li>Other scoped/transient dependencies can be requested in the routes. Here the <code>Injected[T]</code> annotation is required.</li> </ol> app.py<pre><code>wireup.integration.aiohttp.setup(\n    container,\n    app,\n    handlers=[GreeterHandler]\n)\n</code></pre> <p>Overriding: Handlers are created once on startup, their dependencies cannot be overridden once the application starts. If you need to override dependencies in the handler's init, then it must be done before application startup.</p>"},{"location":"integrations/click/","title":":simple-click: Click Integration","text":"<p>Dependency injection for Click is available in the <code>wireup.integration.click</code> module.</p> <ul> <li> <p> Automatic Dependency Management</p> <p>Inject dependencies in Click commands and automatically manage container lifecycle.</p> </li> <li> <p> Shared business logic</p> <p>Wireup is framework-agnostic. Share the service layer between CLIs and other interfaces, such as a web application.</p> </li> </ul>"},{"location":"integrations/click/#initialize-the-integration","title":"Initialize the integration","text":"<p>First, create a sync container</p> <pre><code>import click\nfrom wireup import Inject, Injected, service\n\n@click.group()\ndef cli():\n    pass\n\ncontainer = wireup.create_sync_container(\n    service_modules=[services],\n    parameters={\n        \"env\": \"development\",\n        \"debug\": True\n    }\n)\n</code></pre> <p>Then initialize the integration by calling <code>wireup.integration.click.setup</code> after adding all commands:</p> <pre><code># Initialize the integration.\n# Must be called after all commands have been added.\nwireup.integration.click.setup(container, cli)\n</code></pre>"},{"location":"integrations/click/#inject-in-click-commands","title":"Inject in Click Commands","text":"<p>To inject dependencies, add the type to the commands' signature and annotate them as necessary. See Annotations for more details.</p> Click Command<pre><code>@cli.command()\ndef random_number(random: Injected[RandomService]):\n    click.echo(f\"Your lucky number is: {random.get_random()}\")\n\n@cli.command()\ndef env_info(\n    env: Annotated[str, Inject(param=\"env\")],\n    debug: Annotated[bool, Inject(param=\"debug\")]\n):\n    click.echo(f\"Environment: {env}\")\n    click.echo(f\"Debug mode: {debug}\")\n</code></pre>"},{"location":"integrations/click/#accessing-the-container","title":"Accessing the Container","text":"<p>To access the Wireup container directly, use the following:</p> <pre><code># Get application-wide container\nfrom wireup.integration.click import get_app_container\n\ncontainer = get_app_container(cli)\n</code></pre>"},{"location":"integrations/click/#testing","title":"Testing","text":"<p>When testing Click commands with dependency injection, services can be swapped out in tests by overriding services before executing the Click runner.</p> <pre><code>from click.testing import CliRunner\n\n\ndef test_random_number_command():\n\n    # Create test container with mocked service\n    with container.override.service(RandomService, new=MockRandomService()):\n        runner = CliRunner()\n        result = runner.invoke(cli, [\"random-number\"])\n\n        assert result.exit_code == 0\n        assert \"Your lucky number is:\" in result.output\n</code></pre>"},{"location":"integrations/click/#api-reference","title":"API Reference","text":"<p>Visit API Reference for detailed information about the Click integration module.</p>"},{"location":"integrations/django/","title":"Django Integration","text":"<p>Wireup provides seamless integration with Django through the <code>wireup.integration.django</code> module, enabling dependency injection in Django applications.</p> <ul> <li> <p> Automatic Dependency Management</p> <p>Inject dependencies in routes and automatically manage container lifecycle.</p> </li> <li> <p> Request Objects</p> <p>Use Django request in Wireup dependencies.</p> </li> <li> <p> Django Settings</p> <p>The integration exposes Django settings to Wireup as parameters.</p> </li> <li> <p> Shared business logic</p> <p>Wireup is framework-agnostic. Share the service layer between web applications and other interfaces, such as a CLI.</p> </li> </ul>"},{"location":"integrations/django/#initialize-the-integration","title":"Initialize the integration","text":"<p>Add the following to Django settings:</p> settings.py<pre><code>import os\nfrom wireup.integration.django import WireupSettings\n\nINSTALLED_APPS = [\n    # ...existing code...\n    \"wireup.integration.django\"\n]\n\nMIDDLEWARE = [\n    \"wireup.integration.django.wireup_middleware\",\n    # ...existing code...\n]\n\nWIREUP = WireupSettings(\n    service_modules=[\"mysite.polls.services\"]  # Service modules here\n)\n\n# Additional application settings\nS3_BUCKET_TOKEN = os.environ[\"S3_BUCKET_ACCESS_TOKEN\"]\n</code></pre>"},{"location":"integrations/django/#inject-django-settings","title":"Inject Django settings","text":"<p>Django settings can be injected into services:</p> mysite/polls/services/s3_manager.py<pre><code>from wireup import service, Inject\nfrom typing import Annotated\n\n@service\nclass S3Manager:\n    def __init__(\n        self,\n        # Reference configuration by name\n        token: Annotated[str, Inject(param=\"S3_BUCKET_TOKEN\")],\n    ) -&gt; None: ...\n\n    def upload(self, file: File) -&gt; None: ...\n</code></pre> <p>You can also use Django settings in factories:</p> mysite/polls/services/github_client.py<pre><code>from wireup import service\nfrom django.conf import settings\n\nclass GithubClient:\n    def __init__(self, api_key: str) -&gt; None: ...\n\n@service\ndef github_client_factory() -&gt; GithubClient:\n    return GithubClient(api_key=settings.GH_API_KEY)\n</code></pre>"},{"location":"integrations/django/#inject-the-current-request","title":"Inject the current request","text":"<p>The integration exposes the current Django request as a <code>scoped</code> lifetime dependency, which can be injected into <code>scoped</code> or <code>transient</code> services:</p> mysite/polls/services/auth_service.py<pre><code>from django.http import HttpRequest\nfrom wireup import service\n\n@service(lifetime=\"scoped\")\nclass AuthService:\n    def __init__(self, request: HttpRequest) -&gt; None:\n        self.request = request\n</code></pre>"},{"location":"integrations/django/#inject-dependencies-in-views","title":"Inject dependencies in views","text":"<p>To inject dependencies in views, simply request them by their type:</p> app/views.py<pre><code>from django.http import HttpRequest, HttpResponse\nfrom mysite.polls.services import S3Manager\nfrom wireup import Injected\n\ndef upload_file_view(\n    request: HttpRequest, \n    s3_manager: Injected[S3Manager]\n) -&gt; HttpResponse:\n    # Use the injected S3Manager instance\n    return HttpResponse(...)\n</code></pre> <p>Class-based views are also supported. Specify dependencies in the class <code>__init__</code> function.</p> <p>For more examples, see the Wireup Django integration tests.</p>"},{"location":"integrations/django/#third-party-django-frameworks","title":"Third-party Django frameworks","text":"<p>If your project uses third-party packages to create views, such as Django REST framework or Django Ninja, you must use the <code>@inject</code> decorator explicitly.</p> <p>This approach should work for any Django-based framework as long as it relies on Django's <code>AppConfig</code> and middleware mechanisms.</p> Django REST FrameworkDjango Ninja app/views.py<pre><code>from rest_framework.decorators import api_view\nfrom rest_framework.request import Request\nfrom rest_framework.response import Response\nfrom rest_framework.views import APIView\nfrom rest_framework.viewsets import ViewSet\n\nfrom wireup import Injected\nfrom wireup.integration.django import inject\n\nfrom mysite.polls.services import S3Manager\n\n\n@api_view((\"GET\",))\n@inject\ndef drf_function_based_view(\n    request: Request,\n    s3_manager: Injected[S3Manager]\n) -&gt; Response:\n    # Use the injected S3Manager instance\n    return Response(...)\n\n\nclass DRFClassBasedView(APIView):\n    @inject\n    def get(\n        self,\n        request: Request,\n        s3_manager: Injected[S3Manager]\n    ) -&gt; Response:\n        # Use the injected S3Manager instance\n        return Response(...)\n\n\nclass DRFViewSet(ViewSet):\n    @inject\n    def list(\n        self,\n        request: Request,\n        s3_manager: Injected[S3Manager]\n    ) -&gt; Response:\n        # Use the injected S3Manager instance\n        return Response(...)\n</code></pre> app/views.py<pre><code>from ninja import Router, Schema\n\nfrom wireup import Injected\nfrom wireup.integration.django import inject\n\nfrom mysite.polls.services import S3Manager\n\n\nrouter = Router()\n\n\nclass ItemSchema(Schema):\n    name: str\n    price: float\n\n\n@router.get(\"/items\")\n@inject\ndef list_items(\n    request,\n    s3_manager: Injected[S3Manager]\n):\n    # Use the injected S3Manager instance\n    return {\"items\": [...]}\n\n\n@router.post(\"/items\")\n@inject\ndef create_item(\n    request,\n    data: ItemSchema,\n    s3_manager: Injected[S3Manager]\n):\n    # Both request body and injected service work together\n    return {\"name\": data.name, \"price\": data.price}\n</code></pre> <p>Best practice for mixing core and non-core Django views</p> <p>If your project shares core and non core-django views, consider disabling auto-injection and using <code>@inject</code> explicitly across all your views for consistency:</p> settings.py<pre><code>WIREUP = WireupSettings(\n    service_modules=[\"mysite.polls.services\"],\n    auto_inject_views=False,  # Disable auto-injection\n)\n</code></pre> DoDon't <pre><code># Consistent approach: use @inject everywhere\n@inject\ndef core_django_view(\n    request: HttpRequest,\n    service: Injected[MyService]\n) -&gt; HttpResponse:\n    return HttpResponse(...)\n\n@api_view((\"GET\",))\n@inject\ndef drf_view(\n    request: Request,\n    service: Injected[MyService]\n) -&gt; Response:\n    return Response(...)\n</code></pre> <pre><code># Inconsistent: mixing auto-injection and @inject\ndef core_django_view(\n    request: HttpRequest,\n    service: Injected[MyService]  # Auto-injected\n) -&gt; HttpResponse:\n    return HttpResponse(...)\n\n@api_view((\"GET\",))\n@inject  # Explicit injection\ndef drf_view(\n    request: Request,\n    service: Injected[MyService]\n) -&gt; Response:\n    return Response(...)\n</code></pre>"},{"location":"integrations/django/#accessing-the-container","title":"Accessing the container","text":"<p>To access the Wireup container directly, use the following functions:</p> <pre><code>from wireup.integration.django import get_app_container, get_request_container\n\n# Get application-wide container\napp_container = get_app_container()\n\n# Get request-scoped container\nrequest_container = get_request_container()\n</code></pre>"},{"location":"integrations/django/#testing","title":"Testing","text":"<p>For general testing tips with Wireup refer to the test docs.  With Django you can override dependencies in the container as follows:</p> test_thing.py<pre><code>from wireup.integration.django import get_app_container\n\ndef test_override():\n    class DummyGreeter(GreeterService):\n        def greet(self, name: str):\n            return f\"Hi, {name}\"\n\n    with get_app_container().override.service(GreeterService, new=DummyGreeter()):\n        res = self.client.get(\"/greet?name=Test\")\n        assert res.status_code == 200\n</code></pre> <p>Testing async views</p> <p>When testing async views, use Django's <code>AsyncClient</code> instead of the regular <code>Client</code>:</p> <pre><code>from django.test import AsyncClient\nimport pytest\n\n@pytest.fixture\ndef async_client():\n    return AsyncClient()\n\nasync def test_async_view(async_client):\n    response = await async_client.get(\"/async-endpoint/\")\n    assert response.status_code == 200\n</code></pre>"},{"location":"integrations/django/#api-reference","title":"API Reference","text":"<ul> <li>django_integration</li> </ul>"},{"location":"integrations/fastapi/","title":"FastAPI Integration","text":"<ul> <li> <p> Zero Runtime Overhead</p> <p>Inject dependencies with zero runtime overhead using Class-Based Handlers.</p> <p> Learn more</p> </li> <li> <p> Automatic Dependency Management</p> <p>Inject dependencies in routes and automatically manage container lifecycle.</p> </li> <li> <p> Global Access</p> <p>Retrieve dependencies in middleware and route handler decorators where they are normally unavailable in FastAPI.</p> <p> Learn more</p> </li> <li> <p> Shared business logic</p> <p>Wireup is framework-agnostic. Use it to share the service layer between web applications and other interfaces, such as a CLI.</p> </li> </ul>"},{"location":"integrations/fastapi/#getting-started","title":"Getting started","text":"<p>First, create an async container</p> <pre><code>import wireup\nfrom myapp import services\n\ncontainer = wireup.create_async_container(\n    service_modules=[services],\n    parameters={\"debug\": settings.DEBUG},\n)\n</code></pre> <p>Then initialize the integration by calling <code>wireup.integration.fastapi.setup</code> after adding all routers:</p> <pre><code>from fastapi import FastAPI\n\napp = FastAPI()\n\n# Add routers here\n# app.include_router(...)\n\nwireup.integration.fastapi.setup(\n    container, \n    app, \n    class_based_handlers=[...]  # Include Wireup Class-Based Handlers\n)\n</code></pre>"},{"location":"integrations/fastapi/#inject-in-http-and-websocket-routes","title":"Inject in HTTP and WebSocket routes","text":"<p>To inject dependencies, add the type to the route's signature and annotate them as necessary. See Annotations for more details.</p> HTTPWebSocket HTTP Route<pre><code>from typing import Annotated\nfrom fastapi import Depends\nfrom wireup import Injected, Inject\n\n@app.get(\"/random\")\nasync def target(\n    random_service: Injected[RandomService],\n    is_debug: Annotated[bool, Inject(param=\"debug\")],\n\n    # This is a regular FastAPI dependency.\n    lucky_number: Annotated[int, Depends(get_lucky_number)]\n): ...\n</code></pre> WebSocket Route<pre><code>from fastapi import WebSocket\nfrom wireup import Injected\n\n@app.websocket(\"/ws\")\nasync def ws(websocket: WebSocket, greeter: Injected[GreeterService]): ...\n</code></pre> <p>Tip</p> <p>Improve performance by using a custom APIRoute class.  This reduces overhead in endpoints that use Wireup injection by avoiding redundant processing.</p> <pre><code>from fastapi import APIRouter\nfrom wireup.integration.fastapi import WireupRoute\n\nrouter = APIRouter(route_class=WireupRoute)\n</code></pre> <p>If you already have a custom route class, you can inherit from WireupRoute instead.</p> <p>Under the hood: FastAPI processes all route parameters, including ones meant for Wireup.  The WireupRoute class optimizes this by making Wireup-specific parameters only visible to Wireup,  removing unnecessary processing by FastAPI's dependency injection system.</p>"},{"location":"integrations/fastapi/#inject-fastapi-request-or-websocket","title":"Inject FastAPI request or websocket","text":"<p>To inject the current request/websocket in services, include <code>wireup.integration.fastapi</code>  module in the service modules when creating the container.</p> <pre><code>import wireup\n\ncontainer = wireup.create_async_container(\n    service_modules=[services, wireup.integration.fastapi],\n    parameters={\"debug\": settings.DEBUG},\n)\n</code></pre>"},{"location":"integrations/fastapi/#use-request-and-websocket","title":"Use Request and WebSocket","text":"<pre><code>import fastapi\nfrom wireup import service\n\n@service(lifetime=\"scoped\")\nclass HttpAuthenticationService:\n    def __init__(self, request: fastapi.Request) -&gt; None: ...\n</code></pre> <pre><code>import fastapi\nfrom wireup import service\n\n@service(lifetime=\"scoped\")\nclass ChatService:\n    def __init__(self, websocket: fastapi.WebSocket) -&gt; None:\n        await self.websocket.accept()\n\n    async def send(self, data: str):\n        await self.websocket.send_text(data)\n</code></pre>"},{"location":"integrations/fastapi/#testing","title":"Testing","text":"<p>For general testing tips with Wireup refer to the test docs.  With the FastAPI integration, you can override dependencies in the container as follows.</p> test_thing.py<pre><code>from wireup.integration.fastapi import get_app_container\n\ndef test_override(client):\n    class DummyGreeter(GreeterService):\n        def greet(self, name: str) -&gt; str:\n            return f\"Hi, {name}\"\n\n    with get_app_container(app).override.service(GreeterService, new=DummyGreeter()):\n        res = client.get(\"/greet?name=Test\")\n</code></pre> <p>See FastAPI integration tests for more examples.</p> <p>Warning</p> <p>FastAPI's lifespan events are required to close the Wireup container properly.  Use a context manager when instantiating the test client if using class-based handlers or generator factories in the application.</p> <pre><code>@pytest.fixture()\ndef client(app: FastAPI) -&gt; Iterator[TestClient]:\n    with TestClient(app) as client:\n        yield client\n</code></pre>"},{"location":"integrations/fastapi/#api-reference","title":"API Reference","text":"<ul> <li>fastapi_integration</li> </ul>"},{"location":"integrations/fastapi/class_based_handlers/","title":"Class-Based Handlers for FastAPI","text":"<p>Wireup provides class-based handlers for FastAPI allowing grouping of related endpoints and dependency injection with zero runtime overhead.</p>"},{"location":"integrations/fastapi/class_based_handlers/#benefits","title":"Benefits","text":"<ul> <li>Zero runtime overhead for constructor-injected dependencies</li> <li>State persistence between requests within the same class</li> <li>Better code organization through class-based endpoint grouping</li> </ul>"},{"location":"integrations/fastapi/class_based_handlers/#basic-usage","title":"Basic Usage","text":"<p>Create a class with a field <code>router</code> of type <code>fastapi.Router</code> then decorate class methods like you normally do. Register class-based handlers during setup through Wireup. Do not include these routers in fastapi directly. </p> Class-Based Handler example<pre><code>class UserHandler:\n    router = fastapi.Router(prefix=\"/users\", route_class=WireupRoute)  # (1)!\n\n    def __init__(self, user_service: UserProfileService) -&gt; None:  # (2)!\n        self.user_service = user_profile_service\n\n\n    @router.get(\"/\")\n    async def list_all(self):\n        return self.user_service.find_all()\n\n    @router.get(\"/me\")\n    async def get_current_user_profile(\n        self,\n        auth_service: Injected[AuthenticationService]  # (3)!\n    ) -&gt; web.Response:\n        return self.user_service.get_profile(auth_service.current_user)\n</code></pre> <ol> <li>Define a router for this class. Tip: Use <code>route_class=WireupRoute</code> if you have dependencies being injected in route handlers (methods decorated with <code>@router</code>).</li> <li>Inject dependencies directly in the constructor. This is a one-time operation and has no runtime overhead.</li> <li>This is treated just like any other FastAPI route and as such, use of <code>Injected[T]</code> is required. <code>AuthenticationService</code> is a request-scoped dependency.</li> </ol> <p>The router instance is a regular FastAPI router so you can handle any connections in your class-based handlers, including WebSockets.</p>"},{"location":"integrations/fastapi/class_based_handlers/#integration","title":"Integration","text":"<pre><code>wireup.integration.fastapi.setup(\n    container,\n    app,\n    class_based_handlers=[UserProfileHandler]\n)\n</code></pre>"},{"location":"integrations/fastapi/class_based_handlers/#how-dependencies-work","title":"How Dependencies Work","text":"<ol> <li> <p>Constructor Dependencies</p> <ul> <li>Injected once at startup</li> <li>No <code>Injected[T]</code> syntax needed</li> <li>Cannot be overridden after startup</li> <li>Only parameters and singleton services</li> </ul> </li> <li> <p>Route Dependencies</p> <ul> <li>Use <code>Injected[T]</code> syntax</li> <li>Supports all scopes*</li> <li>Injected per-request</li> </ul> </li> </ol> <p>*  Injecting parameters and singletons here has no benefit and is not zero-cost. Inject those in <code>__init__</code> instead.</p> <p>Testing</p> <p>This feature uses FastAPI lifespan events. When testing, create the test client using a context manager for the lifespan events to correctly trigger. Note that this is a limitation of Fastapi/Testclient rather than Wireup.</p> <pre><code>@pytest.fixture()\ndef client(app: FastAPI) -&gt; Iterator[TestClient]:\n    with TestClient(app) as client:\n        yield client\n</code></pre>"},{"location":"integrations/fastapi/direct_container_access/","title":"Direct Container Access in FastAPI","text":"<p>Wireup primarily handles dependency injection in FastAPI routes. However, you can directly access the request or application container to retrieve services when needed outside of standard dependency injection.</p> <pre><code>from wireup.integration.fastapi import get_app_container, get_request_container\n\n# Access the request-scoped container (used for the current request).\n# This is what you almost always want.\n# It has all the information the app container has in addition\n# to data specific to the current request.\nrequest_container = get_request_container()\n\n# Access the application-wide container (created via `wireup.create_async_container`).\n# Use this when you need the container outside of the request context lifecycle.\napp_container = get_app_container(app)\n</code></pre>"},{"location":"integrations/fastapi/direct_container_access/#container-availability","title":"Container Availability","text":"<p>The app container is always retrievable given an instance of the application.</p> <p>If you need the request-scoped container outside the route handler (middleware, FastAPI dependencies, decorators), enable <code>middleware_mode</code> during setup. </p> <p>Normally, the container is created just before the route handler is called, and only on endpoints with Wireup dependencies. With this mode enabled, the request-scoped container is created at the start of the request lifecycle, making it available everywhere. This offers the greatest flexibility but runs on every request.</p> <pre><code>@router.get(\"/users\")\n@require_authn  # Request container is available here\nasync def get_users(user_service: Injected[UserService]):  # And here\n    pass\n</code></pre>"},{"location":"integrations/fastapi/direct_container_access/#examples-using-middleware-mode","title":"Examples Using Middleware Mode","text":""},{"location":"integrations/fastapi/direct_container_access/#in-route-decorators","title":"In Route Decorators","text":"<pre><code>def require_not_bob(fn):\n    @functools.wraps(fn)\n    async def wrapper(*args: Any, **kwargs: Any) -&gt; Any:\n        request = await get_request_container().get(fastapi.Request)\n\n    if request.query_params.get(\"name\") == \"Bob\":\n        raise HTTPException(status_code=401, detail=\"Bob is not allowed\")\n\n    return await fn(*args, **kwargs)\n\nreturn wrapper\n\n@router.get(\"/users\")\n@require_not_bob\nasync def get_users(user_service: Injected[UserService]):\n    ...\n</code></pre>"},{"location":"integrations/fastapi/direct_container_access/#in-middleware-requires-middleware-mode","title":"In Middleware (Requires Middleware Mode)","text":"<pre><code>from wireup.integration.fastapi import get_request_container\n\nasync def example_middleware(request: Request, call_next) -&gt; Response:\n    container = get_request_container()\n    ...\n    return await call_next(request)\n</code></pre>"},{"location":"integrations/fastapi/direct_container_access/#in-fastapi-dependencies-requires-middleware-mode","title":"In FastAPI Dependencies (Requires Middleware Mode)","text":"<pre><code>from wireup.integration.fastapi import get_request_container\n\nasync def get_example_dependency(\n    request: Request, \n    other_dependency: Annotated[Other, Depends(...)]\n):\n    container = get_request_container()\n    ...\n\n@router.get(\"/users\")\nasync def get_users(example: Annotated[Example, Depends(get_example_dependency)]):\n    ...\n</code></pre> <pre><code>!!! warning\n    Mixing Wireup and `fastapi.Depends` is discouraged and should be avoided unless necessary.\n\n    Keep in mind that while accessing the Wireup container in FastAPI dependencies is possible, the reverse is not: Wireup services cannot depend on objects provided by `fastapi.Depends`.\n    ...\n</code></pre>"},{"location":"integrations/flask/","title":"Flask Integration","text":"<p>Dependency injection for Flask is available in the <code>wireup.integration.flask</code> module.</p> <ul> <li> <p> Automatic Dependency Management</p> <p>Inject dependencies in routes and automatically manage container lifecycle.</p> </li> <li> <p> Shared business logic</p> <p>Wireup is framework-agnostic. Share the service layer between web applications and other interfaces, such as a CLI.</p> </li> </ul>"},{"location":"integrations/flask/#initialize-the-integration","title":"Initialize the integration","text":"<p>First, create a sync container with your service modules:</p> <pre><code>from flask import Flask\nfrom wireup import Inject, Injected, service\n\napp = Flask(__name__)\napp.config[\"FOO\"] = \"bar\"\n\ncontainer = wireup.create_sync_container(\n    service_modules=[services],\n    parameters={\n        **app.config,  # Optionally expose flask configuration to the container\n        \"API_KEY\": \"secret\"\n    }\n)\n</code></pre> <p>Then initialize the integration by calling <code>wireup.integration.flask.setup</code> after adding all views and configuration:</p> <pre><code># Initialize the integration.\n# Must be called after views and configuration have been added.\nwireup.integration.flask.setup(container, app)\n</code></pre>"},{"location":"integrations/flask/#inject-in-flask-views","title":"Inject in Flask Views","text":"<p>To inject dependencies, add the type to the views' signature and annotate them as necessary. See Annotations for more details.</p> Flask View<pre><code>@app.get(\"/random\")\ndef get_random(random: Injected[RandomService]):\n    return {\"lucky_number\": random.get_random()}\n\n@app.get(\"/env\")\ndef get_environment(\n    is_debug: Annotated[bool, Inject(param=\"DEBUG\")], \n    foo: Annotated[str, Inject(param=\"FOO\")]\n):\n    return {\"debug\": is_debug, \"foo\": foo}\n</code></pre>"},{"location":"integrations/flask/#accessing-the-container","title":"Accessing the Container","text":"<p>To access the Wireup container directly, use the following functions:</p> <pre><code>from wireup.integration.flask import get_app_container, get_request_container\n\n# Get application-wide container\napp_container = get_app_container(app)\n\n# Get request-scoped container\nrequest_container = get_request_container()\n</code></pre>"},{"location":"integrations/flask/#testing","title":"Testing","text":"<p>For general testing tips with Wireup refer to the test docs.  With the Flask integration, you can override dependencies in the container as follows.</p> test_thing.py<pre><code>from wireup.integration.flask import get_app_container\n\ndef test_override():\n    class DummyGreeter(GreeterService):\n        def greet(self, name: str) -&gt; str:\n            return f\"Hi, {name}\"\n\n    with get_app_container(app).override.service(GreeterService, new=DummyGreeter()):\n        res = self.client.get(\"/greet?name=Test\")\n</code></pre> <p>See Flask integration tests for more examples.</p>"},{"location":"integrations/flask/#api-reference","title":"API Reference","text":"<ul> <li>flask_integration</li> </ul>"},{"location":"integrations/starlette/","title":"Starlette Integration","text":"<p>The <code>wireup.integration.starlette</code> module provides dependency injection for Starlette applications.</p> <ul> <li> <p> Automatic Dependency Management</p> <p>Automatically manage the container lifecycle and inject dependencies into endpoints.</p> </li> <li> <p> Shared Business Logic</p> <p>Wireup is framework-agnostic, allowing the service layer to be shared across web applications and other interfaces, such as CLIs.</p> </li> </ul>"},{"location":"integrations/starlette/#setting-up-the-integration","title":"Setting Up the Integration","text":"<p>First, create an async container with your service modules:</p> <pre><code>from starlette.applications import Starlette\nfrom starlette.routing import Route\nimport wireup\n\napp = Starlette()\n\ncontainer = wireup.create_async_container(\n    service_modules=[services],\n    parameters={\"DEBUG\": True}  # Optionally expose custom parameters\n)\n</code></pre> <p>Then set up the integration using <code>wireup.integration.starlette.setup</code>:</p> <pre><code># Set up the integration.\nwireup.integration.starlette.setup(container, app)\n</code></pre>"},{"location":"integrations/starlette/#injecting-dependencies-into-endpoints","title":"Injecting Dependencies into Endpoints","text":"<p>To inject dependencies, apply the <code>@inject</code> decorator from the <code>wireup.integration.starlette</code> module to endpoints and annotate parameters accordingly. Refer to Annotations for more details.</p> Starlette Endpoint<pre><code>from starlette.endpoints import HTTPEndpoint\nfrom starlette.requests import Request\nfrom starlette.responses import JSONResponse\n\nfrom wireup import Injected\nfrom wireup.integration.starlette import inject\n\n@inject\nasync def get_random(\n    request: Request, \n    random: Injected[RandomService],\n) -&gt; JSONResponse:\n    return JSONResponse({\"lucky_number\": random.get_random()})\n\n\nclass HelloEndpoint(HTTPEndpoint):\n    @inject\n    async def get(self,\n        request: Request,\n        greeter: Injected[GreeterService]\n    ) -&gt; PlainTextResponse:\n        greeting = greeter.greet(request.query_params.get(\"name\", \"World\"))\n\n        return PlainTextResponse(greeting)\n</code></pre>"},{"location":"integrations/starlette/#inject-starlette-request-or-websocket","title":"Inject Starlette request or WebSocket","text":"<p>To inject the current request/websocket in services, include the <code>wireup.integration.starlette</code> module in the service modules when creating the container.</p> <pre><code>container = wireup.create_async_container(\n    service_modules=[..., wireup.integration.starlette],\n)\n</code></pre>"},{"location":"integrations/starlette/#using-starlette-request","title":"Using Starlette Request","text":"Example Service using Starlette Request<pre><code>@service(lifetime=\"scoped\")\nclass RequestContext:\n    def __init__(self, request: Request):\n        self.request = request\n\n    @property\n    def name(self) -&gt; str:\n        return self.request.query_params.get(\"name\", \"World\")\n</code></pre>"},{"location":"integrations/starlette/#accessing-the-container-directly","title":"Accessing the Container Directly","text":"<p>You can directly access the Wireup container using the following functions:</p> <pre><code>from wireup.integration.starlette import get_app_container, get_request_container\n\n# Access the request-scoped container (used for the current request).\n# This is what you almost always want.\n# It has all the information the app container has in addition\n# to data specific to the current request.\n# You can get an instance of the request container in decorators or other middleware.\nrequest_container = get_request_container()\n\n# Access the application-wide container created with `wireup.create_async_container`.\n# Use this for operations outside the request lifecycle.\napp_container = get_app_container(app)\n</code></pre>"},{"location":"integrations/starlette/#testing","title":"Testing","text":"<p>For general testing tips, see the testing documentation. To override dependencies in the container during tests, use the following approach:</p> test_thing.py<pre><code>from wireup.integration.starlette import get_app_container\n\n\nclass UppercaseGreeter(GreeterService):\n    def greet(self, name: str) -&gt; str:\n        return super().greet(name).upper()\n\n\ndef test_override():\n    container = get_app_container(app)\n\n    with container.override.service(GreeterService, new=UppercaseGreeter()):\n        response = client.get(\"/hello\", params={\"name\": \"world\"})\n\n    assert response.text == \"HELLO WORLD\"\n</code></pre> <p>For more examples, see the Starlette integration tests.</p>"},{"location":"integrations/starlette/#api-reference","title":"API Reference","text":"<ul> <li>starlette_integration</li> </ul>"}]}