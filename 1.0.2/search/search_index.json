{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Wireup","text":"<p>Performant, concise and type-safe Dependency Injection for Python 3.8+</p> <p> </p> <p>What is Dependency Injection?</p> <p>Dependency Injection (DI) is a design pattern where dependencies are provided externally rather than created within objects. Wireup automates DI using Python's type system, with support for async, generators and other modern Python features.</p>"},{"location":"#features","title":"Features","text":""},{"location":"#simple-type-safe-di","title":"\u2728 Simple &amp; Type-Safe DI","text":"<p>Inject services and configuration using a clean and intuitive syntax without boilerplate.</p> Basic UsageWith Configuration <pre><code>@service\nclass Database:\n    pass\n\n@service\nclass UserService:\n    def __init__(self, db: Database) -&gt; None:\n        self.db = db\n\ncontainer = wireup.create_sync_container(services=[Database, UserService])\nuser_service = container.get(UserService) # \u2705 Dependencies resolved.\n</code></pre> <pre><code>@service\nclass Database:\n    def __init__(self, db_url: Annotated[str, Inject(param=\"db_url\")]) -&gt; None:\n        self.db_url = db_url\n\ncontainer = wireup.create_sync_container(\n    services=[Database], \n    parameters={\"db_url\": os.environ[\"APP_DB_URL\"]}\n)\ndatabase = container.get(Database) # \u2705 Dependencies resolved.\n</code></pre>"},{"location":"#function-injection","title":"\ud83c\udfaf Function Injection","text":"<p>Inject dependencies directly into functions with a simple decorator.</p> <pre><code>@inject_from_container(container)\ndef process_users(service: Injected[UserService]):\n    # \u2705 UserService injected.\n    pass\n</code></pre>"},{"location":"#interfaces-abstract-classes","title":"\ud83d\udcdd Interfaces &amp; Abstract Classes","text":"<p>Define abstract types and have the container automatically inject the implementation.</p> <pre><code>@abstract\nclass Notifier(abc.ABC):\n    pass\n\n@service\nclass SlackNotifier(Notifier):\n    pass\n\nnotifier = container.get(Notifier) # \u2705 SlackNotifier instance.\n</code></pre>"},{"location":"#managed-service-lifetimes","title":"\ud83d\udd04 Managed Service Lifetimes","text":"<p>Declare dependencies as singletons, scoped, or transient to control whether to inject a fresh copy or reuse existing instances.</p> SingletonScopedTransient <p>One instance per application. <code>@service(lifetime=\"singleton\")</code> is the default.</p> <pre><code>@service\nclass Database:\n    pass\n</code></pre> <p>One instance per scope/request, shared within that scope/request.</p> <pre><code>@service(lifetime=\"scoped\")\nclass RequestContext:\n    def __init__(self) -&gt; None:\n        self.request_id = uuid4()\n</code></pre> <p>When full isolation and clean state is required. Every request to create transient services results in a new instance.</p> <pre><code>@service(lifetime=\"transient\")\nclass OrderProcessor:\n    pass\n</code></pre>"},{"location":"#flexible-creation-patterns","title":"\ud83c\udfed Flexible Creation Patterns","text":"<p>Defer instantiation to specialized factories when complex initialization or cleanup is required. Full support for async and generators. Wireup handles cleanup at the correct time depending on the service lifetime.</p> SynchronousAsync <pre><code>class WeatherClient:\n    def __init__(self, client: requests.Session) -&gt; None:\n        self.client = client\n\n@service\ndef weather_client_factory() -&gt; Iterator[WeatherClient]:\n    with requests.Session() as session:\n        yield WeatherClient(client=session)\n</code></pre> <pre><code>class WeatherClient:\n    def __init__(self, client: aiohttp.ClientSession) -&gt; None:\n        self.client = client\n\n@service\nasync def weather_client_factory() -&gt; AsyncIterator[WeatherClient]:\n    async with aiohttp.ClientSession() as session:\n        yield WeatherClient(client=session)\n</code></pre>"},{"location":"#improved-safety","title":"\ud83d\udee1\ufe0f Improved Safety","text":"<p>Wireup is mypy strict compliant and will not introduce type errors in your code. It will also warn you at the earliest possible stage about configuration errors to avoid surprises.</p> Container CreationFunction InjectionIntegrationsParameter Checks <p>The container will raise errors at creation time about missing dependencies or other issues.</p> <pre><code>@service\nclass Foo:\n    def __init__(self, unknown: NotManagedByWireup) -&gt; None:\n        pass\n\ncontainer = wireup.create_sync_container(services=[Foo])\n# \u274c Parameter 'unknown' of 'Foo' depends on an unknown service 'NotManagedByWireup'.\n</code></pre> <p>Injected functions will raise errors at module import time rather than when called.</p> <pre><code>@inject_from_container(container)\ndef my_function(oops: Injected[NotManagedByWireup]):\n    pass\n\n# \u274c Parameter 'oops' of 'my_function' depends on an unknown service 'NotManagedByWireup'.\n</code></pre> <p>Wireup integrations assert that requested injections in the framework are valid. <pre><code>@app.get(\"/\")\ndef home(foo: Injected[NotManagedByWireup]):\n    pass\n\nwireup.integration.flask.setup(container, app)\n# \u274c Parameter 'foo' of 'home' depends on an unknown service 'NotManagedByWireup'.\n</code></pre></p> <p>Configuration parameters are also checked for validity. <pre><code>class Database:\n    def __init__(self, url: Annotated[str, Inject(param=\"db_url\")]) -&gt; None:\n        self.db = db\n\n# \u274c Parameter 'url' of Type 'Database' depends on an unknown Wireup parameter 'db_url'.\n</code></pre></p>"},{"location":"#framework-agnostic","title":"\ud83d\udccd Framework-Agnostic","text":"<p>Wireup provides its own Dependency Injection mechanism and is not tied to specific frameworks. Use it anywhere you like.</p>"},{"location":"#share-services-between-application-and-cli","title":"\ud83d\udd17 Share Services Between Application and CLI","text":"<p>Share the service layer between your web application and its accompanying CLI using Wireup.</p>"},{"location":"#native-integration-with-django-fastapi-or-flask","title":"\ud83d\udd0c Native Integration with Django, FastAPI, or Flask","text":"<p>Integrate with popular frameworks for a smoother developer experience. Integrations manage request scopes, injection in endpoints, and lifecycle of services.</p> <pre><code>app = FastAPI()\ncontainer = wireup.create_async_container(services=[UserService, Database])\n\n@app.get(\"/\")\ndef users_list(user_service: Injected[UserService]):\n    pass\n\nwireup.integration.fastapi.setup(container, app)\n</code></pre>"},{"location":"#simplified-testing","title":"\ud83e\uddea Simplified Testing","text":"<p>Wireup does not patch your services and lets you test them in isolation.</p> <p>If you need to use the container in your tests, you can have it create parts of your services or perform dependency substitution.</p> <pre><code>with container.override.service(target=Database, new=in_memory_database):\n    # The /users endpoint depends on Database.\n    # During the lifetime of this context manager, requests to inject `Database`\n    # will result in `in_memory_database` being injected instead.\n    response = client.get(\"/users\")\n</code></pre>"},{"location":"#next-steps","title":"Next Steps","text":"<ul> <li>Getting Started - Follow the Getting Started guide for a more in-depth tutorial.</li> <li>Services</li> <li>Parameters</li> </ul>"},{"location":"annotations/","title":"Dependency Annotations","text":"<p>Wireup uses type annotations to resolve dependencies. In most cases, the type alone is sufficient, but some cases require additional metadata through annotations.</p>"},{"location":"annotations/#when-are-annotations-required","title":"When Are Annotations Required?","text":"<p>Wireup differentiates between injecting into its own services (those decorated with <code>@service</code>) and injecting into external targets.</p>"},{"location":"annotations/#annotation-requirements-in-wireup-services","title":"Annotation Requirements in Wireup Services","text":"Type of Dependency Annotations Required? What is Required Services No Interface with only one implementation No Default implementation of an interface No Interface with multiple implementations Yes Qualifier Parameters Yes Parameter name Parameter expressions Yes Expression"},{"location":"annotations/#annotation-requirements-in-external-targets","title":"Annotation Requirements in External Targets","text":"<p>When injecting into an external target, annotations are always required, even if not typically needed in Wireup services. Annotate parameters with <code>Annotated[T, Inject()]</code> or its alias <code>Injected[T]</code>.</p> <p>Why is this required</p> <p>In its own services, Wireup assumes full ownership of dependencies, making empty annotations via <code>Inject()</code> redundant. For external targets, annotations inform the container to interact only with specific parameters, ensuring compatibility with other libraries or frameworks.</p> <p>Explicit annotations allow the container to fail fast on unrecognized injection requests, improving reliability by catching errors early. They also enhance maintainability and readability by clearly documenting expected dependencies.</p>"},{"location":"annotations/#examples","title":"Examples","text":"<p>For Python 3.9+ (or 3.8+ with <code>typing_extensions</code>):</p> <pre><code>@wireup.inject_from_container(container)\ndef configure(\n    # Inject configuration parameter\n    env: Annotated[str, Inject(param=\"app_env\")],\n\n    # Inject dynamic expression\n    log_path: Annotated[str, Inject(expr=\"${data_dir}/logs\")],\n\n    # Inject service\n    service: Injected[MyService, Inject()],\n\n    # Injected is an alias of Annotated[T, Inject()]\n    service: Injected[MyService],\n\n    # Inject specific implementation\n    db: Annotated[Database, Inject(qualifier=\"readonly\")]\n):\n    ...\n</code></pre>"},{"location":"apply_container_as_decorator/","title":"Apply as a decorator","text":"<p>Warning</p> <p>When using the provided integrations, this is automatically handled for you. Only use this if you're injecting Wireup dependencies in a framework without an integration.</p> <p>Instead of retrieving services via <code>container.get</code> or parameters via <code>container.params</code>, you can inject them by applying the container as a decorator.</p> <p>The goal is to go from this:</p> <pre><code>def awesome_function() -&gt; None:\n    random = container.get(RandomService)\n    env_name = container.params.get(\"env\")\n\n    with container.enter_scope() as scoped_container:\n        scoped_service = scoped_container.get(ScopedService)\n</code></pre> <p>To having the dependencies injected directly into the function.</p>"},{"location":"apply_container_as_decorator/#implementation","title":"Implementation","text":"<p>Wireup provides a decorator called <code>wireup.inject_from_container</code>. The container will enter a scope before executing the function, inject all dependencies and exit the scope once the function returns.</p> <p>Warning</p> <p>When injecting on decorated functions, the container will only interact with parameters annotated with <code>Injected[T]</code> or <code>Annotated[T, Inject()]</code> (the two are equivalent, <code>Injected[T]</code> is only an alias).</p> <pre><code>from wireup import Injected\n\n@wireup.inject_from_container(container)\ndef awesome_function(\n    service: Injected[RandomService], \n    scoped_service: Injected[ScopedService], \n    env_name: Annotated[str, Inject(param=\"env\")]\n) -&gt; None: ...\n</code></pre> <p>If you have already created a scoped container elsewhere, you can supply a callable that returns it as the second argument. Wireup will use that and not enter a new scope.</p> <pre><code>scoped_container: ContextVar[ScopedSyncContainer] = ContextVar(\"scoped_container\")\n\n@wireup.inject_from_container(container, scoped_container.get)\ndef awesome_function(\n    service: Injected[RandomService], \n    scoped_service: Injected[ScopedService], \n    env_name: Annotated[str, Inject(param=\"env\")]\n) -&gt; None: ...\n</code></pre> <p>You can also alias the decorator for a cleaner look.</p> <pre><code>scoped_container: ContextVar[ScopedSyncContainer] = ContextVar(\"scoped_container\")\ninjected = wireup.inject_from_container(container, scoped_container.get)\n\n@injected\ndef awesome_function(\n    service: Injected[RandomService], \n    scoped_service: Injected[ScopedService], \n    env_name: Annotated[str, Inject(param=\"env\")]\n) -&gt; None: ...\n</code></pre>"},{"location":"apply_container_as_decorator/#good-to-know","title":"Good to know","text":"<ul> <li>This function works with both sync and async containers.</li> <li>To inject <code>async def</code> functions you need an async container created via <code>wireup.create_async_contaier</code>.</li> </ul>"},{"location":"apply_container_as_decorator/#function-documentation","title":"Function documentation","text":""},{"location":"apply_container_as_decorator/#wireupinject_from_container","title":"<code>wireup.inject_from_container</code>","text":"<p>Inject dependencies into the decorated function based on annotations.</p> <p>Parameters:</p> Name Type Description Default <code>container</code> <code>SyncContainer | AsyncContainer</code> <p>The main container instance created via <code>wireup.create_sync_container</code> or <code>wireup.create_async_container</code>.</p> required <code>scoped_container_supplier</code> <code>Callable[[], ScopedSyncContainer | ScopedAsyncContainer] | None</code> <p>An optional callable that returns the current scoped container instance. If provided, it will be used to create scoped dependencies. If not provided, the container will automatically enter a scope. Provide a scoped_container_supplier if you need to manage the container's scope manually. For example, in web frameworks, you might enter the scope at the start of a request in middleware so that other middlewares can access the scoped container if needed.</p> <code>None</code>"},{"location":"demo_app/","title":"Demo application","text":"<p>Check out maldoinc/wireup-demo  for a demo Flask application using Wireup.</p> <p>It shows creation, injection and testing in the context of a simple \"Blog\" application.</p>"},{"location":"factory_functions/","title":"Factory functions","text":"<p>Typically getting the necessary dependencies is enough to construct an object. However, there are scenarios where you need to delegate service creation to a special function called a  factory.</p>"},{"location":"factory_functions/#use-cases","title":"Use cases","text":"<ul> <li>Object construction needs additional logic or configuration.</li> <li>Depending on the runtime environment or configuration, you may need to create different objects  inheriting from the same base (See: Strategy Pattern) or configure them differently. </li> <li>Inject a model/dto which represents the result of an action, such as the current authenticated user.</li> <li>Inject a class from another library where it's not possible to add annotations.</li> <li>Inject strings, ints and other built-in types.</li> </ul>"},{"location":"factory_functions/#usage","title":"Usage","text":"<p>In order for the container to inject these dependencies, you must decorate the factory with <code>@service</code> and register it with the container.</p> <p>When the container needs to inject a dependency, it checks known factories to see if any of them can create it.</p> <p>Good to know</p> <p>Return type annotation of the factory is required as it denotes what will be built.</p>"},{"location":"factory_functions/#examples","title":"Examples","text":""},{"location":"factory_functions/#generator-functions-for-resource-management","title":"Generator Functions for Resource Management","text":"<p>When your service requires cleanup (like database connections or network resources), use generator functions:</p> <pre><code>@service\ndef db_session_factory() -&gt; Iterator[Session]:\n    db = Session()\n    try:\n        yield db\n    finally:\n        db.close()\n</code></pre> <p>Or with context managers: <pre><code>@service\ndef db_session_factory() -&gt; Iterator[Session]:\n    with contextlib.closing(Session()) as db:\n        yield db\n</code></pre></p> <p>For async services: <pre><code>@service\nasync def client_session_factory() -&gt; ClientSession:\n    async with ClientSession() as sess:\n        yield sess\n</code></pre></p> <p>Resource Cleanup</p> <p>The container performs cleanup automatically when:</p> <ul> <li>A context manager exits (<code>container.enter_scope()</code>)</li> <li>An injected function returns</li> <li>A request completes (when using framework integrations)</li> </ul>"},{"location":"factory_functions/#inject-models","title":"Inject Models","text":"<p>Assume in the context of an application a class User exists and represents a user of the system. We can use a factory to inject a user model that represents the current authenticated user.</p> <pre><code>from wireup import service\n\n# Create a distinct type for the authenticated user\nAuthenticatedUser = NewType(\"AuthenticatedUser\", User)\n\n@service(lifetime=\"transient\")\ndef get_current_user(auth_service: AuthService) -&gt; AuthenticatedUser:\n    return AuthenticatedUser(auth_service.get_current_user())\n\n# Inject the authenticated user where needed\n@wireup.inject_from_container(container)\ndef get_user_logs(user: Injected[AuthenticatedUser]):\n    # Use authenticated user\n    ...\n</code></pre>"},{"location":"factory_functions/#implement-strategy-pattern","title":"Implement strategy pattern","text":"<p>Assume a base class <code>Notifier</code> with implementations that define how the notification is sent (IMAP, POP, WebHooks, etc.) Given a user it is possible to instantiate the correct type of notifier based on user preferences.</p> <pre><code>from wireup import service\n\n\n@service(lifetime=\"transient\")\ndef get_user_notifier(\n    user: AuthenticatedUser, \n    slack_notifier: SlackNotifier, \n    email_mailer: EmailNotifier\n) -&gt; Notifier:\n    notifier = ...  # get notifier type from preferences.\n\n    return notifier\n</code></pre> <p>When injecting <code>Notifier</code> the correct type will be injected based on the authenticated user's preferences.</p>"},{"location":"factory_functions/#inject-a-third-party-class","title":"Inject a third-party class","text":"<p>You can use factory functions to inject a class which you have not declared yourself and therefore cannot annotate.  Let's take redis client as an example. </p> <pre><code>from wireup import service\n\n\n@service\ndef redis_factory(redis_url: Annotated[str, Inject(param=\"redis_url\")]) -&gt; Redis:\n    return redis.from_url(redis_url)\n</code></pre>"},{"location":"factory_functions/#inject-built-in-types","title":"Inject built-in types","text":"<p>If you want to inject resources which are just strings, ints, or other built-in types then you can use a factory in combination with <code>NewType</code>.</p> factories.py<pre><code>AuthenticatedUsername = NewType(\"AuthenticatedUsername\", str)\n\n@service\ndef authenticated_username_factory(auth: SomeAuthService) -&gt; AuthenticatedUsername:\n    return AuthenticatedUsername(...)\n</code></pre> <p>This can now be injected as usual by annotating the dependency with the new type.</p>"},{"location":"future_annotations/","title":"Type Annotations Support","text":"<p>Wireup supports string type annotations and <code>from __future__ import annotations</code> when the <code>eval_type_backport</code> package is installed.</p>"},{"location":"future_annotations/#important-requirements","title":"Important Requirements","text":"<ol> <li>Define services and factories at the module level only. Inner function definitions are not supported.</li> <li>Keep type imports accessible at runtime - don't move them to <code>TYPE_CHECKING</code> blocks.</li> </ol>"},{"location":"future_annotations/#example","title":"Example","text":"<pre><code>from typing import TYPE_CHECKING  # Don't do this!\n\nif TYPE_CHECKING:\n    from collections.abc import Iterator\n\n\n@service\ndef create_thing() -&gt; Iterator[Thing]:  # This needs the import at runtime\n    yield Thing()\n\n@service\n@dataclass\nclass Service:\n    thing: Thing  # This too needs the import at runtime\n</code></pre> <p>Warning</p> <p>If you use Ruff/flake8 with rules like <code>TCH</code>, be careful not to move required imports into <code>TYPE_CHECKING</code> blocks.</p>"},{"location":"getting_started/","title":"Getting Started","text":"<p>To showcase the basics of Wireup, we will create a container able to inject the following:</p> <ul> <li>A <code>WeatherService</code> that queries a fictional weather api. It needs an api key, a <code>KeyValueStore</code> to cache data and an async http client to make requests.</li> <li><code>KeyValueStore</code> itself needs a <code>redis_url</code> denoting the server it will connect to to query/store data.</li> </ul> <p>These services will then be retrieved in a <code>/weather/forecast</code> endpoint that requires <code>WeatherService</code> to provide weather information.</p> <pre><code>graph LR\n    redis_url[\u2699\ufe0f redis_url] --&gt; KeyValueStore[\ud83d\udc0d KeyValueStore]\n    weather_api_key[\u2699\ufe0f weather_api_key] --&gt; WeatherService\n    KeyValueStore --&gt; WeatherService[\ud83d\udc0d WeatherService]\n    WeatherService --&gt; Route[\ud83c\udf0e /weather/forecast]\n    F[\ud83c\udfed HttpClient] --&gt; WeatherService</code></pre> <p>Tip</p> <p>There will be little <code>+</code> icons in code fragments. You can click on those for more detailed information as to what is happening in that particular line.</p>"},{"location":"getting_started/#1-setup","title":"1. Setup","text":"<p>Install wireup using pip or your favorite package manager.</p> <pre><code>$ pip install wireup\n</code></pre> <p>The first step is to create a container.</p> container.py<pre><code>import wireup\n\ncontainer = wireup.create_async_container(\n    # Parameters are an optional key-value configuration store.\n    # You can inject parameters as necessary by their name where required.\n    parameters={ # (1)!\n        \"redis_url\": os.environ[\"APP_REDIS_URL\"],\n        \"weather_api_key\": os.environ[\"APP_WEATHER_API_KEY\"],\n    },\n    # Let the container know where service registrations are located.\n    # This is a list of top-level modules Wireup should scan for service declarations.\n    service_modules=[services]  # (2)!\n)\n</code></pre> <ol> <li> <p>Parameters are configuration your application needs.     Such as an api key, database url, or other settings.</p> <p>You can inject them as necessary by their name (dict key) where required. Wireup won't pull things from the environment or other places for you. You need to expose to it the different settings you'll need.</p> <p>You don't have to use this if you prefer using things like pydantic-settings, but it will enable you to have self-contained service definitions without writing additional set-up code to create these objects.</p> <p>Note that the values can be literally anything you need to inject and not just int/strings or other scalars. You can put dataclasses for example in the parameters to inject structured configuration.</p> </li> <li> <p>Service modules is a list of top-level python modules containing service definitions this container     needs to know about (Classes or functions decorated with <code>@service</code> or <code>@abstract</code>.).     The container will only create types that are explicitly registered with it.</p> </li> </ol> <p>Container variants: Sync and Async</p> <p>Wireup includes two types of containers: async and sync. The difference is that the async one exposes <code>async def</code> methods for the common operations and is capable of creating resources from <code>async def</code> factories.</p> <p>The async container can create both regular and resources from async factories.</p> <p>If you don't use async in your code you should create a container via <code>wireup.create_sync_container</code>. Some integrations that Wireup provides also require you to create containers of a given type. E.g: FastAPI integration only supports async containers.</p> Read: Global variables <p>Using this approach means relying on global state, which ties your application to a single container instance.  This might be sufficient for you and that's okay but, if you want to avoid global state, it's better to create  the container within your application factory and store it in your application's state instead.</p>"},{"location":"getting_started/#2-define-services","title":"2. Define services","text":"<p>The container uses types and annotations to define services and the discover dependencies between them. This results in self-contained service declarations without having to create factories for every service.</p>"},{"location":"getting_started/#keyvaluestore","title":"\ud83d\udc0d <code>KeyValueStore</code>","text":"<p>To create <code>KeyValueStore</code>, all we need is the <code>redis_url</code> parameter. The <code>@service</code> decorator tells Wireup this is a service, and we need to tell the container via annotated types to fetch the value of the <code>redis_url</code> parameter for <code>dsn</code>. </p> services/key_value_store.py<pre><code>from wireup import service, Inject\nfrom typing_extensions import Annotated\n\n@service  #(1)!\nclass KeyValueStore:\n    def __init__(self, dsn: Annotated[str, Inject(param=\"redis_url\")]) -&gt; None:  #(2)!\n        self.client = redis.from_url(dsn)\n</code></pre> <ol> <li>Decorators are only used to collect metadata.      This makes testing simpler, as you can still instantiate this like a regular class in your tests.</li> <li>Since type-based injection is not possible here (there can be many string/int parameters after all),      parameters must be annotated with the <code>Inject(param=name)</code> syntax. This tells the container which parameter to inject.</li> </ol>"},{"location":"getting_started/#aiohttpclientsession","title":"\ud83c\udfed <code>aiohttp.ClientSession</code>","text":"<p>The http client making requests cannot be instantiated directly as we need to enter an async context manager. To accommodate such cases, Wireup allows you to use functions to create dependencies.  These can be sync/async as well as regular or generator functions if cleanup needs to take place.</p> <p>Factories can define their dependencies in the function's signature.</p> <p>When using generator factories make sure to call <code>container.close</code> when the application is terminating for the necessary cleanup to take place.</p> services/factories.py<pre><code>@service\nasync def make_http_client() -&gt; AsyncIterator[aiohttp.ClientSession]:\n    async with aiohttp.ClientSession() as client:\n        yield client\n</code></pre>"},{"location":"getting_started/#weatherservice","title":"\ud83d\udc0d <code>WeatherService</code>","text":"<p>Creating <code>WeatherService</code> is also straightforward. The <code>@service</code> decorator is used to let Wireup know this is a service and we use the same syntax as above for the <code>api_key</code>. </p> <p>Class dependencies do not need additional annotations, even though the http client is created via an async generator. This is transparently handled by the container.</p> services/weather_service.py<pre><code>@service\nclass WeatherService:\n    def __init(\n        self,\n        api_key: Annotated[str, Inject(param=\"weather_api_key\")], #(1)!\n        kv_store: KeyValueStore, #(2)!\n        client: aiohttp.ClientSession, #(3)!\n    ) -&gt; None: ...\n</code></pre> <ol> <li>Same as above, weather api key needs the parameter name for the container to inject it.</li> <li><code>KeyValueStore</code> can be injected only by type and does not require annotations.</li> <li><code>aiohttp.ClientSession</code> can be injected only by type and requires no additional configuration.</li> </ol>"},{"location":"getting_started/#3-use","title":"3. Use","text":"<p>All that's left now is to retrieve services from the container.</p> Service LocatorInjection via decoratorFastAPIFlaskDjango <p>To fetch services from the container, call <code>.get</code> on the container instance with the type you wish to retrieve.</p> views/posts.py<pre><code>@app.get(\"/weather/forecast\")\nasync def get_forecast():\n    weather_service = await container.get(WeatherService)\n    return await weather_service.get_forecast(...)\n</code></pre> <p>You can also apply Wireup containers as decorators. See Apply the container as a decorator docs for more info, but the end result is that you can decorate any function and specify dependencies to inject in it's signature.</p> views/posts.py<pre><code>from wireup import Injected, inject_from_container\n\n@app.get(\"/weather/forecast\")\n@inject_from_container(container)\nasync def get_forecast(weather_service: Injected[WeatherService]):\n    return await weather_service.get_forecast(...)\n</code></pre> <p>With the FastAPI integration you can just declare dependencies in http or websocket routes.</p> views/posts.py<pre><code>from wireup import Injected\n\n@app.get(\"/weather/forecast\")\nasync def get_forecast(weather_service: Injected[WeatherService]):\n    return await weather_service.get_forecast(...)\n</code></pre> <p>Learn More: FastAPI Integration.</p> <p>With the Flask integration you can just declare dependencies in views.</p> views/posts.py<pre><code>from wireup import Injected\n\n@app.get(\"/weather/forecast\")\nasync def get_forecast(weather_service: Injected[WeatherService]):\n    return await weather_service.get_forecast(...)\n</code></pre> <p>Learn More: Flask Integration.</p> <p>With the Django integration you can just declare dependencies in views. The integration provides support for async views, regular views as well as class-based views.</p> views/posts.py<pre><code>from wireup import Injected\n\nasync def get_forecast(weather_service: Injected[WeatherService]):\n    return await weather_service.get_forecast(...)\n</code></pre> <p>Learn More: Django Integration.</p>"},{"location":"getting_started/#35-integrate","title":"3.5 Integrate","text":"<p>While Wireup is framework-agnostic, usage can be simplified when using it alongside one of the integrations. Key benefits of the integrations are:</p> <ul> <li>Automatic injection in routes without having to do <code>container.get</code> or use decorators.</li> <li>Lifecycle management and access to request-scoped dependencies.</li> <li>Eliminates the need for a global container variable as containers are bound to the application instance.</li> <li>Other goodies specific for that particular framework.</li> </ul>"},{"location":"getting_started/#integrations","title":"Integrations","text":"<ul> <li> Django</li> <li> FastAPI</li> <li> Flask</li> </ul>"},{"location":"getting_started/#4-test","title":"4. Test","text":"<p>Wireup does not patch your services, which means they can be instantiated and tested independently of the container.</p> <p>To substitute dependencies on targets such as views in a web application you can override dependencies with new ones on the fly.</p> <pre><code>with container.override.service(WeatherService, new=test_weather_service):\n    response = client.get(\"/weather/forecast\")\n</code></pre> <p>Requests to inject <code>WeatherService</code> during the lifetime of the context manager  will result in <code>test_weather_service</code> being injected instead.</p>"},{"location":"getting_started/#conclusion","title":"Conclusion","text":"<p>This concludes the \"Getting Started\" walkthrough, covering the most common dependency injection use cases.</p> <p>Info</p> <ul> <li>Wireup can perform injection on both sync and async targets.</li> <li>If you need to create multiple containers, every container you create is separate from the rest and has its own state.</li> </ul>"},{"location":"getting_started/#next-steps","title":"Next Steps","text":"<ul> <li>Services</li> <li>Parameters</li> <li>Factory functions</li> </ul>"},{"location":"interfaces/","title":"Interface Injection","text":"<p>You can use abstract classes as interfaces when you need to inject dependencies. This pattern is particularly useful for testing, as it allows you to create mock implementations.</p>"},{"location":"interfaces/#basic-usage","title":"Basic Usage","text":"<p>Register a class as an interface using the <code>@abstract</code> decorator. Then implement and register concrete classes that inherit from it. Note that the class marked with <code>@abstract</code> doesn't actually have to inherit <code>abc.ABC</code>.</p> <pre><code>from wireup import abstract, container, service\n\n\n@abstract\nclass Engine(abc.ABC):\n    @abc.abstractmethod\n    def get_type(self) -&gt; EngineType:\n        raise NotImplementedError\n\n\n@service\nclass CombustionEngine(Engine):\n    @override\n    def get_type(self) -&gt; EngineType:\n        return EngineType.COMBUSTION\n\n\n@wireup.inject_from_container(container)\ndef target(engine: Engine):\n    engine_type = engine.get_type()  # Returns EngineType.COMBUSTION\n</code></pre>"},{"location":"interfaces/#multiple-implementations","title":"Multiple Implementations","text":"<p>Use qualifiers to distinguish between different implementations of the same interface:</p> <pre><code>@service(qualifier=\"electric\")\nclass ElectricEngine(Engine):\n    def get_type(self):\n        return EngineType.ELECTRIC\n\n\n@service(qualifier=\"combustion\")\nclass CombustionEngine(Engine):\n    def get_type() -&gt; EngineType:\n        return EngineType.COMBUSTION\n\n\n@wireup.inject_from_container(container)\ndef target(\n    electric: Annotated[Engine, Inject(qualifier=\"electric\")],\n    combustion: Annotated[Engine, Inject(qualifier=\"combustion\")],\n):\n    ...\n</code></pre> <p>Tip</p> <p>Qualifiers can be any hashable value, including enum members.</p>"},{"location":"interfaces/#default-implementation","title":"Default Implementation","text":"<p>To set a default implementation, register one class without a qualifier:</p> <pre><code>@service  # Default implementation\nclass ElectricEngine(Engine):\n    pass\n\n@service(qualifier=\"combustion\")\nclass CombustionEngine(Engine):\n    pass\n</code></pre> <p>When injecting <code>Engine</code> without a qualifier, the container will use the default implementation (<code>ElectricEngine</code> in this example). Use qualifiers to access other implementations.</p>"},{"location":"lifetimes/","title":"Service Lifetimes","text":"<p>Wireup manages how long service instances live through three different lifetimes: Singleton, Scoped, and Transient. Configure the lifetime using the <code>lifetime</code> parameter in the <code>@service</code> decorator.</p>"},{"location":"lifetimes/#available-lifetimes","title":"Available Lifetimes","text":""},{"location":"lifetimes/#singleton-default","title":"Singleton (Default)","text":"<p>One instance is created and shared across the entire application.</p> <pre><code>@service  # lifetime=\"singleton\" is the default\nclass Database: ...\n\n# Same instance everywhere\ndb1 = container.get(Database)\ndb2 = container.get(Database)\nassert db1 is db2\n</code></pre> <p>Best for:</p> <ul> <li>Stateful services.</li> <li>Resource-intensive services.</li> <li>Configuration holders.</li> </ul>"},{"location":"lifetimes/#scoped","title":"Scoped","text":"<p>One instance per scope, shared within that scope.</p> <pre><code>@service(lifetime=\"scoped\")\nclass RequestContext: ...\n\nwith container.enter_scope() as scope1, container.enter_scope() as scope2:\n    # Same instance within scope\n    ctx1 = scope1.get(RequestContext)\n    ctx2 = scope1.get(RequestContext)\n    assert ctx1 is ctx2\n\n    # Different instance in different scope\n    other = scope2.get(RequestContext)\n    assert ctx1 is not other\n</code></pre> <p>Best for:</p> <ul> <li>Request-specific services.</li> <li>Per-operation state.</li> <li>Database transactions.</li> </ul> <p>Info</p> <p>Wireup integrations manage the scope lifecycle for you.  A new scope is entered at the beginning of a request and exited at the end.  This means that a <code>scoped</code> service will live for the duration of the request.</p> <p>The Wireup <code>@wireup.inject_from_container(container)</code> decorator can also enter/exit a scope after the decorated function returns. Learn More.</p>"},{"location":"lifetimes/#transient","title":"Transient","text":"<p>New instance created on every request.</p> <pre><code>@service(lifetime=\"transient\")\nclass MessageBuilder: ...\n\nwith container.enter_scope() as scope:\n    # New instance every time\n    builder1 = scope.get(MessageBuilder)\n    builder2 = scope.get(MessageBuilder)\n    assert builder1 is not builder2\n</code></pre> <p>Best for:</p> <ul> <li>Stateless services.</li> <li>Services that need fresh state.</li> <li>Temporary resources.</li> </ul> <p>Scope Required</p> <p>Transient services must be resolved within a scope, even if they don't use scoped dependencies. This ensures proper cleanup of resources if the transient service itself or one of its dependencies needs to perform cleanup.</p>"},{"location":"lifetimes/#lifetime-rules","title":"Lifetime Rules","text":"<ul> <li>Singletons can depend only on other singletons.</li> <li>Scoped and transient services can depend on any lifetime.</li> <li>Parameters can be injected into all lifetimes.</li> </ul> <p>Choosing a Lifetime</p> <ul> <li>Start with singleton unless you have a reason not to.</li> <li>Use scoped for request-specific state.</li> <li>Use transient for fresh instances or temporary resources.</li> </ul>"},{"location":"lifetimes/#scoped-services-and-decorated-functions","title":"Scoped services and decorated functions","text":"<p>Wireup lets you apply the container as a decorator. The provided integrations also decorate for you the routes/views where Wireup services are used.</p> <p>For such cases, you don't need to do any scope management yourself and can simply ask for the scoped/transient services in the function's signature. The decorator can enter a scope and exit it once the function returns.</p>"},{"location":"multiple_registrations/","title":"Multiple Service Registrations","text":"<p>Use factories to register multiple instances of the same class with different qualifiers. This is useful for scenarios where you need multiple configurations of the same service type.</p>"},{"location":"multiple_registrations/#example-multi-database-setup","title":"Example: Multi-Database Setup","text":"<p>Here's how to set up multiple database connections - a common scenario where you have a primary database for writes and a replica for reads.</p>"},{"location":"multiple_registrations/#registration","title":"Registration","text":"db_service.py<pre><code>from typing import Annotated\nfrom wireup import service, Inject\n\nclass DatabaseService:\n    def __init__(self, dsn: str) -&gt; None:\n        self.__connection = ...  # Connection initialization\n\n    def query(self) -&gt; ...:\n        return self.__connection.query(...)\n\n@service  # Default connection for writes\ndef primary_db(\n    dsn: Annotated[str, Inject(param=\"PRIMARY_DB_DSN\")]\n) -&gt; DatabaseService:\n    return DatabaseService(dsn)\n\n@service(qualifier=\"replica\")  # Read-only connection\ndef replica_db(\n    dsn: Annotated[str, Inject(param=\"REPLICA_DB_DSN\")]\n) -&gt; DatabaseService:\n    return DatabaseService(dsn)\n</code></pre>"},{"location":"multiple_registrations/#usage","title":"Usage","text":"repository.py<pre><code>@service\n@dataclass\nclass Repository:\n    primary: DatabaseService  # Default connection\n    replica: Annotated[DatabaseService, Inject(qualifier=\"replica\")]\n\n    def save(self, data: dict) -&gt; None:\n        return self.primary.query(...)  # Write operations\n\n    def get(self, id: int) -&gt; dict:\n        return self.replica.query(...)  # Read operations\n</code></pre> <p>The container will inject the appropriate database connection based on whether a qualifier is specified.</p>"},{"location":"parameters/","title":"Parameters","text":"<p>The container can also hold configuration parameters to configure services. This feature allows self-contained service declarations by adding <code>@service</code> and annotations to indicate what to inject.</p> <p>Warning</p> <p>Parameters are for application configuration only.  They should not be used to pass values around or as a global session object.</p> <p>Use parameters for app configuration like environment name, database URL, mailer URL, etc.</p>"},{"location":"parameters/#inject-by-name","title":"Inject by name","text":"<p>To inject a parameter by name, annotate the type with <code>Inject(param=\"param_name\")</code>.</p> <pre><code>@service\nclass GithubClient:\n    def __init__(self, api_key: Annotated[str, Inject(param=\"gh_api_key\")]) -&gt; None:\n        ...\n</code></pre>"},{"location":"parameters/#parameter-expressions","title":"Parameter expressions","text":"<p>You can interpolate parameters using a special syntax to retrieve and concatenate multiple parameter values.</p> <p>Note: The result is a string, so non-string parameters will be converted using <code>str()</code>.</p> <pre><code>def target(logs_dir: Annotated[str, Inject(expr=\"${cache_dir}/${env}/logs\")]) -&gt; None:\n    ...\n</code></pre>"},{"location":"parameters/#class-based-configuration","title":"\ud83c\udfed Class-based configuration","text":"<p>Wireup's parameter configuration is optional. You can use typed classes for configuration, supported via factories.</p> <p>Register your settings as a service and inject them into factories like regular dependencies.</p> <p>See Use Without Annotations for more info.</p>"},{"location":"services/","title":"Services","text":"<p>A service in Wireup is any class or function decorated with <code>@service</code>.  Services can live anywhere but must be registered with the container.</p> <p>When creating a container, you can use the <code>service_module</code> parameter to pass a list of modules which Wireup will recursively scan for services, or pass them individually to the <code>services</code> parameter.</p>"},{"location":"services/#class-services","title":"Class Services","text":"<p>The simplest way to define a service is with a class:</p> <pre><code>from wireup import service\n\n@service\nclass VehicleRepository: ...\n\n@service\nclass RentalService:\n    # VehicleRepository is automatically injected\n    def __init__(self, repository: VehicleRepository) -&gt; None: ...\n</code></pre>"},{"location":"services/#factory-services","title":"Factory Services","text":"<p>For complex initialization, use factories. These are regular functions decorated with <code>@service</code> that construct and return service instances. The function must have a return type. Wireup uses this to figure out what kind of service the factory creates.</p> <pre><code>@service\ndef create_payment_processor(\n    api_key: Annotated[str, Inject(param=\"STRIPE_API_KEY\")]\n) -&gt; PaymentProcessor:\n    processor = PaymentProcessor()\n    processor.configure(api_key)\n\n    return processor\n</code></pre>"},{"location":"services/#dependency-resolution","title":"Dependency Resolution","text":"<p>Wireup uses type annotations to resolve dependencies. Parameter names are for readability only:</p> <pre><code># These are equivalent:\n@service\ndef create_rental_service(repo: VehicleRepository) -&gt; RentalService:\n    return RentalService(repo)\n\n@service\ndef create_rental_service(vehicle_store: VehicleRepository) -&gt; RentalService:\n    return RentalService(vehicle_store)\n</code></pre> <p>Tip</p> <p>You might have noticed the use of <code>Injected[T]</code> in the documentation. In Wireup's own services, this is not necessary because Wireup assumes ownership of all dependencies for its services. However, this may not be the case when injecting into functions, as some arguments might be provided by other decorators or callers.</p> <p>When injecting into a function, Wireup requires the <code>Injected[T]</code> syntax to make it explicit that it should inject that parameter. This ensures that if the requested dependency is not known, an error is raised instead of silently skipping the parameter.</p>"},{"location":"testing/","title":"Testing","text":"<p>Unit testing service objects is meant to be easy as the container does not interfere in any way with the underlying classes.</p> <p>Classes can be instantiated as usual in tests, and you need to pass dependencies  such as services or parameters to them yourself.</p> <p>To specify custom behavior for tests, provide a custom implementation  or a subclass that returns test data.</p>"},{"location":"testing/#overriding","title":"Overriding","text":"<p>Sometimes you need to be able to swap a service object on the fly for a different one such as a mock.</p> <p>The <code>container.override</code> property provides access to a number of useful methods and context managers which help with overriding dependencies  (See override manager).</p> <p>Good to know</p> <ul> <li>Overriding only applies to future injections.</li> <li>Once a singleton service has been instantiated, it is not possible to directly replace any of its direct or transitive dependencies via overriding as the object is already in memory.</li> <li>When injecting interfaces and/or qualifiers, override the interface and/or qualifier  rather than the implementation that will be injected.</li> </ul> <p>Tip</p> <p>If you're using an integration to get the container instance you can use the <code>wireup.integration.xxx.get_app_container</code>  method. This returns the container associated with your application.</p>"},{"location":"testing/#context-manager","title":"Context Manager","text":"<pre><code>random_mock = MagicMock()\n# Chosen by fair dice roll. Guaranteed to be random.\nrandom_mock.get_random.return_value = 4\n\nwith container.override.service(target=RandomService, new=random_mock):\n    # Assuming in the context of a web app:\n    # /random endpoint has a dependency on RandomService\n    # requests to inject RandomService during the lifetime\n    # of this context manager will result in random_mock being injected instead.\n    response = client.get(\"/random\")\n</code></pre>"},{"location":"testing/#pytest","title":"Pytest","text":"app.py<pre><code>def create_app():\n    app = ...\n\n    container = wireup.create_container(...)\n    # Example shows FastAPI but any integration will work the same.\n    wireup.integration.fastapi.setup(container, app)\n\n    return app\n</code></pre> conftest.py<pre><code># This is a function scoped fixture which means \n# you'll get a fresh copy of the application and container every time.\n@pytest.fixture\ndef app():\n    return create_app()\n</code></pre> some_test_file.py<pre><code>from wireup.integration.fastapi import get_app_container\n\ndef test_something_with_mocked_db_service(client: TestClient, app):\n    with get_app_container(app).override.service(DBService, new=...):\n        response = client.get(\"/some/path\")\n\n    # Assert response and mock calls.\n</code></pre>"},{"location":"tips_tricks/","title":"Tips & Tricks","text":""},{"location":"tips_tricks/#reduce-init-boilerplate","title":"Reduce init boilerplate","text":"<p>Consider an order processing service that requires multiple dependencies. Here's how it looks with traditional initialization:</p> services/order_processor.py<pre><code>@service\nclass OrderProcessor:\n    def __init__(\n        self,\n        payment_gateway: PaymentGateway,\n        inventory_service: InventoryService,\n        order_repository: OrderRepository,\n    ):\n        self.payment_gateway = payment_gateway\n        self.inventory_service = inventory_service\n        self.order_repository = order_repository\n</code></pre> <p>Wireup lets you combine the <code>@service</code> decorator with dataclasses for a more concise syntax.</p> services/order_processor.py<pre><code>from dataclasses import dataclass\n\n@service\n@dataclass\nclass OrderProcessor:\n    payment_gateway: PaymentGateway\n    inventory_service: InventoryService\n    order_repository: OrderRepository\n</code></pre> <p>Using dataclasses eliminates the need to write the <code>__init__</code> method and manually assign each dependency, while maintaining type hints and making the code more maintainable.</p>"},{"location":"tips_tricks/#aliased-parameters","title":"Aliased parameters","text":"<p>If you don't like having string parameters in your service objects you can alias them instead.</p> <pre><code>def awesome_function(env: Annotated[str, Inject(param=\"env\")]) -&gt; None: ...\ndef other_awesome_function(env: Annotated[str, Inject(param=\"env\")]) -&gt; None: ...\n</code></pre> <p>Using type aliases</p> <pre><code>EnvParameter = Annotated[str, Inject(param=\"env\")]\n\ndef awesome_function(env: EnvParameter) -&gt; None: ...\ndef other_awesome_function(env: EnvParameter) -&gt; None: ...\n</code></pre>"},{"location":"upgrading/","title":"Upgrading","text":""},{"location":"upgrading/#upgrade-0160-to-10","title":"Upgrade 0.16.0 to 1.0","text":"<p>With the API now stable, deprecated features have been removed. Refer to the deprecation notices for upgrade guidance.</p>"},{"location":"upgrading/#removed-wireupdependencycontainer","title":"Removed <code>wireup.DependencyContainer</code>","text":"<p>The previous container was overly complex. It has been split into <code>wireup.SyncContainer</code> and <code>wireup.AsyncContainer</code>.</p> <p>Use <code>wireup.AsyncContainer</code> if you need to create async dependencies, as it supports both sync and async resources.</p> <p>Changes include:</p> <ul> <li>Removed <code>@container.register</code><ul> <li>Use <code>@service</code> on services or factories and specify the container during creation with <code>wireup.create_sync_container</code> or <code>wireup.create_async_container</code>.</li> </ul> </li> <li>Removed <code>@container.abstract</code><ul> <li>Similar to above, use the <code>@abstract</code> decorator.</li> </ul> </li> <li>Removed <code>@container.autowire</code><ul> <li>This is removed. See the Apply the container as a decorator docs for details.</li> </ul> </li> <li>Removed <code>container.has_type</code>.</li> <li><code>wireup.create_container</code> is now <code>wireup.create_sync_container</code> and <code>wireup.create_async_container</code>.</li> </ul>"},{"location":"upgrading/#removed-get_all-put-methods-of-parameterbag","title":"Removed get_all, put methods of <code>ParameterBag</code>.","text":"<p><code>ParameterBag</code> does not support mutations. Pass all parameters when creating the container.</p>"},{"location":"upgrading/#removed-support-for-default-values","title":"Removed support for default values","text":"<p>Using <code>foo: str = Inject(...)</code> is no longer supported. Use annotated types instead: <code>foo: Annotated[str, Inject(...)]</code>.</p>"},{"location":"upgrading/#removed-parameterenum","title":"Removed ParameterEnum","text":"<p><code>ParameterEnum</code> is removed. Use type definitions for parameters: <code>AppNameParameter = Annotated[str, Inject(name=\"app_name\")]</code>.</p>"},{"location":"upgrading/#removed-wire-wire","title":"Removed <code>Wire</code>, <code>wire</code>","text":"<p>Replace <code>Wire</code> or <code>wire</code> with <code>Inject</code>.</p>"},{"location":"upgrading/#removed-wireupcontainer-global","title":"Removed <code>wireup.container</code> global","text":"<p>The global <code>wireup.container</code> is removed. Create a container instance with <code>wireup.create_sync_container</code> or <code>wireup.create_async_container</code>.</p>"},{"location":"upgrading/#removed-warmup_container","title":"Removed <code>warmup_container</code>","text":"<p>This utility function is removed. Create a container instance with <code>wireup.create_sync_container</code> or <code>wireup.create_async_container</code>.</p>"},{"location":"upgrading/#removed-old-integrations","title":"Removed old integrations","text":"<p><code>wireup.integrations.flask_integration</code> is replaced by <code>wireup.integrations.flask</code>. <code>wireup.integrations.fastapi_integration</code> is replaced by <code>wireup.integrations.fastapi</code>.</p>"},{"location":"upgrading/#removed-initialize_container","title":"Removed <code>initialize_container</code>","text":"<p>This utility function is removed. Create a container instance with <code>wireup.create_sync_container</code> or <code>wireup.create_async_container</code>.</p>"},{"location":"upgrading/#removed-register_all_in_module","title":"Removed <code>register_all_in_module</code>","text":"<p>This utility function is removed. Register services by passing <code>service_modules</code> to <code>wireup.create_*_container</code>.</p>"},{"location":"upgrading/#removed-load_module","title":"Removed <code>load_module</code>","text":"<p>No direct replacement. Create a container instance with <code>wireup.create_sync_container</code> or <code>wireup.create_async_container</code>.</p>"},{"location":"upgrading/#removed-factoryduplicateserviceregistrationerror","title":"Removed <code>FactoryDuplicateServiceRegistrationError</code>","text":"<p>Use <code>DuplicateServiceRegistrationError</code>.</p>"},{"location":"upgrading/#removed-servicelifetime-enum-in-favor-of-literals","title":"Removed <code>ServiceLifetime</code> enum in favor of literals","text":"<p>Replace <code>ServiceLifetime.SINGLETON</code> with <code>\"singleton\"</code> and <code>ServiceLifetime.TRANSIENT</code> with <code>\"transient\"</code>.</p>"},{"location":"upgrading/#django-integration","title":"Django Integration","text":"<p>The <code>perform_wramup</code> setting is removed.</p>"},{"location":"upgrading/#flask-integration","title":"Flask Integration","text":"<p>The <code>import_flask_config</code> setting is removed. Expose Flask config directly to <code>create_sync_container</code>. See Flask integration docs for details.</p>"},{"location":"upgrading/#fastapi-integration","title":"FastAPI Integration","text":"<p>The integration no longer automatically exposes <code>fastapi.Request</code> as a Wireup dependency. Pass <code>wireup.integration.fastapi</code> in your service modules when creating a container if needed.</p>"},{"location":"use_without_annotations/","title":"Use without annotations","text":"<p>Wireup uses types, annotations, and decorators to manage dependencies, allowing you to write self-contained services. All the information needed to build a service is included and evolves with the service, reducing boilerplate by eliminating the need for factories for every service.</p> <p>If you prefer not to use annotations, you can use factories to create everything.</p>"},{"location":"use_without_annotations/#configuration","title":"Configuration","text":"<p>The example below uses class-based configuration using <code>pydantic-settings</code>, but any class configuration method will work similarly. This lets you bring your own configuration and replace Wireup parameters if they're not suitable for your project.</p> settings.py<pre><code>from pydantic_settings import BaseSettings, Field\n\n@dataclass\nclass Settings(BaseSettings):\n    gh_api_key: str = Field(alias=\"gh_api_key\")  \n    pg_dsn: PostgresDsn = Field(alias=\"pg_dsn\")  \n</code></pre>"},{"location":"use_without_annotations/#services","title":"Services","text":"<p>Next, define services like <code>GithubClient</code> and <code>DatabaseConnection</code>.</p> services/github_client.py<pre><code>@dataclass\nclass GithubClient:\n    api_key: str\n</code></pre> services/db.py<pre><code>@dataclass\nclass DatabaseConnection:\n    dsn: str\n</code></pre>"},{"location":"use_without_annotations/#factories","title":"Factories","text":"<p>Use factories to wire everything together.</p> factories.py<pre><code>from wireup import service, container\n\n@service\ndef settings_factory() -&gt; Settings:\n    return Settings()\n\n# Settings can now be injected like a regular service.\n@service\ndef github_client_factory(settings: Settings) -&gt; GithubClient:\n    return GithubClient(api_key=settings.gh_api_key)\n\n@service\ndef database_connection_factory(settings: Settings) -&gt; DatabaseConnection:\n    return DatabaseConnection(dsn=str(settings.pg_dsn))\n</code></pre>"},{"location":"versioning/","title":"Versioning Policy","text":"<p>Wireup follows Semantic Versioning (SemVer) to provide clear expectations about version compatibility.</p>"},{"location":"versioning/#version-numbers","title":"Version Numbers","text":"<p>Each version number follows the format <code>MAJOR.MINOR.PATCH</code>:</p> <ul> <li>MAJOR: Increments for backward-incompatible changes</li> <li>MINOR: Increments for new features (backward-compatible)</li> <li>PATCH: Increments for bug fixes (backward-compatible)</li> </ul>"},{"location":"versioning/#pre-release-versions-0xx","title":"Pre-release Versions (0.x.x)","text":"<p>Versions starting with <code>0</code> (e.g., <code>0.1.0</code>) are considered pre-release. During this phase:</p> <ul> <li>The API is considered unstable</li> <li>Minor version updates may include breaking changes</li> <li>Use version constraint <code>0.x.*</code> to receive bug fixes while avoiding breaking changes</li> </ul>"},{"location":"versioning/#public-api-definition","title":"Public API Definition","text":"<p>The following components constitute Wireup's public API:</p> <ol> <li>All direct exports from the <code>wireup</code> package</li> <li>All public members and interfaces of the exported objects</li> </ol> <p>Changes to these components are subject to semantic versioning rules.</p>"},{"location":"class/django_integration/","title":"Django","text":""},{"location":"class/django_integration/#wireup.integration.django-classes","title":"Classes","text":""},{"location":"class/django_integration/#wireup.integration.django.WireupSettings","title":"<code>WireupSettings</code>  <code>dataclass</code>","text":"<p>Class containing Wireup settings specific to Django.</p>"},{"location":"class/django_integration/#wireup.integration.django.WireupSettings-attributes","title":"Attributes","text":""},{"location":"class/django_integration/#wireup.integration.django.WireupSettings.service_modules","title":"<code>service_modules: List[Union[str, ModuleType]]</code>  <code>instance-attribute</code>","text":"<p>List of modules containing wireup service registrations.</p>"},{"location":"class/django_integration/#wireup.integration.django-functions","title":"Functions","text":""},{"location":"class/django_integration/#wireup.integration.django.get_app_container","title":"<code>get_app_container()</code>","text":"<p>Return the container instance associated with the current django application.</p>"},{"location":"class/django_integration/#wireup.integration.django.get_request_container","title":"<code>get_request_container()</code>","text":"<p>When inside a request, returns the scoped container instance handling the current request.</p>"},{"location":"class/fastapi_integration/","title":"FastAPI","text":""},{"location":"class/fastapi_integration/#wireupintegrationfastapi","title":"wireup.integration.fastapi","text":""},{"location":"class/fastapi_integration/#wireup.integration.fastapi-classes","title":"Classes","text":""},{"location":"class/fastapi_integration/#wireup.integration.fastapi-functions","title":"Functions","text":""},{"location":"class/fastapi_integration/#wireup.integration.fastapi.fastapi_request_factory","title":"<code>fastapi_request_factory()</code>","text":"<p>Provide the current FastAPI request as a dependency.</p> <p>Note that this requires the Wireup-FastAPI integration to be set up.</p>"},{"location":"class/fastapi_integration/#wireup.integration.fastapi.get_app_container","title":"<code>get_app_container(app)</code>","text":"<p>Return the container associated with the given FastAPI application.</p>"},{"location":"class/fastapi_integration/#wireup.integration.fastapi.get_request_container","title":"<code>get_request_container()</code>","text":"<p>When inside a request, returns the scoped container instance handling the current request.</p>"},{"location":"class/fastapi_integration/#wireup.integration.fastapi.setup","title":"<code>setup(container, app)</code>","text":"<p>Integrate Wireup with FastAPI.</p> <p>Setup performs the following: * Injects dependencies into HTTP and WebSocket routes. * Creates a new container scope for each request, with a scoped lifetime matching the request duration. * Closes the Wireup container upon app shutdown using the lifespan context.</p> <p>For more details, visit: https://maldoinc.github.io/wireup/latest/integrations/fastapi/</p> <p>Note: To trigger lifespan events in the FastAPI test client, use the client as a context manager. <pre><code>@pytest.fixture()\ndef client(app: FastAPI) -&gt; Iterator[TestClient]:\n    with TestClient(app) as client:\n        yield client\n</code></pre></p>"},{"location":"class/flask_integration/","title":"Flask","text":""},{"location":"class/flask_integration/#wireupintegrationflask","title":"wireup.integration.flask","text":""},{"location":"class/flask_integration/#wireup.integration.flask-functions","title":"Functions","text":""},{"location":"class/flask_integration/#wireup.integration.flask.get_app_container","title":"<code>get_app_container(app)</code>","text":"<p>Return the container associated with the given application.</p>"},{"location":"class/flask_integration/#wireup.integration.flask.get_request_container","title":"<code>get_request_container()</code>","text":"<p>Return the container handling the current request.</p>"},{"location":"class/flask_integration/#wireup.integration.flask.setup","title":"<code>setup(container, app)</code>","text":"<p>Integrate Wireup with Flask.</p> <p>Setup performs the following: * Injects dependencies into Flask views. * Creates a new container scope for each request, with a scoped lifetime matching the request duration.</p>"},{"location":"class/override_manager/","title":"OverrideManager","text":"<p>Enables overriding of services registered with the container.</p>"},{"location":"class/override_manager/#wireup.ioc.override_manager.OverrideManager-functions","title":"Functions","text":""},{"location":"class/override_manager/#wireup.ioc.override_manager.OverrideManager.clear","title":"<code>clear()</code>","text":"<p>Clear active service overrides.</p>"},{"location":"class/override_manager/#wireup.ioc.override_manager.OverrideManager.delete","title":"<code>delete(target, qualifier=None)</code>","text":"<p>Clear active override for the <code>target</code> service.</p>"},{"location":"class/override_manager/#wireup.ioc.override_manager.OverrideManager.service","title":"<code>service(target, new, qualifier=None)</code>","text":"<p>Override the <code>target</code> service with <code>new</code> for the duration of the context manager.</p> <p>Future requests to inject <code>target</code> will result in <code>new</code> being injected.</p> <p>Parameters:</p> Name Type Description Default <code>target</code> <code>type</code> <p>The target service to override.</p> required <code>qualifier</code> <code>Qualifier | None</code> <p>The qualifier of the service to override. Set this if service is registered with the qualifier parameter set to a value.</p> <code>None</code> <code>new</code> <code>Any</code> <p>The new object to be injected instead of <code>target</code>.</p> required"},{"location":"class/override_manager/#wireup.ioc.override_manager.OverrideManager.services","title":"<code>services(overrides)</code>","text":"<p>Override a number of services with new for the duration of the context manager.</p>"},{"location":"class/override_manager/#wireup.ioc.override_manager.OverrideManager.set","title":"<code>set(target, new, qualifier=None)</code>","text":"<p>Override the <code>target</code> service with <code>new</code>.</p> <p>Future requests to inject <code>target</code> will result in <code>new</code> being injected.</p> <p>Parameters:</p> Name Type Description Default <code>target</code> <code>type</code> <p>The target service to override.</p> required <code>qualifier</code> <code>Qualifier | None</code> <p>The qualifier of the service to override. Set this if service is registered with the qualifier parameter set to a value.</p> <code>None</code> <code>new</code> <code>Any</code> <p>The new object to be injected instead of <code>target</code>.</p> required"},{"location":"class/parameter_bag/","title":"ParameterBag","text":"<p>Parameter flat key-value store for use with a container.</p> <p>Allows storing and retrieving of parameters in the bag. Templated strings can be used to interpolate a string referencing parameters.</p>"},{"location":"class/parameter_bag/#wireup.ioc.parameter.ParameterBag-functions","title":"Functions","text":""},{"location":"class/parameter_bag/#wireup.ioc.parameter.ParameterBag.__init__","title":"<code>__init__(values=None)</code>","text":"<p>Initialize an empty ParameterBag.</p> <p>ParameterBag holds a flat key-value store of parameter values. __bag: A dictionary to store parameter values. __cache: A cache for interpolated values.</p>"},{"location":"class/parameter_bag/#wireup.ioc.parameter.ParameterBag.get","title":"<code>get(param)</code>","text":"<p>Get the value of a parameter.</p> <p>If the parameter is templated, interpolate it first by replacing placeholders with parameter values.</p> <p>Parameters:</p> Name Type Description Default <code>param</code> <code>ParameterReference</code> <p>The parameter to retrieve.</p> required <p>Returns:</p> Type Description <code>Any</code> <p>The parameter's value.</p>"},{"location":"class/wireup/","title":"wireup","text":""},{"location":"class/wireup/#wireup","title":"<code>wireup</code>","text":""},{"location":"class/wireup/#wireup-attributes","title":"Attributes","text":""},{"location":"class/wireup/#wireup.Injected","title":"<code>Injected = Annotated[T, Inject()]</code>  <code>module-attribute</code>","text":"<p>Let the Wireup container know it must inject this parameter.</p> <p>Alias of <code>Annotated[T, Inject()]</code>.</p>"},{"location":"class/wireup/#wireup-classes","title":"Classes","text":""},{"location":"class/wireup/#wireup.ParameterBag","title":"<code>ParameterBag</code>","text":"<p>Parameter flat key-value store for use with a container.</p> <p>Allows storing and retrieving of parameters in the bag. Templated strings can be used to interpolate a string referencing parameters.</p>"},{"location":"class/wireup/#wireup.ParameterBag-functions","title":"Functions","text":""},{"location":"class/wireup/#wireup.ParameterBag.__init__","title":"<code>__init__(values=None)</code>","text":"<p>Initialize an empty ParameterBag.</p> <p>ParameterBag holds a flat key-value store of parameter values. __bag: A dictionary to store parameter values. __cache: A cache for interpolated values.</p>"},{"location":"class/wireup/#wireup.ParameterBag.get","title":"<code>get(param)</code>","text":"<p>Get the value of a parameter.</p> <p>If the parameter is templated, interpolate it first by replacing placeholders with parameter values.</p> <p>Parameters:</p> Name Type Description Default <code>param</code> <code>ParameterReference</code> <p>The parameter to retrieve.</p> required <p>Returns:</p> Type Description <code>Any</code> <p>The parameter's value.</p>"},{"location":"class/wireup/#wireup.ServiceOverride","title":"<code>ServiceOverride</code>  <code>dataclass</code>","text":"<p>Data class to represent a service override. Target type will be replaced with the new type by the container.</p>"},{"location":"class/wireup/#wireup-functions","title":"Functions","text":""},{"location":"class/wireup/#wireup.Inject","title":"<code>Inject(*, param=None, expr=None, qualifier=None)</code>","text":"<p>Let the Wireup container know it must inject this parameter.</p> <p>When used without parameters as <code>Annotated[T, Inject()]</code>, you can also use the alias <code>Injected[T]</code>.</p> <p>Parameters:</p> Name Type Description Default <code>param</code> <code>str | None</code> <p>Inject a specific parameter by name.</p> <code>None</code> <code>expr</code> <code>str | None</code> <p>Inject a string value using a templated string. Parameters within <code>${}</code> will be replaced with their corresponding values.</p> <code>None</code> <code>qualifier</code> <code>Qualifier | None</code> <p>Specify which implementation to bind when multiple components implement an interface registered in the container via <code>@abstract</code>.</p> <code>None</code>"},{"location":"class/wireup/#wireup.abstract","title":"<code>abstract(cls)</code>","text":"<p>Mark the decorated class as an abstract service.</p>"},{"location":"class/wireup/#wireup.create_async_container","title":"<code>create_async_container(service_modules=None, services=None, parameters=None)</code>","text":"<p>Create a Wireup container.</p> <p>Parameters:</p> Name Type Description Default <code>service_modules</code> <code>list[ModuleType] | None</code> <p>This is a list of top-level modules containing services registered with <code>@service</code> or <code>@abstract</code>. Wireup will recursively scan the modules and register services found in them.</p> <code>None</code> <code>services</code> <code>list[Any] | None</code> <p>A list of classes or functions decorated with <code>@service</code> or <code>@abstract</code> to register with the container instance. Use this when you want to explicitly list services.</p> <code>None</code> <code>parameters</code> <code>dict[str, Any] | None</code> <p>Dict containing parameters you want to expose to the container. Services or factories can request parameters via the <code>Inject(param=\"name\")</code> syntax.</p> <code>None</code> <p>Raises:</p> Type Description <code>WireupError</code> <p>Raised if the dependencies cannot be fully resolved.</p>"},{"location":"class/wireup/#wireup.create_sync_container","title":"<code>create_sync_container(service_modules=None, services=None, parameters=None)</code>","text":"<p>Create a Wireup container.</p> <p>Parameters:</p> Name Type Description Default <code>service_modules</code> <code>list[ModuleType] | None</code> <p>This is a list of top-level modules containing services registered with <code>@service</code> or <code>@abstract</code>. Wireup will recursively scan the modules and register services found in them.</p> <code>None</code> <code>services</code> <code>list[Any] | None</code> <p>A list of classes or functions decorated with <code>@service</code> or <code>@abstract</code> to register with the container instance. Use this when you want to explicitly list services.</p> <code>None</code> <code>parameters</code> <code>dict[str, Any] | None</code> <p>Dict containing parameters you want to expose to the container. Services or factories can request parameters via the <code>Inject(param=\"name\")</code> syntax.</p> <code>None</code> <p>Raises:</p> Type Description <code>WireupError</code> <p>Raised if the dependencies cannot be fully resolved.</p>"},{"location":"class/wireup/#wireup.inject_from_container","title":"<code>inject_from_container(container, scoped_container_supplier=None)</code>","text":"<p>Inject dependencies into the decorated function based on annotations.</p> <p>Parameters:</p> Name Type Description Default <code>container</code> <code>SyncContainer | AsyncContainer</code> <p>The main container instance created via <code>wireup.create_sync_container</code> or <code>wireup.create_async_container</code>.</p> required <code>scoped_container_supplier</code> <code>Callable[[], ScopedSyncContainer | ScopedAsyncContainer] | None</code> <p>An optional callable that returns the current scoped container instance. If provided, it will be used to create scoped dependencies. If not provided, the container will automatically enter a scope. Provide a scoped_container_supplier if you need to manage the container's scope manually. For example, in web frameworks, you might enter the scope at the start of a request in middleware so that other middlewares can access the scoped container if needed.</p> <code>None</code>"},{"location":"class/wireup/#wireup.service","title":"<code>service(obj=None, *, qualifier=None, lifetime='singleton')</code>","text":"<p>Mark the decorated class or function as a Wireup service.</p>"},{"location":"integrations/","title":"Integrations","text":"<p>Wireup is framework-agnostic and can be used in any project, but it also provides integrations for the following frameworks:</p> <ul> <li> Django</li> <li> FastAPI</li> <li> Flask</li> </ul>"},{"location":"integrations/django/","title":"Django Integration","text":"<p>Wireup provides seamless integration with Django through the <code>wireup.integration.django</code> module, enabling dependency injection in Django applications.</p> <p>Features:</p> <ul> <li> Dependency injection in function-based and class-based views (sync and async).</li> <li> Access to <code>django.http.HttpRequest</code> as an injectable dependency.</li> <li> Django settings available as Wireup parameters.</li> <li> Request-scoped container lifecycle management.</li> </ul>"},{"location":"integrations/django/#initialize-the-integration","title":"Initialize the integration","text":"<p>Add the following to your Django settings:</p> settings.py<pre><code>import os\nfrom wireup.integration.django import WireupSettings\n\nINSTALLED_APPS = [\n    # ...existing code...\n    \"wireup.integration.django\"\n]\n\nMIDDLEWARE = [\n    \"wireup.integration.django.wireup_middleware\",\n    # ...existing code...\n]\n\nWIREUP = WireupSettings(\n    service_modules=[\"mysite.polls.services\"]  # Your service modules here\n)\n\n# Additional application settings\nS3_BUCKET_TOKEN = os.environ[\"S3_BUCKET_ACCESS_TOKEN\"]\n</code></pre>"},{"location":"integrations/django/#inject-django-settings","title":"Inject Django settings","text":"<p>You can inject Django settings into your services:</p> mysite/polls/services/s3_manager.py<pre><code>from wireup import service, Inject\nfrom typing import Annotated\n\n@service\nclass S3Manager:\n    # Reference configuration by name\n    def __init__(self, token: Annotated[str, Inject(param=\"S3_BUCKET_TOKEN\")]) -&gt; None: ...\n\n    def upload(self, file: File) -&gt; None: ...\n</code></pre> <p>You can also use Django settings in factory functions:</p> mysite/polls/services/github_client.py<pre><code>from wireup import service\nfrom django.conf import settings\n\nclass GithubClient:\n    def __init__(self, api_key: str) -&gt; None: ...\n\n@service\ndef github_client_factory() -&gt; GithubClient:\n    return GithubClient(api_key=settings.GH_API_KEY)\n</code></pre>"},{"location":"integrations/django/#inject-the-current-request","title":"Inject the current request","text":"<p>The integration exposes the current Django request as a <code>scoped</code> lifetime dependency, which can be injected into <code>scoped</code> or <code>transient</code> services:</p> mysite/polls/services/auth_service.py<pre><code>from django.http import HttpRequest\nfrom wireup import service\n\n@service(lifetime=\"scoped\")\nclass AuthService:\n    def __init__(self, request: HttpRequest) -&gt; None:\n        self.request = request\n</code></pre>"},{"location":"integrations/django/#inject-dependencies-in-views","title":"Inject dependencies in views","text":"<p>To inject dependencies in views, simply request them by their type:</p> app/views.py<pre><code>from django.http import HttpRequest, HttpResponse\nfrom mysite.polls.services import S3Manager\nfrom wireup import Injected\n\ndef upload_file_view(\n    request: HttpRequest, \n    s3_manager: Injected[S3Manager]\n) -&gt; HttpResponse:\n    # Use the injected S3Manager instance\n    return HttpResponse(...)\n</code></pre> <p>Class-based views are also supported. Specify dependencies in the class <code>__init__</code> function.</p> <p>For more examples, see the Wireup Django integration tests.</p>"},{"location":"integrations/django/#accessing-the-container","title":"Accessing the container","text":"<p>Access the Wireup container using the provided functions:</p> <pre><code>from wireup.integration.django import get_app_container, get_request_container\n\n# Get application-wide container\napp_container = get_app_container()\n\n# Get request-scoped container\nrequest_container = get_request_container()\n</code></pre>"},{"location":"integrations/django/#testing","title":"Testing","text":"<p>For general testing tips with Wireup refer to the test docs.  With Django you can override dependencies in the container as follows:</p> test_thing.py<pre><code>from wireup.integration.django import get_app_container\n\ndef test_override():\n    class DummyGreeter(GreeterService):\n        def greet(self, name: str):\n            return f\"Hi, {name}\"\n\n    with get_app_container().override.service(GreeterService, new=DummyGreeter()):\n        res = self.client.get(\"/greet?name=Test\")\n        assert res.status_code == 200\n</code></pre>"},{"location":"integrations/django/#api-reference","title":"API Reference","text":"<ul> <li>django_integration</li> </ul>"},{"location":"integrations/fastapi/","title":"FastAPI","text":"<p>Dependency injection for FastAPI is available in the <code>wireup.integration.fastapi</code> module.</p> <p>Features:</p> <ul> <li> Inject dependencies in FastAPI routes.</li> <li> Expose <code>fastapi.Request</code> as a <code>scoped</code> Wireup dependency.</li> <li> Close the Wireup container upon application termination for proper resource cleanup.</li> </ul>"},{"location":"integrations/fastapi/#initialize-the-integration","title":"Initialize the integration","text":"<p>To initialize the integration, call <code>wireup.integration.fastapi.setup</code> after adding all routers.</p> <pre><code>container = wireup.create_async_container(\n    # Add service modules.\n    service_modules=[\n        # Top level module containing service registrations.\n        services,\n        # Include the integration if you require `fastapi.Request` in Wireup services.\n        wireup.integration.fastapi\n    ],\n    # Expose parameters to Wireup as necessary. \n    parameters={\n        \"debug\": settings.DEBUG\n    }\n)\nwireup.integration.fastapi.setup(container, app)\n</code></pre>"},{"location":"integrations/fastapi/#inject-in-http-and-websocket-routes","title":"Inject in HTTP and WebSocket routes","text":"<p>To inject dependencies, add the type to the route's signature and annotate them as necessary. See Annotations for more details.</p> HTTPWebSocket HTTP Route<pre><code>@app.get(\"/random\")\nasync def target(\n    random_service: Injected[RandomService],\n    is_debug: Annotated[bool, Inject(param=\"debug\")],\n\n    # This is a regular FastAPI dependency.\n    lucky_number: Annotated[int, Depends(get_lucky_number)]\n): ...\n</code></pre> WebSocket Route<pre><code>@app.websocket(\"/ws\")\nasync def ws(websocket: WebSocket, greeter: Injected[GreeterService]): ...\n</code></pre> <p>Optional Performance Optimization</p> <p>Optimize dependency injection performance by using a custom APIRoute class.  This reduces overhead in endpoints that use Wireup injection by avoiding redundant processing.</p> <pre><code>from fastapi import APIRouter\nfrom wireup.integration.fastapi import WireupRoute\n\nrouter = APIRouter(route_class=WireupRoute)\n</code></pre> <p>If you already have a custom route class, you can inherit from WireupRoute instead.</p> <p>Under the hood: FastAPI processes all route parameters, including ones meant for Wireup.  The WireupRoute class optimizes this by making Wireup-specific parameters only visible to Wireup,  removing unnecessary processing by FastAPI's dependency injection system.</p>"},{"location":"integrations/fastapi/#inject-fastapi-request","title":"Inject FastAPI request","text":"<p>A key feature of the integration is to expose <code>fastapi.Request</code> in Wireup. To allow injecting it in your services you must add <code>wireup.integration.fastapi</code> module to your service modules when creating a container.</p> <p>Services depending on it should be transient or scoped, so that these are not shared across requests.</p> <pre><code>@service(lifetime=\"scoped\")\nclass HttpAuthenticationService:\n    def __init__(self, request: fastapi.Request) -&gt; None: ...\n\n\n@service(lifetime=\"scoped\")\ndef example_factory(request: fastapi.Request) -&gt; ExampleService: ...\n</code></pre>"},{"location":"integrations/fastapi/#accessing-the-container","title":"Accessing the Container","text":"<p>If you ever need to access the Wireup container directly, use the provided functions:</p> <pre><code>from wireup.integration.fastapi import get_app_container, get_request_container\n\n# Get application-wide container.\napp_container: AsyncContainer = get_app_container(app)\n\n# Get request-scoped container.\n# This is what is currently injecting services on the active request.\nrequest_container: ScopedAsyncContainer = get_request_container()\n</code></pre>"},{"location":"integrations/fastapi/#get-dependencies-in-middleware","title":"Get dependencies in middleware","text":"<p>Wireup integration performs injection only in FastAPI routes. If the container is not stored globally, you can get a reference to it using <code>get_app_container</code> and <code>get_request_container</code> from the <code>wireup.integration.fastapi</code> module.</p> example_middleware.py<pre><code>from wireup.integration.fastapi import get_request_container\n\nasync def example_middleware(request: Request, call_next) -&gt; Response:\n    container = get_request_container()\n    ...\n\n    return await call_next(request)\n</code></pre>"},{"location":"integrations/fastapi/#get-dependencies-in-depends","title":"Get dependencies in <code>Depends</code>.","text":"<p>Similarly, you can get a reference to the container in a FastAPI dependency.</p> <pre><code>from wireup.integration.fastapi import get_request_container\n\nasync def example_dependency(request: Request, other_dependency: Depends(...)):\n    container = get_request_container()\n    ...\n</code></pre> <p>Warning</p> <p>Use <code>fastapi.Depends</code> only for specific cases. When using Wireup, let it manage all dependencies instead of mixing it with <code>fastapi.Depends</code>.</p> <p>Note that while this approach works, the reverse does not. You cannot require <code>fastapi.Depends</code> objects in Wireup services.</p>"},{"location":"integrations/fastapi/#testing","title":"Testing","text":"<p>For general testing tips with Wireup refer to the test docs.  With the FastAPI integration, you can override dependencies in the container as follows.</p> test_thing.py<pre><code>from wireup.integration.fastapi import get_app_container\n\ndef test_override(client):\n    class DummyGreeter(GreeterService):\n        def greet(self, name: str) -&gt; str:\n            return f\"Hi, {name}\"\n\n    with get_app_container(app).override.service(GreeterService, new=DummyGreeter()):\n        res = client.get(\"/greet?name=Test\")\n</code></pre> <p>See FastAPI integration tests for more examples.</p> <p>Warning</p> <p>The Wireup integration relies on FastAPI's lifespan events to close the container upon termination. To ensure these events are triggered during testing, instantiate the test client as a context manager. This is a requirement due to FastAPI's design, not a limitation of Wireup.</p> <pre><code>@pytest.fixture()\ndef client(app: FastAPI) -&gt; Iterator[TestClient]:\n    with TestClient(app) as client:\n        yield client\n</code></pre>"},{"location":"integrations/fastapi/#api-reference","title":"API Reference","text":"<ul> <li>fastapi_integration</li> </ul>"},{"location":"integrations/flask/","title":"Flask","text":"<p>Dependency injection for Flask is available in the <code>wireup.integration.flask</code> module.</p> <p>Features:</p> <ul> <li> Dependency injection in function-based and class-based views (sync and async)</li> <li> Request-scoped container lifecycle management.</li> </ul>"},{"location":"integrations/flask/#initialize-the-integration","title":"Initialize the integration","text":"<p>To initialize the integration, call <code>wireup.integration.flask.setup</code> after adding all views and configuration.</p> <pre><code>from wireup import Inject, Injected, service\n\napp = Flask(__name__)\napp.config[\"FOO\"] = \"bar\"\n\ncontainer = wireup.create_sync_container(\n    # service_modules is a list of top-level modules with service registrations.\n    service_modules=[services],\n    parameters={\n        **app.config, # Optionally expose flask configuration to the container.\n        \"FOO\": \"bar\"\n    }\n)\n\n# Initialize the integration.\n# Must be called after views and configuration have been added.\nwireup.integration.flask.setup(container, app)\n</code></pre>"},{"location":"integrations/flask/#inject-in-flask-views","title":"Inject in Flask Views","text":"<p>To inject dependencies, add the type to the views' signature and annotate them as necessary. See Annotations for more details.</p> Flask View<pre><code>@app.get(\"/random\")\ndef get_random(random: Injected[RandomService]):\n    return {\"lucky_number\": random.get_random()}\n\n@app.get(\"/env\")\ndef get_environment(\n    is_debug: Annotated[bool, Inject(param=\"DEBUG\")], \n    foo: Annotated[str, Inject(param=\"FOO\")]\n):\n    return {\"debug\": is_debug, \"foo\": foo}\n</code></pre>"},{"location":"integrations/flask/#accessing-the-container","title":"Accessing the Container","text":"<p>If you ever need to access the Wireup container directly, use the provided functions:</p> <pre><code>from wireup.integration.flask import get_app_container, get_request_container\n\n# Get application-wide container\napp_container = get_app_container(app)\n\n# Get request-scoped container\nrequest_container = get_request_container()\n</code></pre>"},{"location":"integrations/flask/#testing","title":"Testing","text":"<p>For general testing tips with Wireup refer to the test docs.  With the Flask integration, you can override dependencies in the container as follows.</p> test_thing.py<pre><code>from wireup.integration.flask import get_app_container\n\ndef test_override():\n    class DummyGreeter(GreeterService):\n        def greet(self, name: str) -&gt; str:\n            return f\"Hi, {name}\"\n\n    with get_app_container(app).override.service(GreeterService, new=DummyGreeter()):\n        res = self.client.get(\"/greet?name=Test\")\n</code></pre> <p>See Flask integration tests for more examples.</p>"},{"location":"integrations/flask/#api-reference","title":"API Reference","text":"<ul> <li>flask_integration</li> </ul>"}]}