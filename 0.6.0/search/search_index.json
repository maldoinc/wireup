{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"WireUp","text":"<p>Dependency injection container with a focus on developer experience, type safety and ease of use.</p> <p>New: Dependency injection for Flask</p> <p>Simplify usage in Flask applications by using the new Flask integration!</p> <ul> <li>Automatically inject dependencies on views without having to manually call autowire.</li> <li>Expose flask application configuration in the container.</li> </ul>"},{"location":"#key-features","title":"Key features","text":"Dependency Injection                  Inject services and configuration using a clean and intuitive syntax.                    Auto-configuration                  Automatically inject dependencies based on their types without additional configuration.                    Short and long-lived processes                  Suitable for use in long-running as well as short-lived processes.         Preload services for performance or lazily inject to instantiate only what you use.                    Interfaces / Abstract classes                  Define abstract types and have the container automatically inject the implementation.         Say goodbye to mocks in your tests!                    Multiple Containers                  Use the provided container or instantiate and use multiple ones depending on your project's needs.                   Factory pattern                  Defer instantiation to specialized factories for full control over object creation when necessary.                    Singletons/Transient dependencies                  Declare dependencies as transient or singletons which tells the container whether          to inject a fresh copy or reuse existing instances.                    Framework Agnostic                  Seamlessly integrate with popular web frameworks like Django, Flask and FastAPI         to simplify dependency management."},{"location":"#license","title":"License","text":"<p>This project is licensed under the terms of the MIT license.</p>"},{"location":"annotations/","title":"Annotations","text":"<p>WireUp relies on various kind of type annotations or hints to be able to autowire dependencies. When it is not possible to automatically locate a given dependency the argument must be annotated with additional metadata.</p>"},{"location":"annotations/#when-do-you-need-to-provide-annotations","title":"When do you need to provide annotations.","text":"<p>Optional when injecting:</p> <ul> <li>Services</li> <li>Injecting an interface which has only one implementing service</li> </ul> <p>Required when injecting:</p> <ul> <li>Parameters</li> <li>Parameter expressions</li> <li>Injecting an interface which has multiple implementing services.</li> </ul>"},{"location":"annotations/#annotation-types","title":"Annotation types","text":"<p>Wireup supports two types of annotations. Using Python's <code>Annotated</code> or by using default values.</p>"},{"location":"annotations/#annotated","title":"Annotated","text":"<p>This is the preferred method for Python 3.9+ and moving forward. It is also recommended to backport this using <code>typing_extensions</code> for Python 3.8.</p> <pre><code>@container.autowire\ndef target(\n    env: Annotated[str, Wire(param=\"env_name\")],\n    logs_cache_dir: Annotated[str, Wire(expr=\"${cache_dir}/logs\")],\n):\n    ...\n</code></pre>"},{"location":"annotations/#default-values","title":"Default values","text":"<p>This relies on the use of default values to inject parameters. Anything that can be passed to <code>Annotated</code> may also be used here.</p> <pre><code>@container.autowire\ndef target(\n    env: str = wire(param=\"env_name\"), \n    logs_cache_dir: str = wire(expr=\"${cache_dir}/logs\")\n):\n    ...\n</code></pre>"},{"location":"annotations/#explicit-injection-annotation","title":"Explicit injection annotation","text":"<p>Even though annotating services is optional, you CAN still annotate them to be explicit about what will   be injected. This also has the benefit of making the container throw when such as service  does not exist instead of silently skipping this parameter.</p> <pre><code>@container.autowire\ndef target(random_service: Annotated[RandomService, Wire()]):\n    ...\n</code></pre>"},{"location":"demo_app/","title":"Demo application","text":"<p>Check out maldoinc/wireup-demo  for a demo Flask application using WireUp.</p> <p>It shows creation, injection and testing in the context of a simple \"Blog\" application.</p>"},{"location":"factory_functions/","title":"Factory functions","text":"<p>Factory functions allow the container to wire dependencies that require additional logic to create  or be able to inject objects it doesn't own.</p> <p>Typically getting the necessary dependencies is enough to construct an object. However, there are scenarios where you need to delegate the creation of an object to a special function called a  factory.</p>"},{"location":"factory_functions/#use-cases","title":"Use cases","text":"<p>Some of the use cases for factories are as follows:</p> <ul> <li>Object construction needs additional logic or configuration.</li> <li>Depending on the runtime environment or configuration, you may need to create different objects  inheriting from the same base (See: Strategy Pattern) or configure them differently. </li> <li>Gradually introduce DI into an existing project where the container should be able to inject dependencies created elsewhere.  Such as injecting the same database connection as the rest of the application.</li> <li>Eliminate services which have only one method that returns the same object and instead inject the object directly.<ul> <li>Register the result of a service's method as its own service. Instead of calling <code>db_service.get_db()</code> every time,   inject the session directly.</li> </ul> </li> </ul>"},{"location":"factory_functions/#usage","title":"Usage","text":"<p>In order for the container to inject these dependencies you must register the factory function. You can do this by using the <code>@container.register</code> decorator or by calling <code>container.register(fn)</code> directly.</p> <p>When the container needs to inject a dependency it checks known factories to see if any of them can create it.</p> <p>Info</p> <p>The return type of the function is mandatory to annotate as tells the container what  type of dependency it can create.</p> <p>Warning</p> <p>Factories can only depend on objects known by the container!</p>"},{"location":"factory_functions/#examples","title":"Examples","text":"<p>Assume in the context of a web application a class <code>User</code> exists and represents a user of the system.</p> <pre><code># Instead of doing the following over and over again\ndef get_user_logs(auth_service: AuthService):\n    current_user = auth_service.get_current_user()\n    ...\n\n\n\n# You can create a factory and inject the authenticated user directly.\n# You may want to create a new type to make a disctinction on the type of user this is.\nAuthenticatedUser = NewType(\"AuthenticatedUser\", User)\n\n@container.register(lifetime=ServiceLifetime.TRANSIENT)\ndef get_current_user(auth_service: AuthService) -&gt; AuthenticatedUser:\n    return auth_service.get_current_user()\n\n# Now it is possible to inject the authenticated user directly wherever it is necessary.\ndef get_user_logs(user: AuthenticatedUser):\n    ...\n</code></pre> <p>Assume a base class <code>Notifier</code> with implementations that define how the notification is sent (IMAP, POP, WebHooks, etc.) Given a user it is possible to instantiate the correct type of notifier based on user preferences.</p> <pre><code>@container.register(lifetime=ServiceLifetime.TRANSIENT)\ndef get_user_notifier(user: AuthenticatedUser) -&gt; Notifier:\n    notifier_type = ...\n\n    return container.get(notifier_type)\n</code></pre> <p>When injecting <code>Notifier</code> the correct type will be created based on the authenticated user's preferences.</p>"},{"location":"factory_functions/#links","title":"Links","text":"<ul> <li>Introduce to an existing project</li> </ul>"},{"location":"flask_integration/","title":"Flask Integration","text":"<p>Dependency injection for Flask (all versions) is available via the first-party integration wireup provides, available in <code>wireup.integration.flask_integration</code>.</p> <p>Features:</p> <ul> <li>Automatically decorate Flask views and blueprints where the container is being used.<ul> <li>Eliminates the need for <code>@container.autowire</code> in views.</li> <li>Views without container references will not be decorated.</li> </ul> </li> <li>Expose Flask configuration in the container's parameters.</li> </ul>"},{"location":"flask_integration/#examples","title":"Examples","text":"<pre><code>app = Flask(__name__)\napp.config[\"FOO\"] = \"bar\"\n\n@app.get(\"/random\")\ndef get_random(random: RandomService):\n    return {\"lucky_number\": random.get_random()}\n\n@app.get(\"/env\")\ndef get_environment(\n    is_debug: Annotated[bool, Wire(param=\"DEBUG\")], \n    foo: Annotated[str, Wire(param=\"FOO\")]\n):\n    return {\"debug\": is_debug, \"foo\": foo}\n\n\nif __name__ == '__main__':\n    # Initialize the integration.\n    # Must be called after all views and configuration have been added.\n    # Pass to service_modules a list of top-level modules where your services reside.\n    wireup_init_flask_integration(app, service_modules=[services])\n    app.run()\n</code></pre>"},{"location":"flask_integration/#using-parameter-enums","title":"Using parameter enums","text":"<p>Parameter enums offer a typed way of representing parameters.  See Parameter Enum documentation for more details</p>"},{"location":"flask_integration/#api-reference","title":"Api Reference","text":"<ul> <li>flask_integration</li> <li>ParameterEnum</li> </ul>"},{"location":"interfaces/","title":"Working with Interfaces","text":"<p>When autowiring dependencies, you might want to inject an interface rather than  the concrete implementation directly. Since Python doesn't have built-in interfaces, you can leverage any class  that's marked as abstract within the container.</p>"},{"location":"interfaces/#example","title":"Example","text":"<p>The following code registers <code>Engine</code> as an interface. This implies that <code>Engine</code> can't be directly injected.  Instead, a dependency that implements the interface must be present and also be registered in the container.</p> <p>To autowire interfaces, you can simply register a dependency that directly inherits the interface  within the container. When injecting, ask for the interface itself, not any of the implementations.</p> <pre><code>@container.abstract\nclass Engine(abc.ABC):\n    def get_type(self) -&gt; EngineType:\n        raise NotImplementedError()\n\n\n@container.register\nclass CombustionEngine(Engine):\n    @override\n    def get_type(self) -&gt; EngineType:\n        return EngineType.COMBUSTION\n\n\n@container.autowire\ndef target(engine: Engine):\n    engine_type = engine.get_type() # Returns EngineType.COMBUSTION\n    ...\n</code></pre>"},{"location":"interfaces/#multiple-implementations","title":"Multiple implementations","text":"<p>In scenarios where there are multiple implementations of an interface, each implementation must be  associated with a qualifier.</p> <pre><code>@container.register(qualifier=\"electric\")\nclass ElectricEngine(Engine):\n    @override\n    def get_type(self):\n        return EngineType.ELECTRIC\n\n\n@container.register(qualifier=\"combustion\")\nclass CombustionEngine(Engine):\n    @override\n    def get_type(self) -&gt; EngineType:\n        return EngineType.COMBUSTION\n</code></pre> <p>When injecting an interface with multiple implementing dependencies, you need to specify a qualifier to indicate  which concrete class should be resolved.</p> <pre><code>container.autowire\ndef target(\n    engine: Annotated[Engine, Wire(qualifier=\"electric\")],\n    combustion: Annotated[Engine, Wire(qualifier=\"combustion\")],\n):\n    ...\n</code></pre> <p>Tip</p> <p>Qualifiers can be anything, not just strings! For the above example, <code>EngineType</code> enum members could have been used as qualifiers just as well.</p>"},{"location":"introduce_to_an_existing_project/","title":"Introduce to an existing project","text":"<p>It can be challenging to add DI to an existing project which doesn't yet use it. One of the issues you will run into sooner or later is being able to share resources between code which uses DI and the rest of the application  which does not. </p> <p>This is especially useful to allow the container to inject dependencies created elsewhere.</p> <p>Think of a database connection. Your application probably already has one. Instead of opening a second connection using a new database service, you can instruct the container how to get the connection either via a service or by using factory functions.</p> <p>Another case might be an existing service that is already constructed, and you want to inject.</p>"},{"location":"introduce_to_an_existing_project/#using-a-service","title":"Using a Service","text":"<p>A typical way to solve this would involve create a service with a single method  that uses existing functionality to get the desired object and simply returns it.</p> <pre><code># Example of a service acting as a factory\n@container.register\n@dataclass\nclass DbConnectionService:\n    self.conn = get_db_connection_from_somewhere()\n</code></pre> <p>Here, it is possible inject <code>DbConnectionService</code> and call <code>.conn</code> to get the connection. While this works, it's not the best way to go.</p>"},{"location":"introduce_to_an_existing_project/#using-factory-functions","title":"Using Factory functions","text":"<p>To handle this more elegantly, WireUp lets you register functions as factories.  You can do this by using the <code>@container.register</code> decorator or by calling <code>container.register(fn)</code> directly.</p> <pre><code>@container.register\ndef get_db_connection_from_somewhere() -&gt; Connection:\n    return ...\n\n# Alternatively\n\ncontainer.register(get_db_connection_from_somewhere)\n</code></pre> <p>Now it is possible to inject <code>Connection</code> just like any other dependency. </p>"},{"location":"introduce_to_an_existing_project/#links","title":"Links","text":"<ul> <li>Factory functions</li> </ul>"},{"location":"manual_configuration/","title":"Manual configuration","text":"<p>WireUp provides convenient decorators and functions for you to use and perform dependency injection. If using decorators or functions such as <code>wire</code> not appropriate for your application then manual container configuration is also possible.</p>"},{"location":"manual_configuration/#using-wireup-without-registration-decorators","title":"Using wireup without registration decorators","text":"<p>In addition to using <code>@container.register</code> to register each dependency, automatic registration is also possible by using the <code>wireup.register_all_in_module(module, pattern = \"*\")</code> method.</p> <p>Module represents the top level module containing all your dependencies, optionally a <code>fnmatch</code> pattern can be specified to only register classes that match the pattern. This is the equivalent of using <code>@container.register</code> on each.</p> <pre><code>wireup.register_all_in_module(app.service, \"*Service\")\n</code></pre>"},{"location":"manual_configuration/#interfaces","title":"Interfaces","text":"<p>Even though It's not possible to automatically register abstract types and implementation using qualifiers.  Manual registration is still possible.</p> <pre><code>container.abstract(FooBase)\ncontainer.register(FooBar, qualifier=\"bar\")\ncontainer.register(FooBaz, qualifier=\"baz\")\n</code></pre>"},{"location":"manual_configuration/#manually-wiring-parameters","title":"Manually wiring parameters","text":"<p>Given that parameters can't be resolved from type annotations alone, they must be annotated.</p> <p>To achieve the same outcome without relying on annotations, you can use the container's  initialization context. This allows you to manually provide data that the library would  otherwise gather from the decorators or annotations.</p> <p><pre><code>wireup.register_all_in_module(app.services, \"*Service\")\n\n# Register parameters individually using add_param\ncontainer.context.add_dependency(\n    klass=DbService,\n    argument_name=\"connection_str\",\n    value=AnnotatedParameter(annotation=ParameterWrapper(\"connection_str\")),\n)\ncontainer.context.put_param(\n    klass=DbService,\n    argument_name=\"connection_str\",\n    value=AnnotatedParameter(\n        annotation=ParameterWrapper(TemplatedString(\"${cache_dir}/${auth_user}/db\"))\n    ),\n)\n</code></pre> Configuration can also be stored in JSON or YAML documents that can be read and used to update the container accordingly.</p>"},{"location":"manual_configuration/#manually-wiring-services","title":"Manually wiring services","text":"<p>The context's <code>put</code> method will register a new dependency for a particular service type.</p> <p>Tip</p> <p>Make sure to call <code>context.init_target</code> on the class to initialize the registration before calling <code>put</code>.</p> <pre><code>self.context.init_target(MyService)\nself.context.add_dependency(MyService, \"foo\", AnnotatedParameter(klass=DbService))\n</code></pre>"},{"location":"multiple_containers/","title":"Multiple containers","text":"<p>As each container has its own state and does not modify the underlying classes, use of multiple containers is possible. A few things to keep in mind when using multiple containers.</p> <ul> <li>The default <code>wireup.container</code> is simply an instance just like any other.</li> <li>If a dependency belongs to multiple containers you can use decorators on them, but it is preferable you manage register dependencies without the decorators.</li> <li>To wire parameters use initialization context or the <code>wire</code> method. The <code>wire</code> method is not bound to any single container but merely provides hints as to what should be injected. These hints can be read by any container when calling autowire.</li> <li>Use of <code>@autowire</code> decorator with multiple containers is unsupported. To bind parameters and dependencies to a method call <code>instance.autowire(fn)()</code>. The autowire method will return a function where all the arguments that the container knows about are passed.</li> </ul>"},{"location":"optimizing_container/","title":"Optimizing the container","text":"<p>The container can be adjusted for either short or long-lived processes. A short-lived process may be a cli command that is part of a broader application. Whereas a long-lived process may be an Api that listens and serves requests.</p> <p>Note</p> <p>To warm up, use <code>warmup_container</code> from the <code>wireup</code> module.</p>"},{"location":"optimizing_container/#under-the-hood","title":"Under the hood","text":"<p>When decorating with <code>@register</code> or <code>@autowire</code>, the container doesn't know yet the final set of services so when it performs autowiring it injects proxy objects. These act and behave the same way as the real ones but there is a tiny performance penalty when interacting with them.</p> <p>During warmup, the container will assume the current dependency set is the final one and will create only real instances for singleton dependencies that way during autowiring there will be no more proxies.</p>"},{"location":"optimizing_container/#recommendations","title":"Recommendations","text":"<ul> <li>For simple commands which will perform a small number of tasks then exit it is recommended to not use  <code>warmup_container</code>. This will mean that only objects used during the lifetime of the command will be used instead of instantiating all services.</li> <li>For long-lived processes where all these objects will be instantiated anyway, it is recommended to use  <code>warmup_container</code> to minimize performance penalty incurred by autowiring.</li> </ul>"},{"location":"parameters/","title":"Parameters","text":"<p>In addition to service objects, the container also holds configuration, called parameters.</p> <p>Parameters are stored as a flat key-value store. They are able to retrieved at a later time by  services when being constructed. They serve as configuration for services.  Think of a database url or environment name.</p> <p>Warning</p> <p>Parameters represent application configuration.  They are not intended for the developers to pass values around or to be used as a global session object.</p> <p>Store only app configuration such as environment name, database url, mailer url etc.</p>"},{"location":"parameters/#management","title":"Management","text":"<p>Parameters are put in the container using its <code>params</code> property and are referenced by their name. It is possible to add items by calling the <code>.put(name, value)</code> method, or in bulk or by calling <code>.update(dict)</code>  using a dictionary of name-value pairs.</p> <p>To retrieve a parameter by name directly from the container you can call <code>container.params.get(name)</code>.</p> <p>Note</p> <p>Although the value of the parameters can be anything; including classes,  they cannot depend on anything else.  As such, autowiring services or other parameters on them is not possible.</p>"},{"location":"parameters/#injection","title":"Injection","text":"<p>Contrary to services, it is not possible to autowire a parameter solely by its type. To enable autowiring you must annotate the function parameter with the parameter name or expression being injected.</p>"},{"location":"parameters/#by-name","title":"By name","text":"<p>To inject a parameter by name simply call <code>Wire(param=\"param_name\")</code>.</p> <pre><code>@container.autowire\ndef target(cache_dir: Annotated[str, Wire(param=\"cache_dir\")]) -&gt; None:\n    ...\n</code></pre>"},{"location":"parameters/#parameter-expressions","title":"Parameter expressions","text":"<p>It is possible to interpolate parameters using a special syntax. This will enable you to retrieve several parameters at once and concatenate their values together or simply format the value of a single parameter.</p> <pre><code>@container.autowire\ndef target(logs_cache_dir: Annotated[str, Wire(expr=\"${cache_dir}/${env}/logs\")]) -&gt; None:\n    ...\n</code></pre>"},{"location":"parameters/#parameter-enums","title":"Parameter enums","text":"<p>Parameter enums represent an alternative for those who do not want to rely on strings and want to have a typed way to refer to parameter names. You can achieve this by creating a new type inheriting from <code>ParameterEnum</code>.</p> <p><pre><code>class AppParameters(ParameterEnum):\n    cache_dir = \"cache_dir\"\n    # ... other params follow\n</code></pre> Using this we can use the enum member whenever we want to refer to a particular parameter. The main feature of the enum is a <code>wire()</code> method which is syntactic sugar for <code>wire(param=AppParameters.cache_dir.value)</code></p> <pre><code>container.params.put(AppParameters.cache_dir.value, \"/var/cache\")\n\n@container.autowire\ndef do_something_cool(cache_dir: Annotated[str, AppParameters.cache_dir.wire()]) -&gt; None:\n    ...\n</code></pre>"},{"location":"quickstart/","title":"Quickstart","text":"<p>Example showing a Database service, a repository and a web view which uses the repository to fetch all posts  from a fictional blog db.</p> <p>1. Register dependencies</p> <pre><code>from wireup import container\n\n# Parameters serve as configuration for services. \n# Think of a database url or environment name.\ncontainer.params.update(existing_dict_config)\n\n\n@container.register # (1)!\nclass DatabaseService:\n    def __init__(self, connection_url: Annotated[str, Wire(param=\"db_connection_url\")]):\n        self.engine = create_engine(connection_url)\n\n\n# Initializer injection is supported for regular classes as well as dataclasses.\n@container.register\n@dataclass\nclass PostRepository:\n    db: DatabaseService # (2)!\n\n    def find_all(self) -&gt; list[Post]:\n        return self.db.query...\n</code></pre> <ol> <li>Decorators do not modify the classes in any way and only serve to collect metadata. This behavior can make    testing a lot simpler as you can still instantiate this like a regular class in your tests.</li> <li> <ul> <li>Use type hints to indicate which dependency to inject.</li> <li>Services are automatically autowired and do not need the <code>@autowire</code> decorator</li> </ul> </li> </ol> <p>2. Inject</p> <pre><code>@app.get(\"/posts\")\n@container.autowire # (1)!\ndef get_posts(post_repository: PostRepository):\n    return post_repository.find_all()\n</code></pre> <ol> <li>Decorate all methods where the library must perform injection</li> </ol> <p>3. Ready</p> <p>That was it. No, really!</p> <p>Installation</p> <pre><code># Install using poetry:\npoetry add wireup\n\n# Install using pip:\npip install wireup\n</code></pre>"},{"location":"services/","title":"Services","text":"<p>Use service objects to implement functionality in your application. Services can depend on configuration or other services.</p>"},{"location":"services/#registration","title":"Registration","text":"<p>Wireup does not enforce a structure, services may live anywhere in the application but must be registered  with the container.</p> <p>To register a class as a service the following options are available.</p> <ul> <li>Decorate the class using the <code>container.register</code>.</li> <li>Call <code>container.register(YourService)</code> directly on the service.</li> <li>Use <code>wireup.register_all_in_module</code>.   (See: Manual Configuration)</li> </ul>"},{"location":"services/#lifetime","title":"Lifetime","text":"<p>By default, services will be registered as singletons. If your service or Factory function needs to generate a fresh instance every time it is injected it needs to be registered with the <code>lifetime</code> parameter set to <code>TRANSIENT</code>.</p>"},{"location":"services/#injection","title":"Injection","text":"<p>The container will perform autowiring based on the type hints given. Most of the time no manual configuration  is needed to inject services. </p> <p>Tip</p> <p>Refer to the documentation regarding Annotations for the exact details on when you need to explicitly annotate your dependencies.</p>"},{"location":"services/#autowiring","title":"Autowiring","text":"<p>To perform autowiring the method to be autowired must be decorated with <code>@container.autowire</code>. Given the nature of Python decorators it is also possible to simply call it as a regular function which will return a callable where the container will perform dependency injection when called.</p>"},{"location":"versioning/","title":"Versioning","text":"<p>This library adheres to Semantic Versioning (Semver) principles to ensure predictable versioning and compatibility for its users. </p> <ul> <li>Semver consists of three distinct version components: MAJOR, MINOR, and PATCH, separated by dots (e.g., 1.2.3). </li> <li>Changes in the MAJOR version indicate backward-incompatible changes, such as breaking API alterations. </li> <li>MINOR version updates signify new, backward-compatible features or enhancements, while PATCH versions are reserved for backward-compatible bug fixes. </li> <li>All releases with a MAJOR version of 0 are considered pre-release and as such, the api is considered unstable.   Minor-version releases may contain breaking changes as the api evolves.</li> <li>The following is considered public API</li> <li>All direct exports of the <code>wireup</code> package.</li> <li>All accessible objects from the public interface of the above exported objects.</li> </ul> <p>Tip</p> <p>When using a pre-release version, pin the constraint to <code>^0.x</code> so that you don't accidentally upgrade to a version with breaking changes, but are still able to get bug-fix releases.</p>"},{"location":"class/dependency_container/","title":"DependencyContainer","text":"<p>Dependency Injection and Service Locator container registry.</p> <p>This contains all the necessary information to initialize registered classes. Objects instantiated by the container are lazily loaded and initialized only on first use.</p> <p>Provides the following decorators: <code>register</code>, <code>abstract</code> and <code>autowire</code>. Use register on factory functions and concrete classes which are to be injected from the container. Abstract classes are to be used as interfaces and will not be injected directly, rather concrete classes which implement them will be injected instead.</p> <p>Use the <code>autowire</code> decorator on methods where dependency injection must be performed. Services will be injected automatically where possible. Parameters will have to be annotated as they cannot be located from type alone.</p>"},{"location":"class/dependency_container/#wireup.ioc.dependency_container.DependencyContainer-attributes","title":"Attributes","text":""},{"location":"class/dependency_container/#wireup.ioc.dependency_container.DependencyContainer.context","title":"<code>context: InitializationContext</code>  <code>property</code>","text":"<p>The initialization context for registered targets. A map between an injection target and its dependencies.</p>"},{"location":"class/dependency_container/#wireup.ioc.dependency_container.DependencyContainer.params","title":"<code>params: ParameterBag</code>  <code>property</code>","text":"<p>Parameter bag associated with this container.</p>"},{"location":"class/dependency_container/#wireup.ioc.dependency_container.DependencyContainer-functions","title":"Functions","text":""},{"location":"class/dependency_container/#wireup.ioc.dependency_container.DependencyContainer.__init__","title":"<code>__init__(parameter_bag)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>parameter_bag</code> <code>ParameterBag</code> <p>ParameterBag instance holding parameter information.</p> required"},{"location":"class/dependency_container/#wireup.ioc.dependency_container.DependencyContainer.abstract","title":"<code>abstract(klass)</code>","text":"<p>Register a type as an interface.</p> <p>This type cannot be initialized directly and one of the components implementing this will be injected instead.</p>"},{"location":"class/dependency_container/#wireup.ioc.dependency_container.DependencyContainer.autowire","title":"<code>autowire(fn)</code>","text":"<p>Automatically inject resources from the container to the decorated methods.</p> <p>Any arguments which the container does not know about will be ignored so that another decorator or framework can supply their values. This decorator can be used on both async and blocking methods.</p> <ul> <li>Classes will be automatically injected.</li> <li>Parameters need to be annotated in order for container to be able to resolve them</li> <li>When injecting an interface for which there are multiple implementations you need to supply a qualifier   using annotations.</li> </ul>"},{"location":"class/dependency_container/#wireup.ioc.dependency_container.DependencyContainer.get","title":"<code>get(klass, qualifier=None)</code>","text":"<p>Get an instance of the requested type.</p> <p>Use this to locate services by their type but strongly prefer using injection instead.</p> <p>Parameters:</p> Name Type Description Default <code>qualifier</code> <code>ContainerProxyQualifierValue</code> <p>Qualifier for the class if it was registered with one.</p> <code>None</code> <code>klass</code> <code>type</code> <p>Class of the dependency already registered in the container.</p> required <p>Returns:</p> Type Description <code>Any</code> <p>An instance of the requested object. Always returns an existing instance when one is available.</p>"},{"location":"class/dependency_container/#wireup.ioc.dependency_container.DependencyContainer.is_type_known","title":"<code>is_type_known(klass)</code>","text":"<p>Given a class type return True if's registered in the container as a service or interface.</p>"},{"location":"class/dependency_container/#wireup.ioc.dependency_container.DependencyContainer.register","title":"<code>register(obj=None, *, qualifier=None, lifetime=ServiceLifetime.SINGLETON)</code>","text":"<p>Register a dependency in the container.</p> <p>Use <code>@register</code> without parameters on a class or with a single parameter <code>@register(qualifier=name)</code> to register this with a given name when there are multiple implementations of the interface this implements.</p> <p>Use <code>@register</code> on a function to register that function as a factory method which produces an object that matches its return type.</p> <p>The container stores all necessary metadata for this class and the underlying class remains unmodified.</p>"},{"location":"class/dependency_container/#wireup.ioc.dependency_container.DependencyContainer.warmup","title":"<code>warmup()</code>","text":"<p>Initialize all singleton dependencies registered in the container.</p> <p>This should be executed once all services are registered with the container. Targets of autowire will not be affected.</p>"},{"location":"class/flask_integration/","title":"flask_integration","text":""},{"location":"class/flask_integration/#wireup_init_flask_integration","title":"wireup_init_flask_integration","text":"<p>Integrate wireup with a flask application.</p> <p>This must be called once all flask configuration and views have been registered.  Updates the container with flask configuration and decorates all views where container objects  are being used making the <code>@container.autowire</code> decorator no longer needed.</p> <p>Parameters:</p> Name Type Description Default <code>flask_app</code> <code>Flask</code> <p>The flask application instance</p> required <code>service_modules</code> <code>list[ModuleType]</code> <p>A list of python modules where application services reside. These will be loaded to trigger container registrations.</p> required <code>dependency_container</code> <code>DependencyContainer</code> <p>The instance of the dependency container. The default wireup singleton will be used when this is unset. This will be a noop and have no performance penalty for views which do not use the container.</p> <code>container</code> <code>config_prefix</code> <code>str | None</code> <p>If set to a value all registered configuration will be prefixed with config and be accessible via \"prefix.config_name\". E.g: app.DEBUG. This is a noop if config_as_params is False.</p> <code>None</code>"},{"location":"class/initialization_context/","title":"InitializationContext","text":"<p>The initialization context for registered targets. A map between an injection target and its dependencies.</p> <p>Container uses this to determine what to inject for each target.</p>"},{"location":"class/initialization_context/#wireup.ioc.initialization_context.InitializationContext-attributes","title":"Attributes","text":""},{"location":"class/initialization_context/#wireup.ioc.initialization_context.InitializationContext.dependencies","title":"<code>dependencies: Mapping[AutowireTarget, dict[str, AnnotatedParameter]]</code>  <code>property</code>","text":"<p>Read-only view of the dependency definitions.</p>"},{"location":"class/initialization_context/#wireup.ioc.initialization_context.InitializationContext.lifetime","title":"<code>lifetime: Mapping[type, ServiceLifetime]</code>  <code>property</code>","text":"<p>Read-only view of service lifetime mapping.</p>"},{"location":"class/initialization_context/#wireup.ioc.initialization_context.InitializationContext-functions","title":"Functions","text":""},{"location":"class/initialization_context/#wireup.ioc.initialization_context.InitializationContext.__init__","title":"<code>__init__()</code>","text":"<p>Create a new InitializationContext.</p>"},{"location":"class/initialization_context/#wireup.ioc.initialization_context.InitializationContext.add_dependency","title":"<code>add_dependency(target, parameter_name, value)</code>","text":"<p>Update the mapping of dependencies for a particular target.</p> <p>Registers a new dependency for the parameter in parameter_name. Target must have been already initialized prior to calling this.</p>"},{"location":"class/initialization_context/#wireup.ioc.initialization_context.InitializationContext.init_target","title":"<code>init_target(target, lifetime=None)</code>","text":"<p>Initialize the context for a particular target.</p> <p>Returns true on first call. If the target is already registered it returns False.</p>"},{"location":"class/initialization_context/#wireup.ioc.initialization_context.InitializationContext.remove_dependencies","title":"<code>remove_dependencies(target, names_to_remove)</code>","text":"<p>Remove dependencies with names in <code>names_to_remove</code> from the given target.</p> <p>Target must have been already initialized prior to calling this.</p>"},{"location":"class/parameter_bag/","title":"ParameterBag","text":"<p>Parameter flat key-value store for use with a container.</p> <p>Allows storing and retrieving of parameters in the bag. Templated strings can be used to interpolate a string referencing parameters.</p>"},{"location":"class/parameter_bag/#wireup.ioc.parameter.ParameterBag-functions","title":"Functions","text":""},{"location":"class/parameter_bag/#wireup.ioc.parameter.ParameterBag.__init__","title":"<code>__init__()</code>","text":"<p>Initialize an empty ParameterBag.</p> <p>ParameterBag holds a flat key-value store of parameter values. __bag: A dictionary to store parameter values. __cache: A cache for interpolated values. __param_cache: A dictionary to keep track of which cache entries involve each parameter.</p>"},{"location":"class/parameter_bag/#wireup.ioc.parameter.ParameterBag.get","title":"<code>get(param)</code>","text":"<p>Get the value of a parameter.</p> <p>If the parameter is templated, interpolate it first by replacing placeholders with parameter values.</p> <p>Parameters:</p> Name Type Description Default <code>param</code> <code>ParameterReference</code> <p>The parameter to retrieve.</p> required <p>Returns:</p> Type Description <code>Any</code> <p>The parameter's value.</p>"},{"location":"class/parameter_bag/#wireup.ioc.parameter.ParameterBag.get_all","title":"<code>get_all()</code>","text":"<p>Get all parameters stored in the bag.</p> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>A dictionary containing all parameter names and their values.</p>"},{"location":"class/parameter_bag/#wireup.ioc.parameter.ParameterBag.put","title":"<code>put(name, val)</code>","text":"<p>Put a parameter value into the bag. This overwrites any previous values.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the parameter.</p> required <code>val</code> <code>Any</code> <p>The value of the parameter.</p> required"},{"location":"class/parameter_bag/#wireup.ioc.parameter.ParameterBag.update","title":"<code>update(new_params)</code>","text":"<p>Update the bag with new set of parameters.</p> <p>Parameters from new_params will overwrite any existing parameters set with the same name.</p> <p>Parameters:</p> Name Type Description Default <code>new_params</code> <code>dict[str, Any]</code> <p>A dictionary of parameter names and their updated values.</p> required"},{"location":"class/parameter_enum/","title":"ParameterEnum","text":"<p>             Bases: <code>Enum</code></p> <p>Enum with a <code>.wire</code> method allowing easy injection of members.</p> <p>Allows you to add application parameters as enum members and their names as values. When you need to inject a parameter instead of referencing it by name you can annotate the parameter with the wire function call or set that as the default value.</p> <p>This will inject a parameter by name and won't work with expressions.</p>"},{"location":"class/parameter_enum/#wireup.ParameterEnum-functions","title":"Functions","text":""},{"location":"class/parameter_enum/#wireup.ParameterEnum.wire","title":"<code>wire()</code>","text":"<p>Inject the parameter this enumeration member represents.</p> <p>Equivalent of <code>wire(param=EnumParam.enum_member.value)</code></p>"},{"location":"class/wireup/","title":"wireup","text":""},{"location":"class/wireup/#wireup.container","title":"<code>wireup.container = DependencyContainer(ParameterBag())</code>  <code>module-attribute</code>","text":"<p>Singleton DI container instance.</p> <p>Use when your application only needs one container.</p>"},{"location":"class/wireup/#wireup.wire","title":"<code>wireup.wire(*, param=None, expr=None, qualifier=None)</code>","text":"<p>Inject resources from the container to autowired method arguments.</p> <p>Arguments are exclusive and only one of them must be used at any time.</p> <p>Note</p> <p>Methods MUST be still decorated with autowire for this to work.</p> <p>Parameters:</p> Name Type Description Default <code>param</code> <code>str | None</code> <p>Inject a given parameter by name.</p> <code>None</code> <code>expr</code> <code>str | None</code> <p>Inject a string value using a templated string. Parameters inside <code>${}</code> will be replaced with their corresponding value.</p> <code>None</code> <code>qualifier</code> <code>ContainerProxyQualifierValue</code> <p>Qualify which implementation to bind when there are multiple components implementing an interface that is registered in the container via <code>@abstract</code>.</p> <code>None</code>"}]}